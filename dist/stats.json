{"errors":[],"warnings":[],"version":"3.12.0","hash":"fdd6de174f9f4ac9d2e5","publicPath":"","assetsByChunkName":{"main":"chat-engine.js"},"assets":[{"name":"chat-engine.js","size":309502,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"filteredAssets":0,"entrypoints":{"main":{"chunks":[0],"assets":["chat-engine.js"]}},"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":298813,"names":["main"],"files":["chat-engine.js"],"hash":"9a2c1bdccadafa10e315","parents":[],"modules":[{"id":1,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":63,"index2":62,"size":9673,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":102,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":27,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"11:14-43"},{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"14:14-43"},{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"9:14-43"},{"moduleId":100,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/session.js","module":"./src/components/session.js","moduleName":"./src/components/session.js","type":"cjs require","userRequest":"../modules/emitter","loc":"11:14-43"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar waterfall = require('async/waterfall');\nvar RootEmitter = require('./root_emitter');\nvar Event = require('../components/event');\n\nvar augmentSender = require('../plugins/augment/sender');\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\n\nvar Emitter = function (_RootEmitter) {\n    _inherits(Emitter, _RootEmitter);\n\n    function Emitter(chatEngine) {\n        _classCallCheck(this, Emitter);\n\n        var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        _this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        _this._dataset = {};\n\n        _this.plugin(augmentSender(chatEngine));\n\n        /**\n         Emit events locally.\n          @private\n         @param {String} event The event payload object\n         */\n        _this._emit = function (event) {\n            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            _this.chatEngine._emit(event, data, _this);\n\n            // emit the event from the object that created it\n            _this.emitter.emit(event, data);\n\n            return _this;\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        _this.on = function (event, cb) {\n\n            // keep track of all events on this emitter\n            _this.events[event] = _this.events[event] || new Event(_this.chatEngine, _this, event);\n\n            // call the private _on property\n            _this._on(event, cb);\n\n            return _this;\n        };\n\n        return _this;\n    }\n\n    // add an object as a subobject under a namespoace\n\n\n    _createClass(Emitter, [{\n        key: 'addChild',\n        value: function addChild(childName, childOb) {\n            // assign the new child object as a property of parent under the\n            // given namespace\n            this[childName] = childOb;\n\n            // assign a data set for the namespace if it doesn't exist\n            if (!this._dataset[childName]) {\n                this._dataset[childName] = {};\n            }\n\n            // the new object can use ```this.parent``` to access\n            // the root class\n            childOb.parent = this;\n\n            // bind get() and set() to the data set\n            childOb.get = this.get.bind(this._dataset[childName]);\n            childOb.set = this.set.bind(this._dataset[childName]);\n        }\n    }, {\n        key: 'get',\n        value: function get(key) {\n            return this[key];\n        }\n    }, {\n        key: 'set',\n        value: function set(key, value) {\n            if (this[key] && !value) {\n                delete this[key];\n            } else {\n                this[key] = value;\n            }\n        }\n\n        /**\n         Binds a plugin to this object\n         @param {Object} module The plugin module\n         @tutorial using\n         */\n\n    }, {\n        key: 'plugin',\n        value: function plugin(module) {\n\n            // add this plugin to a list of plugins for this object\n            this.plugins.push(module);\n\n            // see if there are plugins to attach to this class\n            if (module.extends && module.extends[this.name]) {\n                // attach the plugins to this class\n                // under their namespace\n                this.addChild(module.namespace, new module.extends[this.name]());\n\n                this[module.namespace].ChatEngine = this.chatEngine;\n\n                // if the plugin has a special construct function\n                // run it\n                if (this[module.namespace].construct) {\n                    this[module.namespace].construct();\n                }\n            }\n\n            return this;\n        }\n    }, {\n        key: 'bindProtoPlugins',\n        value: function bindProtoPlugins() {\n            var _this2 = this;\n\n            if (this.chatEngine.protoPlugins[this.name]) {\n\n                this.chatEngine.protoPlugins[this.name].forEach(function (module) {\n                    _this2.plugin(module);\n                });\n            }\n        }\n\n        /**\n         Broadcasts an event locally to all listeners.\n         @private\n         @param {String} event The event name\n         @param {Object} payload The event payload object\n         */\n\n    }, {\n        key: 'trigger',\n        value: function trigger(event) {\n            var _this3 = this;\n\n            var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, function (next) {\n                next(null, payload);\n            }, function (reject, pluginResponse) {\n\n                if (reject) {\n                    done(reject);\n                } else {\n\n                    // emit this event to any listener\n                    _this3._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n            });\n        }\n\n        /**\n         Load plugins and attach a queue of functions to execute before and\n         after events are trigger or received.\n          @private\n         @param {String} location Where in the middleeware the event should run (emit, trigger)\n         @param {String} event The event name\n         @param {String} first The first function to run before the plugins have run\n         @param {String} last The last function to run after the plugins have run\n         */\n\n    }, {\n        key: 'runPluginQueue',\n        value: function runPluginQueue(location, event, first, last) {\n\n            // this assembles a queue of functions to run as middleware\n            // event is a triggered event key\n            var pluginQueue = [];\n\n            // the first function is always required\n            pluginQueue.push(first);\n\n            // look through the configured plugins\n            this.plugins.forEach(function (pluginItem) {\n\n                // if they have defined a function to run specifically\n                // for this event\n                if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                    if (pluginItem.middleware[location][event]) {\n                        // add the function to the queue\n                        pluginQueue.push(pluginItem.middleware[location][event]);\n                    }\n\n                    if (pluginItem.middleware[location]['*']) {\n                        // add the function to the queue\n                        pluginQueue.push(pluginItem.middleware[location]['*']);\n                    }\n                }\n            });\n\n            // waterfall runs the functions in assigned order\n            // waiting for one to complete before moving to the next\n            // when it's done, the ```last``` parameter is called\n            waterfall(pluginQueue, last);\n        }\n    }, {\n        key: 'onConstructed',\n        value: function onConstructed() {\n\n            this.bindProtoPlugins();\n            this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n        }\n    }]);\n\n    return Emitter;\n}(RootEmitter);\n\nmodule.exports = Emitter;"},{"id":3,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":3966,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":11,"building":37},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"12:18-43"},{"moduleId":23,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/event.js","module":"./src/components/event.js","moduleName":"./src/components/event.js","type":"cjs require","userRequest":"../modules/root_emitter","loc":"11:14-48"},{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"7:18-51"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\n\nvar RootEmitter = function RootEmitter() {\n    var _this = this;\n\n    _classCallCheck(this, RootEmitter);\n\n    /**\n    * @private\n    */\n    this.events = {};\n\n    this.name = 'RootEmitter';\n\n    /**\n    Create a new EventEmitter2 object for this class.\n     @private\n    */\n    this.emitter = new EventEmitter2({\n        wildcard: true,\n        newListener: true,\n        maxListeners: 50,\n        verboseMemoryLeak: true\n    });\n\n    // we bind to make sure wildcards work\n    // https://github.com/asyncly/EventEmitter2/issues/186\n\n    /**\n    Private emit method that broadcasts the event to listeners on this page.\n     @private\n    @param {String} event The event name\n    @param {Object} the event payload\n    */\n    this._emit = this.emitter.emit.bind(this.emitter);\n\n    /**\n    Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n     @private\n    @param {String} event The event name\n    @param {Function} callback The function to run when the event is emitted\n    */\n\n    this._on = this.emitter.on.bind(this.emitter);\n\n    /**\n    * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n    * @method\n    * @param {String} event The event name\n    * @param {Function} cb The function to run when the event is emitted\n    * @example\n    *\n    * // Get notified whenever someone joins the room\n    * object.on('event', (payload) => {\n    *     console.log('event was fired').\n    * })\n    *\n    * // Get notified of event.a and event.b\n    * object.on('event.*', (payload) => {\n    *     console.log('event.a or event.b was fired').;\n    * })\n    */\n    this.on = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.on(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Stop a callback from listening to an event.\n    * @method\n    * @param {String} event The event name\n    * @example\n    * let callback = function(payload;) {\n    *    console.log('something happend!');\n    * };\n    * object.on('event', callback);\n    * // ...\n    * object.off('event', callback);\n    */\n    this.off = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.off(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Listen for any event on this object and fire a callback when it's emitted\n    * @method\n    * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n    * @example\n    * object.onAny((event, payload) => {\n    *     console.log('All events trigger this.');\n    * });\n    */\n    this.onAny = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.onAny(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Listen for an event and only fire the callback a single time\n    * @method\n    * @param {String} event The event name\n    * @param {Function} callback The function to run once\n    * @example\n    * object.once('message', => (event, payload) {\n    *     console.log('This is only fired once!');\n    * });\n    */\n    this.once = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.once(event, callback);\n\n        return _this;\n    };\n};\n\nmodule.exports = RootEmitter;"},{"id":23,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":64,"index2":60,"size":4177,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":264,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"13:12-42"},{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"15:12-42"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/root_emitter');\n\n/**\n * @class Event\n * Represents an {@link Chat} event.\n * @fires $\".\"emitted\n * @extends Emitter\n * @extends RootEmitter\n */\n\nvar Event = function (_Emitter) {\n  _inherits(Event, _Emitter);\n\n  function Event(chatEngine, chat, event) {\n    var _ret;\n\n    _classCallCheck(this, Event);\n\n    /**\n     * @private\n     */\n    var _this = _possibleConstructorReturn(this, (Event.__proto__ || Object.getPrototypeOf(Event)).call(this));\n\n    _this.chatEngine = chatEngine;\n\n    /**\n     * The {@link Chat#channel} that this event is registered to.\n     * @type String\n     * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n     * @readonly\n     */\n    _this.channel = chat.channel;\n\n    /**\n     * Events are always a property of a {@link Chat}. Responsible for\n     * listening to specific events and firing events when they occur.\n     * @readonly\n     * @type {Chat}\n     */\n    _this.chat = chat;\n\n    /**\n     * The string representation of the event. This is supplied as the first parameter to {@link Chat#on}\n     * @type {String}\n     */\n    _this.event = event;\n\n    /**\n     * A name that identifies this class\n     * @type {String}\n     */\n    _this.name = 'Event';\n\n    return _ret = _this, _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   Publishes the event over the PubNub network to the {@link Event} channel\n    @private\n   @param {Object} data The event payload object\n   */\n\n\n  _createClass(Event, [{\n    key: 'publish',\n    value: function publish(m) {\n      var _this2 = this;\n\n      m.event = this.event;\n\n      var storeInHistory = true;\n\n      // don't store in history if $.system event\n      if (!this.event.indexOf('$.system')) {\n        storeInHistory = false;\n      }\n\n      this.chatEngine.pubnub.publish({\n        message: m,\n        channel: this.channel,\n        storeInHistory: storeInHistory\n      }, function (status, response) {\n\n        if (status.statusCode === 200) {\n\n          if (response) {\n            m.timetoken = response.timetoken;\n          }\n\n          /**\n           * Message successfully published\n           * @event Event#$\".\"emitted\"\n           * @param {Object} data The message payload\n           */\n          _this2._emit('$.emitted', m);\n        } else {\n\n          /**\n           * There was a problem publishing over the PubNub network.\n           * @event Chat#$\".\"error\".\"publish\n           */\n          _this2.chatEngine.throwError(_this2, '_emit', 'emitter', new Error('There was a problem publishing over the PubNub network.'), status);\n        }\n      });\n    }\n  }]);\n\n  return Event;\n}(Emitter);\n\nmodule.exports = Event;"},{"id":26,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":81,"index2":70,"size":517,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","issuerId":82,"issuerName":"./node_modules/lodash/isBuffer.js","profile":{"factory":22,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":82,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":88,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":11,"source":"module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n"},{"id":27,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":99,"index2":96,"size":6752,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":335,"dependencies":16},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"10:11-39"},{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"13:11-28"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\n\nvar User = function (_Emitter) {\n    _inherits(User, _Emitter);\n\n    function User(chatEngine, uuid) {\n        var _ret;\n\n        var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, User);\n\n        var _this = _possibleConstructorReturn(this, (User.__proto__ || Object.getPrototypeOf(User)).call(this));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n          @readonly\n         @type String\n         */\n        _this.uuid = uuid.toString();\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        _this.state = state;\n\n        _this._stateSet = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        _this.feed = new _this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, _this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        _this.direct = new _this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, _this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = _this;\n        }\n\n        if (Object.keys(state).length) {\n            // update this user's state in it's created context\n            _this.assign(state);\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     this is only called from network updates\n     @private\n     */\n\n\n    _createClass(User, [{\n        key: 'assign',\n        value: function assign(state) {\n\n            var oldState = this.state || {};\n            this.state = Object.assign(oldState, state);\n\n            this._stateSet = true;\n        }\n\n        /**\n         * @private\n         * @param {Object} state The new state for the user\n         */\n\n    }, {\n        key: 'update',\n        value: function update(state) {\n            this.assign(state);\n        }\n\n        /**\n        Get stored user state from remote server.\n        @private\n        */\n\n    }, {\n        key: '_getStoredState',\n        value: function _getStoredState(callback) {\n            var _this2 = this;\n\n            if (!this._stateSet) {\n\n                this.chatEngine.request('get', 'user_state', {\n                    user: this.uuid\n                }).then(function (res) {\n\n                    _this2.assign(res.data);\n                    callback(_this2.state);\n                }).catch(function (err) {\n                    _this2.chatEngine.throwError(_this2, 'trigger', 'getState', err);\n                });\n            } else {\n                callback(this.state);\n            }\n        }\n    }]);\n\n    return User;\n}(Emitter);\n\nmodule.exports = User;"},{"id":28,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":100,"size":2628,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":26,"building":187},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"'use strict';\n\nvar init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/web-javascript/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.enableSync] {Boolean} Synchronizes chats between instances with the same {@link Me#uuid}. See {@link Me#sync}.\n@param [ceConfig.enableMeta] {Boolean} Persists {@link Chat#meta} on the server. See {@link Chat#update}.\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console This should not be enabled in production.\n@param [ceConfig.profile] {Boolean} Sums event counts and outputs a table to the console every few seconds.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nvar create = function create(pnConfig) {\n    var ceConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    if (typeof ceConfig.enableSync === 'undefined') {\n        ceConfig.enableSync = false;\n    }\n\n    if (typeof ceConfig.enableMeta === 'undefined') {\n        ceConfig.enableMeta = false;\n    }\n\n    ceConfig.endpoint = ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + pnConfig.subscribeKey + '/chat-engine-server';\n\n    pnConfig.heartbeatInterval = pnConfig.heartbeatInterval || 0;\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n};\n\n// export the ChatEngine api\nvar ChatEngineCore = {\n    plugin: {},\n    create: create\n};\n\nmodule.exports = ChatEngineCore;\n\nmodule.exports.ChatEngineCore = ChatEngineCore;"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":99,"size":19552,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","issuerId":28,"issuerName":"./src/index.js","profile":{"factory":3,"building":181},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":28,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"3:11-33"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"'use strict';\n\nvar axios = require('axios');\nvar PubNub = require('pubnub');\nvar pack = require('../package.json');\n\nvar RootEmitter = require('./modules/root_emitter');\nvar Chat = require('./components/chat');\nvar Me = require('./components/me');\nvar User = require('./components/user');\nvar waterfall = require('async/waterfall');\n\n/**\n@class ChatEngine\n@extends RootEmitter\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n*/\nmodule.exports = function () {\n    var ceConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var pnConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    // Create the root ChatEngine object\n    var ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = function (self, cb, key, ceError) {\n        var payload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n    };\n\n    if (ceConfig.debug) {\n\n        ChatEngine.onAny(function (event, payload) {\n            console.info('debug:', event, payload);\n        });\n    }\n\n    if (ceConfig.profile) {\n\n        var countObject = {};\n\n        ChatEngine.onAny(function (event) {\n            countObject['event: ' + event] = countObject[event] || 0;\n            countObject['event: ' + event] += 1;\n        });\n\n        setInterval(function () {\n\n            countObject.chats = Object.keys(ChatEngine.chats).length;\n            countObject.users = Object.keys(ChatEngine.users).length;\n\n            console.table(countObject);\n        }, 3000);\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = function (className, plugin) {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = function (method, route) {\n        var inputBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var inputParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\n        var body = {\n            uuid: ChatEngine.pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authKey: ChatEngine.pnConfig.authKey\n        };\n\n        var params = {\n            route: route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params: params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params: params });\n        }\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = function (channel) {\n\n        var info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = function () {\n        var original = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date().getTime();\n        var isPrivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\n        var channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        var chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n    };\n\n    /**\n     * Initial communication with the server. Server grants permissions to\n     * talk in chats, etc.\n     * @private\n     */\n    ChatEngine.handshake = function (complete) {\n\n        waterfall([function (next) {\n            ChatEngine.request('post', 'bootstrap').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'user_read').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'user_write').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'group').then(function () {\n                next();\n            }).catch(next);\n        }], function (error) {\n\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').' + error && error.response && error.response.data), { error: error });\n            } else {\n                complete();\n            }\n        });\n    };\n\n    /**\n     * Listen to PubNub events and forward them into ChatEngine system.\n     * @private\n     */\n    ChatEngine.listenToPubNub = function () {\n\n        ChatEngine.pubnub.addListener({\n            message: function message(m) {\n\n                // assign the message timetoken as a property of the payload\n                m.message.timetoken = m.timetoken;\n\n                if (ChatEngine.chats[m.channel]) {\n                    ChatEngine.chats[m.channel].trigger(m.message.event, m.message);\n                }\n            },\n            presence: function presence(payload) {\n\n                if (ChatEngine.chats[payload.channel]) {\n                    ChatEngine.chats[payload.channel].onPresence(payload);\n                }\n            },\n            status: function status(statusEvent) {\n\n                /**\n                 * SDK detected that network is online.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"online\n                 */\n\n                /**\n                 * SDK detected that network is down.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                 */\n\n                /**\n                 * A subscribe event experienced an exception when running.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                 */\n\n                /**\n                 * SDK was able to reconnect to pubnub.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                 */\n\n                /**\n                 * SDK subscribed with a new mix of channels.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                 */\n\n                /**\n                 * JSON parsing crashed.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                 */\n\n                /**\n                 * Server rejected the request.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                 */\n\n                /**\n                 * If using decryption strategies and the decryption fails.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                 */\n\n                /**\n                 * Request timed out.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                 */\n\n                /**\n                 * PAM permission failure.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                 */\n\n                // map the pubnub events into ChatEngine events\n                var categories = {\n                    PNNetworkUpCategory: 'up.online',\n                    PNNetworkDownCategory: 'down.offline',\n                    PNNetworkIssuesCategory: 'down.issue',\n                    PNReconnectedCategory: 'up.reconnected',\n                    PNConnectedCategory: 'up.connected',\n                    PNAccessDeniedCategory: 'down.denied',\n                    PNMalformedResponseCategory: 'down.malformed',\n                    PNBadRequestCategory: 'down.badrequest',\n                    PNDecryptionErrorCategory: 'down.decryption',\n                    PNTimeoutCategory: 'down.timeout'\n                };\n\n                var eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                ChatEngine._emit(eventName, statusEvent);\n            }\n        });\n    };\n\n    /**\n     * Subscribe to PubNub and begin receiving events.\n     * @private\n     */\n    ChatEngine.subscribeToPubNub = function () {\n\n        var chanGroups = [ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms', ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system', ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'];\n\n        ChatEngine.pubnub.subscribe({\n            channelGroups: chanGroups,\n            withPresence: true\n        });\n    };\n\n    /**\n     * Initialize ChatEngine modules on first time boot.\n     * @private\n     */\n    ChatEngine.firstConnect = function (state) {\n\n        ChatEngine.pubnub = new PubNub(ChatEngine.pnConfig);\n\n        // create a new chat to use as global chat\n        // we don't do auth on this one because it's assumed to be done with the /auth request below\n        ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n        ChatEngine.global.once('$.connected', function () {\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, ChatEngine.pnConfig.uuid);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            if (ChatEngine.ceConfig.enableSync) {\n                ChatEngine.me.session.subscribe();\n            }\n\n            ChatEngine.me.update(state, function () {\n\n                /**\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\n                 * @event ChatEngine#$\".\"ready\n                 * @example\n                 * ChatEngine.on('$.ready', (data) => {\n                 *     let me = data.me;\n                 * })\n                 */\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.ready = true;\n\n                ChatEngine.listenToPubNub();\n                ChatEngine.subscribeToPubNub();\n\n                ChatEngine.global.getUserUpdates();\n\n                if (ChatEngine.ceConfig.enableSync) {\n                    ChatEngine.me.session.restore();\n                }\n            });\n        });\n    };\n\n    /**\n     * Disconnect from all {@link Chat}s and mark them as asleep.\n     * @method ChatEngine#disconnect\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // every individual chat will be disconnected\n     * chat.on('$.disconnected', () => {\n     *     done();\n     * });\n     *\n     * // Changing User:\n     * ChatEngine.disconnect()\n     * ChatEngine = new ChatEngine({}, {});\n     * ChatEngine.connect()\n     */\n    ChatEngine.disconnect = function () {\n\n        // Unsubscribe from all PubNub chats\n        ChatEngine.pubnub.unsubscribeAll();\n\n        // for every chat in ChatEngine.chats, signal disconnected\n        Object.keys(ChatEngine.chats).forEach(function (key) {\n            ChatEngine.chats[key].sleep();\n        });\n    };\n\n    /**\n     * Performs authentication with server and restores connection\n     * to all sleeping chats.\n     * @method ChatEngine#reconnect\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // reconnect sometime later\n     * ChatEngine.reconnect();\n     *\n     */\n    ChatEngine.reconnect = function () {\n\n        // do the whole auth flow with the new authKey\n        ChatEngine.handshake(function () {\n\n            // for every chat in ChatEngine.chats, call .connect()\n            Object.keys(ChatEngine.chats).forEach(function (key) {\n                ChatEngine.chats[key].wake();\n            });\n\n            ChatEngine.subscribeToPubNub();\n        });\n    };\n\n    /**\n    @private\n    */\n    ChatEngine.setAuth = function () {\n        var authKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PubNub.generateUUID();\n\n\n        ChatEngine.pnConfig.authKey = authKey;\n        ChatEngine.pubnub.setAuthKey(authKey);\n    };\n\n    /**\n     * Disconnects, changes authentication token, performs handshake with server\n     * and reconnects with new auth key. Used for extending logged in sessions\n     * for active users.\n     * @method ChatEngine#reauthorize\n     * @example\n     * // early\n     * ChatEngine.connect(...);\n     *\n     * ChatEngine.once('$.connected', () => {\n     *     // first connection established\n     * });\n     *\n     * // some time passes, session token expires\n     * ChatEngine.reauthorize(authKey);\n     *\n     * // we are connected again\n     * ChatEngine.once('$.connected', () => {\n     *     // we are connected again\n     * });\n     */\n    ChatEngine.reauthorize = function () {\n        var authKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PubNub.generateUUID();\n\n\n        ChatEngine.global.once('$.disconnected', function () {\n\n            ChatEngine.setAuth(authKey);\n            ChatEngine.reconnect();\n        });\n\n        ChatEngine.disconnect();\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = function (uuid) {\n        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var authKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubNub.generateUUID();\n\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        ChatEngine.pnConfig.uuid = uuid;\n        ChatEngine.pnConfig.authKey = authKey;\n\n        ChatEngine.handshake(function () {\n            ChatEngine.firstConnect(state);\n        });\n    };\n\n    ChatEngine.destroy = function () {\n\n        Object.keys(ChatEngine.chats).forEach(function (chat) {\n            ChatEngine.chats[chat].emitter.removeAllListeners();\n        });\n\n        Object.keys(ChatEngine.users).forEach(function (user) {\n            ChatEngine.users[user].emitter.removeAllListeners();\n        });\n\n        ChatEngine.emitter.removeAllListeners();\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function createChat() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        var internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            var newChat = new (Function.prototype.bind.apply(Chat, [null].concat([ChatEngine], args)))();\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n        }\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function createUser() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            var newUser = new (Function.prototype.bind.apply(User, [null].concat([ChatEngine], args)))();\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n        }\n    };\n\n    return ChatEngine;\n};"},{"id":50,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1494,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":365,"building":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"5:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.9.18\",\"description\":\"ChatEngine\",\"browser\":\"dist/chat-engine.js\",\"main\":\"src/index.js\",\"react-native\":\"src/index.js\",\"scripts\":{\"build\":\"gulp\",\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"babel-loader\":\"^7.1.4\",\"babel-preset-es2015\":\"^6.24.1\",\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"decache\":\"^4.3.0\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"2.1.2\",\"axios\":\"0.16.2\",\"eventemitter2\":\"2.2.1\",\"pubnub\":\"4.20.2\"}}"},{"id":52,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":95,"size":30144,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":11,"building":249,"dependencies":89},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"8:11-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar waterfall = require('async/waterfall');\nvar Emitter = require('../modules/emitter');\nvar Event = require('../components/event');\nvar Search = require('../components/search');\n\nvar augmentChat = require('../plugins/augment/chat');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link Me.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\n\nvar Chat = function (_Emitter) {\n    _inherits(Chat, _Emitter);\n\n    function Chat(chatEngine) {\n        var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date().getTime();\n        var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var autoConnect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n        var _ret;\n\n        var group = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'custom';\n\n        _classCallCheck(this, Chat);\n\n        var _this = _possibleConstructorReturn(this, (Chat.__proto__ || Object.getPrototypeOf(Chat)).call(this, chatEngine));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'Chat';\n\n        _this.plugin(augmentChat(_this));\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        _this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        _this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        _this.meta = meta || {};\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        _this.channel = _this.chatEngine.augmentChannel(channel, _this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n          @type Object\n         @readonly\n         */\n        _this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        _this.connected = false;\n\n        /**\n         * Keep a record if we've every successfully connected to this chat before.\n         * @type {Boolean}\n         */\n        _this.hasConnected = false;\n\n        /**\n         * If user manually disconnects via {@link ChatEngine#disconnect}, the\n         * chat is put to \"sleep\". If a connection is reestablished\n         * via {@link ChatEngine#reconnect}, sleeping chats reconnect automatically.\n         * @type {Boolean}\n         */\n        _this.asleep = false;\n\n        _this.chatEngine.chats[_this.channel] = _this;\n\n        if (autoConnect) {\n            _this.connect();\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n      @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n\n\n    _createClass(Chat, [{\n        key: 'onHereNow',\n        value: function onHereNow(status, response) {\n            var _this2 = this;\n\n            if (status.error) {\n\n                /**\n                 * There was a problem fetching the presence of this chat\n                 * @event Chat#$\".\"error\".\"presence\n                 */\n                this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'));\n            } else {\n\n                // get the list of occupants in this channel\n                var occupants = response.channels[this.channel].occupants;\n\n                // format the userList for rltm.js standard\n                occupants.forEach(function (occupant) {\n                    _this2.userUpdate(occupant.uuid, occupant.state);\n                });\n            }\n        }\n\n        /**\n        * Turns a {@link Chat} into a JSON representation.\n        * @return {Object}\n        */\n\n    }, {\n        key: 'objectify',\n        value: function objectify() {\n\n            return {\n                channel: this.channel,\n                group: this.group,\n                private: this.isPrivate,\n                meta: this.meta\n            };\n        }\n\n        /**\n         * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n         * @param {User} user The {@link User} to invite to this chatroom.\n         * @fires Me#event:$\".\"invite\n         * @example\n         * // one user running ChatEngine\n         * let secretChat = new ChatEngine.Chat('secret-channel');\n         * secretChat.invite(someoneElse);\n         *\n         * // someoneElse in another instance of ChatEngine\n         * me.direct.on('$.invite', (payload) => {\n         *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n         * });\n         */\n\n    }, {\n        key: 'invite',\n        value: function invite(user) {\n            var _this3 = this;\n\n            this.chatEngine.request('post', 'invite', {\n                to: user.uuid,\n                chat: this.objectify()\n            }).then(function () {\n\n                var send = function send() {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: _this3.channel\n                    });\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n            }).catch(function (error) {\n                _this3.chatEngine.throwError(_this3, 'trigger', 'search', new Error('Something went wrong while making a request to authentication server.'), { error: error });\n            });\n        }\n\n        /**\n         Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n          @private\n         @param {Object} data The PubNub presence response for this event\n         */\n\n    }, {\n        key: 'onPresence',\n        value: function onPresence(presenceEvent) {\n\n            // make sure channel matches this channel\n\n            // someone joins channel\n            if (presenceEvent.action === 'join') {\n                this.userJoin(presenceEvent.uuid, presenceEvent.state);\n            }\n\n            // someone leaves channel\n            if (presenceEvent.action === 'leave') {\n                this.userLeave(presenceEvent.uuid);\n            }\n\n            // someone timesout\n            if (presenceEvent.action === 'timeout') {\n                this.userDisconnect(presenceEvent.uuid);\n            }\n\n            // someone's state is updated\n            if (presenceEvent.action === 'state-change') {\n                this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n            }\n        }\n\n        /**\n         * Update the {@link Chat} metadata on the server.\n         * @param  {object} data JSON object representing chat metadta.\n         */\n\n    }, {\n        key: 'update',\n        value: function update(data) {\n            var _this4 = this;\n\n            var oldMeta = this.meta || {};\n            this.meta = Object.assign(oldMeta, data);\n\n            this.chatEngine.request('post', 'chat', {\n                chat: this.objectify()\n            }).then(function () {}).catch(function (error) {\n                _this4.chatEngine.throwError(_this4, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error: error });\n            });\n        }\n\n        /**\n         * Send events to other clients in this {@link User}.\n         * Events are trigger over the network  and all events are made\n         * on behalf of {@link Me}\n         *\n         * @param {String} event The event name\n         * @param {Object} data The event payload object\n         * @example\n         * chat.emit('custom-event', {value: true});\n         * chat.on('custom-event', (payload) => {\n          *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n          * });\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n\n            if (event === 'message' && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n                throw new Error('the payload has to be an object');\n            }\n\n            // create a standardized payload object\n            var payload = {\n                data: data, // the data supplied from params\n                sender: this.chatEngine.me.uuid, // my own uuid\n                chat: this, // an instance of this chat\n                event: event,\n                chatengineSDK: this.chatEngine.package.version\n            };\n\n            var tracer = new Event(this.chatEngine, this, event);\n\n            // run the plugin queue to modify the event\n            this.runPluginQueue('emit', event, function (next) {\n                next(null, payload);\n            }, function (err, pluginResponse) {\n\n                // remove chat otherwise it would be serialized\n                // instead, it's rebuilt on the other end.\n                // see this.trigger\n                delete pluginResponse.chat;\n\n                // publish the event and data over the configured channel\n                tracer.publish(pluginResponse);\n            });\n\n            return tracer;\n        }\n\n        /**\n         Add a user to the {@link Chat}, creating it if it doesn't already exist.\n          @private\n         @param {String} uuid The user uuid\n         @param {Object} state The user initial state\n         @param {Boolean} trigger Force a trigger that this user is online\n         */\n\n    }, {\n        key: 'userJoin',\n        value: function userJoin(uuid, state) {\n\n            // Ensure that this user exists in the global list\n            // so we can reference it from here out\n            this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n            this.chatEngine.users[uuid].assign(state);\n\n            // check if the user already exists within the chatroom\n            // so we know if we need to notify or not\n            var userAlreadyHere = this.users[uuid];\n\n            // assign the user to the chatroom\n            this.users[uuid] = this.chatEngine.users[uuid];\n\n            // trigger the join event over this chatroom\n            if (userAlreadyHere) {\n\n                /**\n                 * Broadcast that a {@link User} has come online. This is when\n                 * the framework firsts learn of a user. This can be triggered\n                 * by, ```$.join```, or other network events that\n                 * notify the framework of a new user.\n                 *\n                 * @event Chat#$\".\"online\".\"here\n                 * @param {Object} data The payload returned by the event\n                 * @param {User} data.user The {@link User} that came online\n                 * @example\n                 * chat.on('$.online.here', (data) => {\n                          *     console.log('User has come online:', data.user);\n                          * });\n                 */\n\n                this.trigger('$.online.here', { user: this.users[uuid] });\n            } else {\n\n                /**\n                 * Fired when a {@link User} has joined the room.\n                 *\n                 * @event Chat#$\".\"online\".\"join\n                 * @param {Object} data The payload returned by the event\n                 * @param {User} data.user The {@link User} that came online\n                 * @example\n                 * chat.on('$.join', (data) => {\n                 *     console.log('User has joined the room!', data.user);\n                 * });\n                 */\n\n                this.trigger('$.online.join', { user: this.users[uuid] });\n            }\n\n            // return the instance of this user\n            return this.chatEngine.users[uuid];\n        }\n\n        /**\n         * Update a user's state.\n         * @private\n         * @param {String} uuid The {@link User} uuid\n         * @param {Object} state State to update for the user\n         */\n\n    }, {\n        key: 'userUpdate',\n        value: function userUpdate(uuid, state) {\n\n            // ensure the user exists within the global space\n            this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n            // if we don't know about this user\n            if (!this.users[uuid]) {\n                // do the whole join thing\n                this.userJoin(uuid, state);\n            }\n\n            // update this user's state in this chatroom\n            this.users[uuid].assign(state);\n\n            /**\n             * Broadcast that a {@link User} has changed state.\n             * @event ChatEngine#$\".\"state\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that changed state\n             * @param {Object} data.state The new user state\n             * @example\n             * ChatEngine.on('$.state', (data) => {\n             *     console.log('User has changed state:', data.user, 'new state:', data.state);\n             * });\n             */\n            this.chatEngine._emit('$.state', {\n                user: this.users[uuid],\n                state: this.users[uuid].state\n            });\n        }\n\n        /**\n         * Called by {@link ChatEngine#disconnect}. Fires disconnection notifications\n         * and stores \"sleep\" state in memory. Sleep means the Chat was previously connected.\n         * @private\n         */\n\n    }, {\n        key: 'sleep',\n        value: function sleep() {\n\n            if (this.connected) {\n                this.onDisconnected();\n                this.asleep = true;\n            }\n        }\n\n        /**\n         * Called by {@link ChatEngine#reconnect}. Wakes the Chat up from sleep state.\n         * Re-authenticates with the server, and fires connection events once established.\n         * @private\n         */\n\n    }, {\n        key: 'wake',\n        value: function wake() {\n            var _this5 = this;\n\n            if (this.asleep) {\n                this.handshake(function () {\n                    _this5.onConnected();\n                });\n            }\n        }\n\n        /**\n         * Fired upon successful connection to the network.\n         * @private\n         */\n\n    }, {\n        key: 'onConnected',\n        value: function onConnected() {\n            this.connected = true;\n            this.trigger('$.connected');\n        }\n\n        /**\n         * Fires upon disconnection from the network through any means.\n         * @private\n         */\n\n    }, {\n        key: 'onDisconnected',\n        value: function onDisconnected() {\n            this.connected = false;\n            this.trigger('$.disconnected');\n        }\n        /**\n         * Fires upon manually invoked leaving.\n         * @private\n         */\n\n    }, {\n        key: 'onLeave',\n        value: function onLeave() {\n            this.trigger('$.left');\n            this.onDisconnected();\n        }\n\n        /**\n         * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n         * receiving events.\n         * @fires Chat#event:$\".\"offline\".\"leave\n         * @example\n         * chat.leave();\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave() {\n            var _this6 = this;\n\n            // unsubscribe from the channel locally\n            this.chatEngine.pubnub.unsubscribe({\n                channels: [this.channel]\n            });\n\n            // tell the server we left\n            this.chatEngine.request('post', 'leave', { chat: this.objectify() }).then(function () {\n\n                // trigger the disconnect events and update state\n                _this6.onLeave();\n\n                // tell the chat we've left\n                _this6.emit('$.system.leave', { subject: _this6.objectify() });\n\n                // tell session we've left\n                if (_this6.chatEngine.me.session) {\n                    _this6.chatEngine.me.session.leave(_this6);\n                }\n            }).catch(function (error) {\n                _this6.chatEngine.throwError(_this6, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error: error });\n            });\n        }\n\n        /**\n         Perform updates when a user has left the {@link Chat}.\n          @private\n         */\n\n    }, {\n        key: 'userLeave',\n        value: function userLeave(uuid) {\n\n            // store a temporary reference to send with our event\n            var user = this.users[uuid];\n\n            // remove the user from the local list of users\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n            delete this.users[uuid];\n\n            // make sure this event is real, user may have already left\n            if (user) {\n\n                // if a user leaves, trigger the event\n\n                /**\n                 * Fired when a {@link User} intentionally leaves a {@link Chat}.\n                 *\n                 * @event Chat#$\".\"offline\".\"leave\n                 * @param {Object} data The data payload from the event\n                 * @param {User} user The {@link User} that has left the room\n                 * @example\n                 * chat.on('$.offline.leave', (data) => {\n                          *     console.log('User left the room manually:', data.user);\n                          * });\n                 */\n                this.trigger('$.offline.leave', { user: user });\n            }\n        }\n\n        /**\n         Fired when a user disconnects from the {@link Chat}\n          @private\n         @param {String} uuid The uuid of the {@link Chat} that left\n         */\n\n    }, {\n        key: 'userDisconnect',\n        value: function userDisconnect(uuid) {\n\n            var user = this.users[uuid];\n            delete this.users[uuid];\n\n            // make sure this event is real, user may have already left\n            if (user) {\n\n                /**\n                 * Fired specifically when a {@link User} looses network connection\n                 * to the {@link Chat} involuntarily.\n                 *\n                 * @event Chat#$\".\"offline\".\"disconnect\n                 * @param {Object} data The {@link User} that disconnected\n                 * @param {Object} data.user The {@link User} that disconnected\n                 * @example\n                 * chat.on('$.offline.disconnect', (data) => {\n                 *     console.log('User disconnected from the network:', data.user);\n                 * });\n                 */\n                this.trigger('$.offline.disconnect', { user: user });\n            }\n        }\n\n        /**\n         Set the state for {@link Me} within this {@link User}.\n         Broadcasts the ```$.state``` event on other clients\n          @private\n         @param {Object} state The new state {@link Me} will have within this {@link User}\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state, callback) {\n            this.chatEngine.pubnub.setState({ state: state, channels: [this.chatEngine.global.channel] }, callback);\n        }\n\n        /**\n         Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n         which will emit all old events unless ```config.event``` is supplied.\n         @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n         @param {Event} [config.event] The {@link Event} to search for.\n         @param {User} [config.sender] The {@link User} who sent the message.\n         @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history. Limit will be ignored in case if both 'start' and 'end' timetokens has been passed in search configuration.\n         @param {Number} [config.start=0] The timetoken to begin searching between.\n         @param {Number} [config.end=0] The timetoken to end searching between.\n         @param {Boolean} [config.reverse=false] Search oldest messages first.\n         @return {Search}\n         @example\n        chat.search({\n            event: 'my-custom-event',\n            sender: ChatEngine.me,\n            limit: 20\n        }).on('my-custom-event', (event) => {\n            console.log('this is an old event!', event);\n        }).on('$.search.finish', () => {\n            console.log('we have all our results!')\n        });\n         */\n\n    }, {\n        key: 'search',\n        value: function search(config) {\n\n            if (this.hasConnected) {\n                return new Search(this.chatEngine, this, config);\n            } else {\n                this.chatEngine.throwError(this, 'trigger', 'search', new Error('You must wait for the $.connected event before calling Chat#search'));\n            }\n        }\n\n        /**\n         * Fired when the chat first connects to network.\n         * @private\n         */\n\n    }, {\n        key: 'connectionReady',\n        value: function connectionReady() {\n            var _this7 = this;\n\n            this.connected = true;\n            this.hasConnected = true;\n\n            /**\n             * Broadcast that the {@link Chat} is connected to the network.\n             * @event Chat#$\".\"connected\n             * @example\n             * chat.on('$.connected', () => {\n             *     console.log('chat is ready to go!');\n             * });\n             */\n            this.onConnected();\n\n            if (this.chatEngine.me.session) {\n                this.chatEngine.me.session.join(this);\n            }\n\n            // add self to list of users\n            this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n            // trigger my own online event\n            this.trigger('$.online.join', {\n                user: this.chatEngine.me\n            });\n\n            // global channel updates are triggered manually, only get presence on custom chats\n            if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n                this.getUserUpdates();\n\n                // we may miss updates, so call this again 5 seconds later\n                setTimeout(function () {\n                    _this7.getUserUpdates();\n                }, 5000);\n            }\n\n            this.on('$.system.leave', function (payload) {\n                _this7.userLeave(payload.sender.uuid);\n            });\n        }\n\n        /**\n         * Ask PubNub for information about {@link User}s in this {@link Chat}.\n         */\n\n    }, {\n        key: 'getUserUpdates',\n        value: function getUserUpdates() {\n            var _this8 = this;\n\n            // get a list of users online now\n            // ask PubNub for information about connected users in this channel\n            this.chatEngine.pubnub.hereNow({\n                channels: [this.channel],\n                includeUUIDs: true,\n                includeState: true\n            }, function (s, r) {\n                _this8.onHereNow(s, r);\n            });\n        }\n\n        /**\n         * Establish authentication with the server, then subscribe with PubNub.\n         * @fires Chat#$\".\"ready\n         */\n\n    }, {\n        key: 'connect',\n        value: function connect() {\n            var _this9 = this;\n\n            // establish good will with the server\n            this.handshake(function () {\n\n                // now that we've got connection, do everything else via connectionReady\n                _this9.connectionReady();\n            });\n        }\n\n        /**\n         * Connect to PubNub servers to initialize the chat.\n         * @example\n         * // create a new chatroom, but don't connect to it automatically\n         * let chat = new Chat('some-chat', false)\n         *\n         * // connect to the chat when we feel like it\n         * chat.connect();\n         */\n\n    }, {\n        key: 'handshake',\n        value: function handshake(complete) {\n            var _this10 = this;\n\n            waterfall([function (next) {\n                if (!_this10.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            }, function (next) {\n\n                _this10.chatEngine.request('post', 'grant', { chat: _this10.objectify() }).then(function () {\n                    next();\n                }).catch(next);\n            }, function (next) {\n\n                _this10.chatEngine.request('post', 'join', { chat: _this10.objectify() }).then(function () {\n                    next();\n                }).catch(next);\n            }, function (next) {\n\n                if (_this10.chatEngine.ceConfig.enableMeta) {\n\n                    _this10.chatEngine.request('get', 'chat', {}, { channel: _this10.channel }).then(function (response) {\n\n                        // asign metadata locally\n                        if (response.data.found) {\n                            _this10.meta = response.data.chat.meta;\n                        } else {\n                            _this10.update(_this10.meta);\n                        }\n\n                        next();\n                    }).catch(next);\n                } else {\n                    next();\n                }\n            }], function (error) {\n\n                if (error) {\n                    _this10.chatEngine.throwError(_this10, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error: error });\n                } else {\n                    complete();\n                }\n            });\n        }\n    }]);\n\n    return Chat;\n}(Emitter);\n\nmodule.exports = Chat;"},{"id":62,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":53,"index2":38,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","issuerId":20,"issuerName":"./node_modules/lodash/_freeGlobal.js","profile":{"factory":1,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":20,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":13,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":70,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/augment/sender.js","name":"./src/plugins/augment/sender.js","index":65,"index2":61,"size":811,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","issuerId":1,"issuerName":"./src/modules/emitter.js","profile":{"factory":449,"building":48},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../plugins/augment/sender","loc":"15:20-56"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (chatEngine) {\n\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    // if we should try to restore the sender property\n                    if (payload.sender && typeof payload.sender === 'string') {\n\n                        // get the user from ChatEngine\n                        payload.sender = new chatEngine.User(payload.sender);\n\n                        payload.sender._getStoredState(function () {\n                            next(null, payload);\n                        });\n                    } else {\n                        // there's no \"sender\" in this object, move on\n                        next(null, payload);\n                    }\n                }\n            }\n        }\n    };\n};"},{"id":71,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":66,"index2":93,"size":8048,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":212,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"16:13-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\nvar eachSeries = require('async/eachSeries');\n\nvar eventFilter = require('../plugins/filter/event');\nvar senderFilter = require('../plugins/filter/sender');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\n\nvar Search = function (_Emitter) {\n    _inherits(Search, _Emitter);\n\n    function Search(chatEngine, chat) {\n        var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, Search);\n\n        var _this = _possibleConstructorReturn(this, (Search.__proto__ || Object.getPrototypeOf(Search)).call(this, chatEngine));\n\n        _this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        _this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        _this.chat = chat;\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        _this.config = config;\n        _this.config.event = config.event;\n        _this.config.limit = config.limit || 20;\n        _this.config.channel = _this.chat.channel;\n        _this.config.includeTimetoken = true;\n        _this.config.stringifiedTimeToken = true;\n        _this.config.count = _this.config.count || 100;\n        _this.config.pages = _this.config.pages || 10;\n\n        /** @private */\n        _this.maxPage = _this.config.pages;\n        /** @private */\n        _this.numPage = 0;\n\n        /** @private */\n        _this.referenceDate = _this.config.end || 0;\n\n        /**\n         * Flag which represent whether there is potentially more data available in {@link Chat} history. This flag can\n         * be used for conditional call of {@link Chat#search}.\n         * @type {boolean}\n         */\n        _this.hasMore = true;\n        /** @private */\n        _this.messagesBetweenTimetokens = _this.config.start > '0' && _this.config.end > '0';\n        /** @private */\n        _this.needleCount = 0;\n\n        /**\n         * Call PubNub history in a loop.\n         * @private\n         */\n        _this.page = function (pageDone) {\n            var searchConfiguration = Object.assign({}, _this.config, { start: _this.referenceDate });\n            delete searchConfiguration.reverse;\n            delete searchConfiguration.end;\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            _this._emit('$.search.page.request');\n\n            _this.chatEngine.pubnub.history(searchConfiguration, function (status, response) {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                _this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    _this.chatEngine.throwError(_this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n                } else {\n                    var startDate = response.startTimeToken;\n                    _this.referenceDate = response.startTimeToken;\n                    _this.hasMore = response.messages.length === _this.config.count && startDate !== '0';\n\n                    response.messages.sort(function (left, right) {\n                        return left.timetoken < right.timetoken ? -1 : 1;\n                    });\n\n                    if (_this.config.start && startDate < _this.config.start) {\n                        _this.hasMore = false;\n                        response.messages = response.messages.filter(function (event) {\n                            return event.timetoken >= _this.config.start;\n                        });\n                    }\n\n                    pageDone(response);\n                }\n            });\n        };\n\n        /**\n         * @private\n         */\n        _this.triggerHistory = function (message, cb) {\n\n            if (_this.needleCount < _this.config.limit || _this.messagesBetweenTimetokens) {\n\n                message.entry.timetoken = message.timetoken;\n\n                _this.trigger(message.entry.event, message.entry, function (reject) {\n\n                    if (!reject) {\n                        _this.needleCount += 1;\n                    }\n\n                    cb();\n                });\n            } else {\n                cb();\n            }\n        };\n\n        _this.next = function () {\n\n            if (_this.hasMore) {\n\n                _this.maxPage = _this.maxPage + _this.config.pages;\n                _this.find();\n            } else {\n                _this._emit('$.search.finish');\n            }\n        };\n\n        /**\n         * @private\n         */\n        _this.find = function () {\n            _this.page(function (response) {\n                response.messages.reverse();\n\n                eachSeries(response.messages, _this.triggerHistory, function () {\n\n                    if (_this.hasMore && _this.numPage === _this.maxPage) {\n                        _this._emit('$.search.pause');\n                    } else if (_this.hasMore && (_this.needleCount < _this.config.limit || _this.messagesBetweenTimetokens)) {\n                        _this.numPage += 1;\n                        _this.find();\n                    } else {\n\n                        if (_this.needleCount >= _this.config.limit && !_this.messagesBetweenTimetokens) {\n                            _this.hasMore = false;\n                        }\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        _this._emit('$.search.finish');\n                    }\n                });\n            });\n\n            return _this;\n        };\n\n        if (_this.config.event) {\n            _this.plugins.unshift(eventFilter(_this.config.event));\n        }\n\n        if (_this.config.sender) {\n            _this.plugins.unshift(senderFilter(_this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        _this._emit('$.search.start');\n        _this.find();\n        return _this;\n    }\n\n    return Search;\n}(Emitter);\n\nmodule.exports = Search;"},{"id":96,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/filter/event.js","name":"./src/plugins/filter/event.js","index":95,"index2":91,"size":338,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","issuerId":71,"issuerName":"./src/components/search.js","profile":{"factory":340,"building":60},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../plugins/filter/event","loc":"12:18-52"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (event) {\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    var matches = payload && payload.event && payload.event === event;\n\n                    next(!matches, payload);\n                }\n            }\n        }\n    };\n};"},{"id":97,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/filter/sender.js","name":"./src/plugins/filter/sender.js","index":96,"index2":92,"size":346,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","issuerId":71,"issuerName":"./src/components/search.js","profile":{"factory":341,"building":66},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../plugins/filter/sender","loc":"13:19-54"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (user) {\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n                    var matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                    next(!matches, payload);\n                }\n            }\n        }\n    };\n};"},{"id":98,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/augment/chat.js","name":"./src/plugins/augment/chat.js","index":97,"index2":94,"size":402,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":107,"building":540},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../plugins/augment/chat","loc":"18:18-52"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nmodule.exports = function (chat) {\n\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    // restore chat in payload\n                    if (!payload.chat) {\n                        payload.chat = chat;\n                    }\n\n                    next(null, payload);\n                }\n            }\n        }\n    };\n};"},{"id":99,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":98,"index2":98,"size":4317,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":291,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"9:9-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar User = require('./user');\nvar Session = require('./session');\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\n\nvar Me = function (_User) {\n    _inherits(Me, _User);\n\n    function Me(chatEngine, uuid) {\n        var _ret;\n\n        _classCallCheck(this, Me);\n\n        var _this = _possibleConstructorReturn(this, (Me.__proto__ || Object.getPrototypeOf(Me)).call(this, chatEngine, uuid));\n\n        // call the User constructor\n\n\n        _this.chatEngine = chatEngine;\n\n        _this.session = false;\n\n        _this.name = 'Me';\n\n        if (_this.chatEngine.ceConfig.enableSync) {\n            _this.session = new Session(chatEngine);\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n\n\n    _createClass(Me, [{\n        key: 'update',\n        value: function update(state) {\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n\n            // assign state values locally before broadcasting them over the network\n            this.assign(state);\n\n            // publish the update over the global channel\n            this.chatEngine.global.setState(state, callback);\n        }\n\n        /**\n         * assign updates from network\n         * @private\n         */\n\n    }, {\n        key: 'assign',\n        value: function assign(state) {\n\n            // run the root update function\n            _get(Me.prototype.__proto__ || Object.getPrototypeOf(Me.prototype), 'assign', this).call(this, state);\n        }\n    }]);\n\n    return Me;\n}(User);\n\nmodule.exports = Me;"},{"id":100,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/session.js","name":"./src/components/session.js","index":100,"index2":97,"size":8790,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","issuerId":99,"issuerName":"./src/components/me.js","profile":{"factory":61,"building":339,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./session","loc":"14:14-34"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\n\nvar Session = function (_Emitter) {\n    _inherits(Session, _Emitter);\n\n    function Session(chatEngine) {\n        _classCallCheck(this, Session);\n\n        var _this = _possibleConstructorReturn(this, (Session.__proto__ || Object.getPrototypeOf(Session)).call(this, chatEngine));\n\n        _this.name = 'Session';\n\n        _this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        _this.chats = {};\n\n        /**\n         * The {@link Chat} that syncs session between instances. Only connects\n         * if \"enableSync\" has been set to true in ceConfig.\n         * @type {this}\n         */\n        _this.sync = null;\n\n        return _this;\n    }\n\n    /**\n     * Forwards sync events from other instances into callback functions\n     * @private\n     */\n\n\n    _createClass(Session, [{\n        key: 'subscribe',\n        value: function subscribe() {\n            var _this2 = this;\n\n            this.sync = new this.chatEngine.Chat([this.chatEngine.global.channel, 'user', this.chatEngine.me.uuid, 'me.', 'sync'].join('#'), false, this.chatEngine.ceConfig.enableSync, {}, 'system');\n\n            // subscribe to the events on our sync chat and forward them\n            this.sync.on('$.session.notify.chat.join', function (payload) {\n                _this2.onJoin(payload.data.subject);\n            });\n\n            this.sync.on('$.session.notify.chat.leave', function (payload) {\n                _this2.onleave(payload.data.subject);\n            });\n        }\n\n        /**\n         * Uses PubNub channel groups to restore a session for this uuid\n         * @private\n         */\n\n    }, {\n        key: 'restore',\n        value: function restore() {\n            var _this3 = this;\n\n            // these are custom groups that separate custom chats from system chats\n            // for better fitlering\n            var groups = ['custom', 'system'];\n\n            // loop through the groups\n            groups.forEach(function (group) {\n\n                // generate the channel group string for PubNub using the current uuid\n                var channelGroup = [_this3.chatEngine.ceConfig.globalChannel, _this3.chatEngine.me.uuid, group].join('#');\n\n                // ask pubnub for a list of channels for this group\n                _this3.chatEngine.pubnub.channelGroups.listChannels({\n                    channelGroup: channelGroup\n                }, function (status, response) {\n\n                    if (status.error) {\n                        _this3.chatEngine.throwError(_this3.chatEngine, '_emit', 'sync', new Error('There was a problem restoring your session from PubNub servers.'), { status: status });\n                    } else {\n\n                        // loop through the returned channels\n                        response.channels.forEach(function (channel) {\n\n                            // call the same callback as if we were notified about them\n                            _this3.onJoin({\n                                channel: channel,\n                                private: _this3.chatEngine.parseChannel(channel).private,\n                                group: group\n                            });\n\n                            /**\n                            Fired when session has been restored at boot. Fired once per\n                            session group.\n                            @event Me#$\".\"session\".\"group\".\"restored\n                            */\n                            _this3.trigger('$.group.restored', { group: group });\n                        });\n                    }\n                });\n            });\n        }\n\n        /**\n         * Callback fired when another instance has joined a chat\n         * @private\n         */\n\n    }, {\n        key: 'join',\n        value: function join(chat) {\n\n            // don't rebroadcast chats in session we've already heard about\n            if (!this.chats[chat.group] || !this.chats[chat.group][chat.channel]) {\n                this.sync.emit('$.session.notify.chat.join', { subject: chat.objectify() });\n            }\n        }\n\n        /**\n         * Callback fired when another instance has left a chat\n         * @private\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave(chat) {\n            this.sync.emit('$.session.notify.chat.leave', { subject: chat.objectify() });\n        }\n\n        /**\n        Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n        @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n        @private\n        */\n\n    }, {\n        key: 'onJoin',\n        value: function onJoin(chat) {\n\n            // create the chat group if it doesn't exist\n            this.chats[chat.group] = this.chats[chat.group] || {};\n\n            // check the chat exists within the global list but is not grouped\n            var existingChat = this.chatEngine.chats[chat.channel];\n\n            // if it exists\n            if (existingChat) {\n\n                // assign it to the group\n                this.chats[chat.group][chat.channel] = existingChat;\n            } else {\n\n                // otherwise, try to recreate it with the server information\n                this.chats[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n                /**\n                Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n                Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n                ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n                @event Me#$\".\"session\".\"chat\".\"join\n                @example\n                *\n                * // Logged in as \"Ian\" in first window\n                * ChatEngine.me.session.on('$.chat.join', (data) => {\n                *     console.log('I joined a new chat in a second window!', data.chat);\n                * });\n                *\n                * // Logged in as \"Ian\" in second window\n                * new ChatEngine.Chat('another-chat');\n                */\n                this.trigger('$.chat.join', { chat: this.chats[chat.group][chat.channel] });\n            }\n        }\n\n        /**\n        Removes {@link Chat} within this.chats\n        @private\n        */\n\n    }, {\n        key: 'onleave',\n        value: function onleave(chat) {\n\n            if (this.chats[chat.group] && this.chats[chat.group][chat.channel]) {\n\n                chat = this.chats[chat.group][chat.channel] || chat;\n\n                /**\n                * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n                * @event Me#$\".\"session\".\"chat\".\"leave\n                */\n\n                delete this.chatEngine.chats[chat.channel];\n                delete this.chats[chat.group][chat.channel];\n            }\n\n            this.trigger('$.chat.leave', { chat: chat });\n        }\n    }]);\n\n    return Session;\n}(Emitter);\n\nmodule.exports = Session;"}],"filteredModules":84,"origins":[{"moduleId":28,"module":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":1,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":63,"index2":62,"size":9673,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":102,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":27,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"11:14-43"},{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"14:14-43"},{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"9:14-43"},{"moduleId":100,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/session.js","module":"./src/components/session.js","moduleName":"./src/components/session.js","type":"cjs require","userRequest":"../modules/emitter","loc":"11:14-43"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar waterfall = require('async/waterfall');\nvar RootEmitter = require('./root_emitter');\nvar Event = require('../components/event');\n\nvar augmentSender = require('../plugins/augment/sender');\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\n\nvar Emitter = function (_RootEmitter) {\n    _inherits(Emitter, _RootEmitter);\n\n    function Emitter(chatEngine) {\n        _classCallCheck(this, Emitter);\n\n        var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        _this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        _this._dataset = {};\n\n        _this.plugin(augmentSender(chatEngine));\n\n        /**\n         Emit events locally.\n          @private\n         @param {String} event The event payload object\n         */\n        _this._emit = function (event) {\n            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            _this.chatEngine._emit(event, data, _this);\n\n            // emit the event from the object that created it\n            _this.emitter.emit(event, data);\n\n            return _this;\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        _this.on = function (event, cb) {\n\n            // keep track of all events on this emitter\n            _this.events[event] = _this.events[event] || new Event(_this.chatEngine, _this, event);\n\n            // call the private _on property\n            _this._on(event, cb);\n\n            return _this;\n        };\n\n        return _this;\n    }\n\n    // add an object as a subobject under a namespoace\n\n\n    _createClass(Emitter, [{\n        key: 'addChild',\n        value: function addChild(childName, childOb) {\n            // assign the new child object as a property of parent under the\n            // given namespace\n            this[childName] = childOb;\n\n            // assign a data set for the namespace if it doesn't exist\n            if (!this._dataset[childName]) {\n                this._dataset[childName] = {};\n            }\n\n            // the new object can use ```this.parent``` to access\n            // the root class\n            childOb.parent = this;\n\n            // bind get() and set() to the data set\n            childOb.get = this.get.bind(this._dataset[childName]);\n            childOb.set = this.set.bind(this._dataset[childName]);\n        }\n    }, {\n        key: 'get',\n        value: function get(key) {\n            return this[key];\n        }\n    }, {\n        key: 'set',\n        value: function set(key, value) {\n            if (this[key] && !value) {\n                delete this[key];\n            } else {\n                this[key] = value;\n            }\n        }\n\n        /**\n         Binds a plugin to this object\n         @param {Object} module The plugin module\n         @tutorial using\n         */\n\n    }, {\n        key: 'plugin',\n        value: function plugin(module) {\n\n            // add this plugin to a list of plugins for this object\n            this.plugins.push(module);\n\n            // see if there are plugins to attach to this class\n            if (module.extends && module.extends[this.name]) {\n                // attach the plugins to this class\n                // under their namespace\n                this.addChild(module.namespace, new module.extends[this.name]());\n\n                this[module.namespace].ChatEngine = this.chatEngine;\n\n                // if the plugin has a special construct function\n                // run it\n                if (this[module.namespace].construct) {\n                    this[module.namespace].construct();\n                }\n            }\n\n            return this;\n        }\n    }, {\n        key: 'bindProtoPlugins',\n        value: function bindProtoPlugins() {\n            var _this2 = this;\n\n            if (this.chatEngine.protoPlugins[this.name]) {\n\n                this.chatEngine.protoPlugins[this.name].forEach(function (module) {\n                    _this2.plugin(module);\n                });\n            }\n        }\n\n        /**\n         Broadcasts an event locally to all listeners.\n         @private\n         @param {String} event The event name\n         @param {Object} payload The event payload object\n         */\n\n    }, {\n        key: 'trigger',\n        value: function trigger(event) {\n            var _this3 = this;\n\n            var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, function (next) {\n                next(null, payload);\n            }, function (reject, pluginResponse) {\n\n                if (reject) {\n                    done(reject);\n                } else {\n\n                    // emit this event to any listener\n                    _this3._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n            });\n        }\n\n        /**\n         Load plugins and attach a queue of functions to execute before and\n         after events are trigger or received.\n          @private\n         @param {String} location Where in the middleeware the event should run (emit, trigger)\n         @param {String} event The event name\n         @param {String} first The first function to run before the plugins have run\n         @param {String} last The last function to run after the plugins have run\n         */\n\n    }, {\n        key: 'runPluginQueue',\n        value: function runPluginQueue(location, event, first, last) {\n\n            // this assembles a queue of functions to run as middleware\n            // event is a triggered event key\n            var pluginQueue = [];\n\n            // the first function is always required\n            pluginQueue.push(first);\n\n            // look through the configured plugins\n            this.plugins.forEach(function (pluginItem) {\n\n                // if they have defined a function to run specifically\n                // for this event\n                if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                    if (pluginItem.middleware[location][event]) {\n                        // add the function to the queue\n                        pluginQueue.push(pluginItem.middleware[location][event]);\n                    }\n\n                    if (pluginItem.middleware[location]['*']) {\n                        // add the function to the queue\n                        pluginQueue.push(pluginItem.middleware[location]['*']);\n                    }\n                }\n            });\n\n            // waterfall runs the functions in assigned order\n            // waiting for one to complete before moving to the next\n            // when it's done, the ```last``` parameter is called\n            waterfall(pluginQueue, last);\n        }\n    }, {\n        key: 'onConstructed',\n        value: function onConstructed() {\n\n            this.bindProtoPlugins();\n            this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n        }\n    }]);\n\n    return Emitter;\n}(RootEmitter);\n\nmodule.exports = Emitter;"},{"id":3,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":3966,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":11,"building":37},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"12:18-43"},{"moduleId":23,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/event.js","module":"./src/components/event.js","moduleName":"./src/components/event.js","type":"cjs require","userRequest":"../modules/root_emitter","loc":"11:14-48"},{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"7:18-51"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\n\nvar RootEmitter = function RootEmitter() {\n    var _this = this;\n\n    _classCallCheck(this, RootEmitter);\n\n    /**\n    * @private\n    */\n    this.events = {};\n\n    this.name = 'RootEmitter';\n\n    /**\n    Create a new EventEmitter2 object for this class.\n     @private\n    */\n    this.emitter = new EventEmitter2({\n        wildcard: true,\n        newListener: true,\n        maxListeners: 50,\n        verboseMemoryLeak: true\n    });\n\n    // we bind to make sure wildcards work\n    // https://github.com/asyncly/EventEmitter2/issues/186\n\n    /**\n    Private emit method that broadcasts the event to listeners on this page.\n     @private\n    @param {String} event The event name\n    @param {Object} the event payload\n    */\n    this._emit = this.emitter.emit.bind(this.emitter);\n\n    /**\n    Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n     @private\n    @param {String} event The event name\n    @param {Function} callback The function to run when the event is emitted\n    */\n\n    this._on = this.emitter.on.bind(this.emitter);\n\n    /**\n    * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n    * @method\n    * @param {String} event The event name\n    * @param {Function} cb The function to run when the event is emitted\n    * @example\n    *\n    * // Get notified whenever someone joins the room\n    * object.on('event', (payload) => {\n    *     console.log('event was fired').\n    * })\n    *\n    * // Get notified of event.a and event.b\n    * object.on('event.*', (payload) => {\n    *     console.log('event.a or event.b was fired').;\n    * })\n    */\n    this.on = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.on(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Stop a callback from listening to an event.\n    * @method\n    * @param {String} event The event name\n    * @example\n    * let callback = function(payload;) {\n    *    console.log('something happend!');\n    * };\n    * object.on('event', callback);\n    * // ...\n    * object.off('event', callback);\n    */\n    this.off = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.off(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Listen for any event on this object and fire a callback when it's emitted\n    * @method\n    * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n    * @example\n    * object.onAny((event, payload) => {\n    *     console.log('All events trigger this.');\n    * });\n    */\n    this.onAny = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.onAny(event, callback);\n\n        return _this;\n    };\n\n    /**\n    * Listen for an event and only fire the callback a single time\n    * @method\n    * @param {String} event The event name\n    * @param {Function} callback The function to run once\n    * @example\n    * object.once('message', => (event, payload) {\n    *     console.log('This is only fired once!');\n    * });\n    */\n    this.once = function (event, callback) {\n\n        // emit the event from the object that created it\n        _this.emitter.once(event, callback);\n\n        return _this;\n    };\n};\n\nmodule.exports = RootEmitter;"},{"id":23,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":64,"index2":60,"size":4177,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":264,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"13:12-42"},{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"15:12-42"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/root_emitter');\n\n/**\n * @class Event\n * Represents an {@link Chat} event.\n * @fires $\".\"emitted\n * @extends Emitter\n * @extends RootEmitter\n */\n\nvar Event = function (_Emitter) {\n  _inherits(Event, _Emitter);\n\n  function Event(chatEngine, chat, event) {\n    var _ret;\n\n    _classCallCheck(this, Event);\n\n    /**\n     * @private\n     */\n    var _this = _possibleConstructorReturn(this, (Event.__proto__ || Object.getPrototypeOf(Event)).call(this));\n\n    _this.chatEngine = chatEngine;\n\n    /**\n     * The {@link Chat#channel} that this event is registered to.\n     * @type String\n     * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n     * @readonly\n     */\n    _this.channel = chat.channel;\n\n    /**\n     * Events are always a property of a {@link Chat}. Responsible for\n     * listening to specific events and firing events when they occur.\n     * @readonly\n     * @type {Chat}\n     */\n    _this.chat = chat;\n\n    /**\n     * The string representation of the event. This is supplied as the first parameter to {@link Chat#on}\n     * @type {String}\n     */\n    _this.event = event;\n\n    /**\n     * A name that identifies this class\n     * @type {String}\n     */\n    _this.name = 'Event';\n\n    return _ret = _this, _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   Publishes the event over the PubNub network to the {@link Event} channel\n    @private\n   @param {Object} data The event payload object\n   */\n\n\n  _createClass(Event, [{\n    key: 'publish',\n    value: function publish(m) {\n      var _this2 = this;\n\n      m.event = this.event;\n\n      var storeInHistory = true;\n\n      // don't store in history if $.system event\n      if (!this.event.indexOf('$.system')) {\n        storeInHistory = false;\n      }\n\n      this.chatEngine.pubnub.publish({\n        message: m,\n        channel: this.channel,\n        storeInHistory: storeInHistory\n      }, function (status, response) {\n\n        if (status.statusCode === 200) {\n\n          if (response) {\n            m.timetoken = response.timetoken;\n          }\n\n          /**\n           * Message successfully published\n           * @event Event#$\".\"emitted\"\n           * @param {Object} data The message payload\n           */\n          _this2._emit('$.emitted', m);\n        } else {\n\n          /**\n           * There was a problem publishing over the PubNub network.\n           * @event Chat#$\".\"error\".\"publish\n           */\n          _this2.chatEngine.throwError(_this2, '_emit', 'emitter', new Error('There was a problem publishing over the PubNub network.'), status);\n        }\n      });\n    }\n  }]);\n\n  return Event;\n}(Emitter);\n\nmodule.exports = Event;"},{"id":26,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":81,"index2":70,"size":517,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","issuerId":82,"issuerName":"./node_modules/lodash/isBuffer.js","profile":{"factory":22,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":82,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":88,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":11,"source":"module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n"},{"id":27,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":99,"index2":96,"size":6752,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":335,"dependencies":16},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"10:11-39"},{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"13:11-28"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\n\nvar User = function (_Emitter) {\n    _inherits(User, _Emitter);\n\n    function User(chatEngine, uuid) {\n        var _ret;\n\n        var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, User);\n\n        var _this = _possibleConstructorReturn(this, (User.__proto__ || Object.getPrototypeOf(User)).call(this));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n          @readonly\n         @type String\n         */\n        _this.uuid = uuid.toString();\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        _this.state = state;\n\n        _this._stateSet = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        _this.feed = new _this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, _this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        _this.direct = new _this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, _this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = _this;\n        }\n\n        if (Object.keys(state).length) {\n            // update this user's state in it's created context\n            _this.assign(state);\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     this is only called from network updates\n     @private\n     */\n\n\n    _createClass(User, [{\n        key: 'assign',\n        value: function assign(state) {\n\n            var oldState = this.state || {};\n            this.state = Object.assign(oldState, state);\n\n            this._stateSet = true;\n        }\n\n        /**\n         * @private\n         * @param {Object} state The new state for the user\n         */\n\n    }, {\n        key: 'update',\n        value: function update(state) {\n            this.assign(state);\n        }\n\n        /**\n        Get stored user state from remote server.\n        @private\n        */\n\n    }, {\n        key: '_getStoredState',\n        value: function _getStoredState(callback) {\n            var _this2 = this;\n\n            if (!this._stateSet) {\n\n                this.chatEngine.request('get', 'user_state', {\n                    user: this.uuid\n                }).then(function (res) {\n\n                    _this2.assign(res.data);\n                    callback(_this2.state);\n                }).catch(function (err) {\n                    _this2.chatEngine.throwError(_this2, 'trigger', 'getState', err);\n                });\n            } else {\n                callback(this.state);\n            }\n        }\n    }]);\n\n    return User;\n}(Emitter);\n\nmodule.exports = User;"},{"id":28,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":100,"size":2628,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":26,"building":187},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"'use strict';\n\nvar init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/web-javascript/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.enableSync] {Boolean} Synchronizes chats between instances with the same {@link Me#uuid}. See {@link Me#sync}.\n@param [ceConfig.enableMeta] {Boolean} Persists {@link Chat#meta} on the server. See {@link Chat#update}.\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console This should not be enabled in production.\n@param [ceConfig.profile] {Boolean} Sums event counts and outputs a table to the console every few seconds.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nvar create = function create(pnConfig) {\n    var ceConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    if (typeof ceConfig.enableSync === 'undefined') {\n        ceConfig.enableSync = false;\n    }\n\n    if (typeof ceConfig.enableMeta === 'undefined') {\n        ceConfig.enableMeta = false;\n    }\n\n    ceConfig.endpoint = ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + pnConfig.subscribeKey + '/chat-engine-server';\n\n    pnConfig.heartbeatInterval = pnConfig.heartbeatInterval || 0;\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n};\n\n// export the ChatEngine api\nvar ChatEngineCore = {\n    plugin: {},\n    create: create\n};\n\nmodule.exports = ChatEngineCore;\n\nmodule.exports.ChatEngineCore = ChatEngineCore;"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":99,"size":19552,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","issuerId":28,"issuerName":"./src/index.js","profile":{"factory":3,"building":181},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":28,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"3:11-33"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"'use strict';\n\nvar axios = require('axios');\nvar PubNub = require('pubnub');\nvar pack = require('../package.json');\n\nvar RootEmitter = require('./modules/root_emitter');\nvar Chat = require('./components/chat');\nvar Me = require('./components/me');\nvar User = require('./components/user');\nvar waterfall = require('async/waterfall');\n\n/**\n@class ChatEngine\n@extends RootEmitter\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n*/\nmodule.exports = function () {\n    var ceConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var pnConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    // Create the root ChatEngine object\n    var ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = function (self, cb, key, ceError) {\n        var payload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n    };\n\n    if (ceConfig.debug) {\n\n        ChatEngine.onAny(function (event, payload) {\n            console.info('debug:', event, payload);\n        });\n    }\n\n    if (ceConfig.profile) {\n\n        var countObject = {};\n\n        ChatEngine.onAny(function (event) {\n            countObject['event: ' + event] = countObject[event] || 0;\n            countObject['event: ' + event] += 1;\n        });\n\n        setInterval(function () {\n\n            countObject.chats = Object.keys(ChatEngine.chats).length;\n            countObject.users = Object.keys(ChatEngine.users).length;\n\n            console.table(countObject);\n        }, 3000);\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = function (className, plugin) {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = function (method, route) {\n        var inputBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var inputParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\n        var body = {\n            uuid: ChatEngine.pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authKey: ChatEngine.pnConfig.authKey\n        };\n\n        var params = {\n            route: route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params: params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params: params });\n        }\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = function (channel) {\n\n        var info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = function () {\n        var original = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date().getTime();\n        var isPrivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\n        var channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        var chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n    };\n\n    /**\n     * Initial communication with the server. Server grants permissions to\n     * talk in chats, etc.\n     * @private\n     */\n    ChatEngine.handshake = function (complete) {\n\n        waterfall([function (next) {\n            ChatEngine.request('post', 'bootstrap').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'user_read').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'user_write').then(function () {\n                next(null);\n            }).catch(next);\n        }, function (next) {\n            ChatEngine.request('post', 'group').then(function () {\n                next();\n            }).catch(next);\n        }], function (error) {\n\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').' + error && error.response && error.response.data), { error: error });\n            } else {\n                complete();\n            }\n        });\n    };\n\n    /**\n     * Listen to PubNub events and forward them into ChatEngine system.\n     * @private\n     */\n    ChatEngine.listenToPubNub = function () {\n\n        ChatEngine.pubnub.addListener({\n            message: function message(m) {\n\n                // assign the message timetoken as a property of the payload\n                m.message.timetoken = m.timetoken;\n\n                if (ChatEngine.chats[m.channel]) {\n                    ChatEngine.chats[m.channel].trigger(m.message.event, m.message);\n                }\n            },\n            presence: function presence(payload) {\n\n                if (ChatEngine.chats[payload.channel]) {\n                    ChatEngine.chats[payload.channel].onPresence(payload);\n                }\n            },\n            status: function status(statusEvent) {\n\n                /**\n                 * SDK detected that network is online.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"online\n                 */\n\n                /**\n                 * SDK detected that network is down.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                 */\n\n                /**\n                 * A subscribe event experienced an exception when running.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                 */\n\n                /**\n                 * SDK was able to reconnect to pubnub.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                 */\n\n                /**\n                 * SDK subscribed with a new mix of channels.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                 */\n\n                /**\n                 * JSON parsing crashed.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                 */\n\n                /**\n                 * Server rejected the request.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                 */\n\n                /**\n                 * If using decryption strategies and the decryption fails.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                 */\n\n                /**\n                 * Request timed out.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                 */\n\n                /**\n                 * PAM permission failure.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                 */\n\n                // map the pubnub events into ChatEngine events\n                var categories = {\n                    PNNetworkUpCategory: 'up.online',\n                    PNNetworkDownCategory: 'down.offline',\n                    PNNetworkIssuesCategory: 'down.issue',\n                    PNReconnectedCategory: 'up.reconnected',\n                    PNConnectedCategory: 'up.connected',\n                    PNAccessDeniedCategory: 'down.denied',\n                    PNMalformedResponseCategory: 'down.malformed',\n                    PNBadRequestCategory: 'down.badrequest',\n                    PNDecryptionErrorCategory: 'down.decryption',\n                    PNTimeoutCategory: 'down.timeout'\n                };\n\n                var eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                ChatEngine._emit(eventName, statusEvent);\n            }\n        });\n    };\n\n    /**\n     * Subscribe to PubNub and begin receiving events.\n     * @private\n     */\n    ChatEngine.subscribeToPubNub = function () {\n\n        var chanGroups = [ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms', ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system', ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'];\n\n        ChatEngine.pubnub.subscribe({\n            channelGroups: chanGroups,\n            withPresence: true\n        });\n    };\n\n    /**\n     * Initialize ChatEngine modules on first time boot.\n     * @private\n     */\n    ChatEngine.firstConnect = function (state) {\n\n        ChatEngine.pubnub = new PubNub(ChatEngine.pnConfig);\n\n        // create a new chat to use as global chat\n        // we don't do auth on this one because it's assumed to be done with the /auth request below\n        ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n        ChatEngine.global.once('$.connected', function () {\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, ChatEngine.pnConfig.uuid);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            if (ChatEngine.ceConfig.enableSync) {\n                ChatEngine.me.session.subscribe();\n            }\n\n            ChatEngine.me.update(state, function () {\n\n                /**\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\n                 * @event ChatEngine#$\".\"ready\n                 * @example\n                 * ChatEngine.on('$.ready', (data) => {\n                 *     let me = data.me;\n                 * })\n                 */\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.ready = true;\n\n                ChatEngine.listenToPubNub();\n                ChatEngine.subscribeToPubNub();\n\n                ChatEngine.global.getUserUpdates();\n\n                if (ChatEngine.ceConfig.enableSync) {\n                    ChatEngine.me.session.restore();\n                }\n            });\n        });\n    };\n\n    /**\n     * Disconnect from all {@link Chat}s and mark them as asleep.\n     * @method ChatEngine#disconnect\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // every individual chat will be disconnected\n     * chat.on('$.disconnected', () => {\n     *     done();\n     * });\n     *\n     * // Changing User:\n     * ChatEngine.disconnect()\n     * ChatEngine = new ChatEngine({}, {});\n     * ChatEngine.connect()\n     */\n    ChatEngine.disconnect = function () {\n\n        // Unsubscribe from all PubNub chats\n        ChatEngine.pubnub.unsubscribeAll();\n\n        // for every chat in ChatEngine.chats, signal disconnected\n        Object.keys(ChatEngine.chats).forEach(function (key) {\n            ChatEngine.chats[key].sleep();\n        });\n    };\n\n    /**\n     * Performs authentication with server and restores connection\n     * to all sleeping chats.\n     * @method ChatEngine#reconnect\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // reconnect sometime later\n     * ChatEngine.reconnect();\n     *\n     */\n    ChatEngine.reconnect = function () {\n\n        // do the whole auth flow with the new authKey\n        ChatEngine.handshake(function () {\n\n            // for every chat in ChatEngine.chats, call .connect()\n            Object.keys(ChatEngine.chats).forEach(function (key) {\n                ChatEngine.chats[key].wake();\n            });\n\n            ChatEngine.subscribeToPubNub();\n        });\n    };\n\n    /**\n    @private\n    */\n    ChatEngine.setAuth = function () {\n        var authKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PubNub.generateUUID();\n\n\n        ChatEngine.pnConfig.authKey = authKey;\n        ChatEngine.pubnub.setAuthKey(authKey);\n    };\n\n    /**\n     * Disconnects, changes authentication token, performs handshake with server\n     * and reconnects with new auth key. Used for extending logged in sessions\n     * for active users.\n     * @method ChatEngine#reauthorize\n     * @example\n     * // early\n     * ChatEngine.connect(...);\n     *\n     * ChatEngine.once('$.connected', () => {\n     *     // first connection established\n     * });\n     *\n     * // some time passes, session token expires\n     * ChatEngine.reauthorize(authKey);\n     *\n     * // we are connected again\n     * ChatEngine.once('$.connected', () => {\n     *     // we are connected again\n     * });\n     */\n    ChatEngine.reauthorize = function () {\n        var authKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PubNub.generateUUID();\n\n\n        ChatEngine.global.once('$.disconnected', function () {\n\n            ChatEngine.setAuth(authKey);\n            ChatEngine.reconnect();\n        });\n\n        ChatEngine.disconnect();\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = function (uuid) {\n        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var authKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubNub.generateUUID();\n\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        ChatEngine.pnConfig.uuid = uuid;\n        ChatEngine.pnConfig.authKey = authKey;\n\n        ChatEngine.handshake(function () {\n            ChatEngine.firstConnect(state);\n        });\n    };\n\n    ChatEngine.destroy = function () {\n\n        Object.keys(ChatEngine.chats).forEach(function (chat) {\n            ChatEngine.chats[chat].emitter.removeAllListeners();\n        });\n\n        Object.keys(ChatEngine.users).forEach(function (user) {\n            ChatEngine.users[user].emitter.removeAllListeners();\n        });\n\n        ChatEngine.emitter.removeAllListeners();\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function createChat() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        var internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            var newChat = new (Function.prototype.bind.apply(Chat, [null].concat([ChatEngine], args)))();\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n        }\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function createUser() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            var newUser = new (Function.prototype.bind.apply(User, [null].concat([ChatEngine], args)))();\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n        }\n    };\n\n    return ChatEngine;\n};"},{"id":50,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1494,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":365,"building":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"5:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.9.18\",\"description\":\"ChatEngine\",\"browser\":\"dist/chat-engine.js\",\"main\":\"src/index.js\",\"react-native\":\"src/index.js\",\"scripts\":{\"build\":\"gulp\",\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"babel-loader\":\"^7.1.4\",\"babel-preset-es2015\":\"^6.24.1\",\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"decache\":\"^4.3.0\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"2.1.2\",\"axios\":\"0.16.2\",\"eventemitter2\":\"2.2.1\",\"pubnub\":\"4.20.2\"}}"},{"id":52,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":95,"size":30144,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":11,"building":249,"dependencies":89},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"8:11-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar waterfall = require('async/waterfall');\nvar Emitter = require('../modules/emitter');\nvar Event = require('../components/event');\nvar Search = require('../components/search');\n\nvar augmentChat = require('../plugins/augment/chat');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link Me.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\n\nvar Chat = function (_Emitter) {\n    _inherits(Chat, _Emitter);\n\n    function Chat(chatEngine) {\n        var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date().getTime();\n        var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var autoConnect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n        var _ret;\n\n        var group = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'custom';\n\n        _classCallCheck(this, Chat);\n\n        var _this = _possibleConstructorReturn(this, (Chat.__proto__ || Object.getPrototypeOf(Chat)).call(this, chatEngine));\n\n        _this.chatEngine = chatEngine;\n\n        _this.name = 'Chat';\n\n        _this.plugin(augmentChat(_this));\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        _this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        _this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        _this.meta = meta || {};\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        _this.channel = _this.chatEngine.augmentChannel(channel, _this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n          @type Object\n         @readonly\n         */\n        _this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        _this.connected = false;\n\n        /**\n         * Keep a record if we've every successfully connected to this chat before.\n         * @type {Boolean}\n         */\n        _this.hasConnected = false;\n\n        /**\n         * If user manually disconnects via {@link ChatEngine#disconnect}, the\n         * chat is put to \"sleep\". If a connection is reestablished\n         * via {@link ChatEngine#reconnect}, sleeping chats reconnect automatically.\n         * @type {Boolean}\n         */\n        _this.asleep = false;\n\n        _this.chatEngine.chats[_this.channel] = _this;\n\n        if (autoConnect) {\n            _this.connect();\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n      @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n\n\n    _createClass(Chat, [{\n        key: 'onHereNow',\n        value: function onHereNow(status, response) {\n            var _this2 = this;\n\n            if (status.error) {\n\n                /**\n                 * There was a problem fetching the presence of this chat\n                 * @event Chat#$\".\"error\".\"presence\n                 */\n                this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'));\n            } else {\n\n                // get the list of occupants in this channel\n                var occupants = response.channels[this.channel].occupants;\n\n                // format the userList for rltm.js standard\n                occupants.forEach(function (occupant) {\n                    _this2.userUpdate(occupant.uuid, occupant.state);\n                });\n            }\n        }\n\n        /**\n        * Turns a {@link Chat} into a JSON representation.\n        * @return {Object}\n        */\n\n    }, {\n        key: 'objectify',\n        value: function objectify() {\n\n            return {\n                channel: this.channel,\n                group: this.group,\n                private: this.isPrivate,\n                meta: this.meta\n            };\n        }\n\n        /**\n         * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n         * @param {User} user The {@link User} to invite to this chatroom.\n         * @fires Me#event:$\".\"invite\n         * @example\n         * // one user running ChatEngine\n         * let secretChat = new ChatEngine.Chat('secret-channel');\n         * secretChat.invite(someoneElse);\n         *\n         * // someoneElse in another instance of ChatEngine\n         * me.direct.on('$.invite', (payload) => {\n         *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n         * });\n         */\n\n    }, {\n        key: 'invite',\n        value: function invite(user) {\n            var _this3 = this;\n\n            this.chatEngine.request('post', 'invite', {\n                to: user.uuid,\n                chat: this.objectify()\n            }).then(function () {\n\n                var send = function send() {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: _this3.channel\n                    });\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n            }).catch(function (error) {\n                _this3.chatEngine.throwError(_this3, 'trigger', 'search', new Error('Something went wrong while making a request to authentication server.'), { error: error });\n            });\n        }\n\n        /**\n         Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n          @private\n         @param {Object} data The PubNub presence response for this event\n         */\n\n    }, {\n        key: 'onPresence',\n        value: function onPresence(presenceEvent) {\n\n            // make sure channel matches this channel\n\n            // someone joins channel\n            if (presenceEvent.action === 'join') {\n                this.userJoin(presenceEvent.uuid, presenceEvent.state);\n            }\n\n            // someone leaves channel\n            if (presenceEvent.action === 'leave') {\n                this.userLeave(presenceEvent.uuid);\n            }\n\n            // someone timesout\n            if (presenceEvent.action === 'timeout') {\n                this.userDisconnect(presenceEvent.uuid);\n            }\n\n            // someone's state is updated\n            if (presenceEvent.action === 'state-change') {\n                this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n            }\n        }\n\n        /**\n         * Update the {@link Chat} metadata on the server.\n         * @param  {object} data JSON object representing chat metadta.\n         */\n\n    }, {\n        key: 'update',\n        value: function update(data) {\n            var _this4 = this;\n\n            var oldMeta = this.meta || {};\n            this.meta = Object.assign(oldMeta, data);\n\n            this.chatEngine.request('post', 'chat', {\n                chat: this.objectify()\n            }).then(function () {}).catch(function (error) {\n                _this4.chatEngine.throwError(_this4, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error: error });\n            });\n        }\n\n        /**\n         * Send events to other clients in this {@link User}.\n         * Events are trigger over the network  and all events are made\n         * on behalf of {@link Me}\n         *\n         * @param {String} event The event name\n         * @param {Object} data The event payload object\n         * @example\n         * chat.emit('custom-event', {value: true});\n         * chat.on('custom-event', (payload) => {\n          *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n          * });\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n\n            if (event === 'message' && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n                throw new Error('the payload has to be an object');\n            }\n\n            // create a standardized payload object\n            var payload = {\n                data: data, // the data supplied from params\n                sender: this.chatEngine.me.uuid, // my own uuid\n                chat: this, // an instance of this chat\n                event: event,\n                chatengineSDK: this.chatEngine.package.version\n            };\n\n            var tracer = new Event(this.chatEngine, this, event);\n\n            // run the plugin queue to modify the event\n            this.runPluginQueue('emit', event, function (next) {\n                next(null, payload);\n            }, function (err, pluginResponse) {\n\n                // remove chat otherwise it would be serialized\n                // instead, it's rebuilt on the other end.\n                // see this.trigger\n                delete pluginResponse.chat;\n\n                // publish the event and data over the configured channel\n                tracer.publish(pluginResponse);\n            });\n\n            return tracer;\n        }\n\n        /**\n         Add a user to the {@link Chat}, creating it if it doesn't already exist.\n          @private\n         @param {String} uuid The user uuid\n         @param {Object} state The user initial state\n         @param {Boolean} trigger Force a trigger that this user is online\n         */\n\n    }, {\n        key: 'userJoin',\n        value: function userJoin(uuid, state) {\n\n            // Ensure that this user exists in the global list\n            // so we can reference it from here out\n            this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n            this.chatEngine.users[uuid].assign(state);\n\n            // check if the user already exists within the chatroom\n            // so we know if we need to notify or not\n            var userAlreadyHere = this.users[uuid];\n\n            // assign the user to the chatroom\n            this.users[uuid] = this.chatEngine.users[uuid];\n\n            // trigger the join event over this chatroom\n            if (userAlreadyHere) {\n\n                /**\n                 * Broadcast that a {@link User} has come online. This is when\n                 * the framework firsts learn of a user. This can be triggered\n                 * by, ```$.join```, or other network events that\n                 * notify the framework of a new user.\n                 *\n                 * @event Chat#$\".\"online\".\"here\n                 * @param {Object} data The payload returned by the event\n                 * @param {User} data.user The {@link User} that came online\n                 * @example\n                 * chat.on('$.online.here', (data) => {\n                          *     console.log('User has come online:', data.user);\n                          * });\n                 */\n\n                this.trigger('$.online.here', { user: this.users[uuid] });\n            } else {\n\n                /**\n                 * Fired when a {@link User} has joined the room.\n                 *\n                 * @event Chat#$\".\"online\".\"join\n                 * @param {Object} data The payload returned by the event\n                 * @param {User} data.user The {@link User} that came online\n                 * @example\n                 * chat.on('$.join', (data) => {\n                 *     console.log('User has joined the room!', data.user);\n                 * });\n                 */\n\n                this.trigger('$.online.join', { user: this.users[uuid] });\n            }\n\n            // return the instance of this user\n            return this.chatEngine.users[uuid];\n        }\n\n        /**\n         * Update a user's state.\n         * @private\n         * @param {String} uuid The {@link User} uuid\n         * @param {Object} state State to update for the user\n         */\n\n    }, {\n        key: 'userUpdate',\n        value: function userUpdate(uuid, state) {\n\n            // ensure the user exists within the global space\n            this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n            // if we don't know about this user\n            if (!this.users[uuid]) {\n                // do the whole join thing\n                this.userJoin(uuid, state);\n            }\n\n            // update this user's state in this chatroom\n            this.users[uuid].assign(state);\n\n            /**\n             * Broadcast that a {@link User} has changed state.\n             * @event ChatEngine#$\".\"state\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that changed state\n             * @param {Object} data.state The new user state\n             * @example\n             * ChatEngine.on('$.state', (data) => {\n             *     console.log('User has changed state:', data.user, 'new state:', data.state);\n             * });\n             */\n            this.chatEngine._emit('$.state', {\n                user: this.users[uuid],\n                state: this.users[uuid].state\n            });\n        }\n\n        /**\n         * Called by {@link ChatEngine#disconnect}. Fires disconnection notifications\n         * and stores \"sleep\" state in memory. Sleep means the Chat was previously connected.\n         * @private\n         */\n\n    }, {\n        key: 'sleep',\n        value: function sleep() {\n\n            if (this.connected) {\n                this.onDisconnected();\n                this.asleep = true;\n            }\n        }\n\n        /**\n         * Called by {@link ChatEngine#reconnect}. Wakes the Chat up from sleep state.\n         * Re-authenticates with the server, and fires connection events once established.\n         * @private\n         */\n\n    }, {\n        key: 'wake',\n        value: function wake() {\n            var _this5 = this;\n\n            if (this.asleep) {\n                this.handshake(function () {\n                    _this5.onConnected();\n                });\n            }\n        }\n\n        /**\n         * Fired upon successful connection to the network.\n         * @private\n         */\n\n    }, {\n        key: 'onConnected',\n        value: function onConnected() {\n            this.connected = true;\n            this.trigger('$.connected');\n        }\n\n        /**\n         * Fires upon disconnection from the network through any means.\n         * @private\n         */\n\n    }, {\n        key: 'onDisconnected',\n        value: function onDisconnected() {\n            this.connected = false;\n            this.trigger('$.disconnected');\n        }\n        /**\n         * Fires upon manually invoked leaving.\n         * @private\n         */\n\n    }, {\n        key: 'onLeave',\n        value: function onLeave() {\n            this.trigger('$.left');\n            this.onDisconnected();\n        }\n\n        /**\n         * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n         * receiving events.\n         * @fires Chat#event:$\".\"offline\".\"leave\n         * @example\n         * chat.leave();\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave() {\n            var _this6 = this;\n\n            // unsubscribe from the channel locally\n            this.chatEngine.pubnub.unsubscribe({\n                channels: [this.channel]\n            });\n\n            // tell the server we left\n            this.chatEngine.request('post', 'leave', { chat: this.objectify() }).then(function () {\n\n                // trigger the disconnect events and update state\n                _this6.onLeave();\n\n                // tell the chat we've left\n                _this6.emit('$.system.leave', { subject: _this6.objectify() });\n\n                // tell session we've left\n                if (_this6.chatEngine.me.session) {\n                    _this6.chatEngine.me.session.leave(_this6);\n                }\n            }).catch(function (error) {\n                _this6.chatEngine.throwError(_this6, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error: error });\n            });\n        }\n\n        /**\n         Perform updates when a user has left the {@link Chat}.\n          @private\n         */\n\n    }, {\n        key: 'userLeave',\n        value: function userLeave(uuid) {\n\n            // store a temporary reference to send with our event\n            var user = this.users[uuid];\n\n            // remove the user from the local list of users\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n            delete this.users[uuid];\n\n            // make sure this event is real, user may have already left\n            if (user) {\n\n                // if a user leaves, trigger the event\n\n                /**\n                 * Fired when a {@link User} intentionally leaves a {@link Chat}.\n                 *\n                 * @event Chat#$\".\"offline\".\"leave\n                 * @param {Object} data The data payload from the event\n                 * @param {User} user The {@link User} that has left the room\n                 * @example\n                 * chat.on('$.offline.leave', (data) => {\n                          *     console.log('User left the room manually:', data.user);\n                          * });\n                 */\n                this.trigger('$.offline.leave', { user: user });\n            }\n        }\n\n        /**\n         Fired when a user disconnects from the {@link Chat}\n          @private\n         @param {String} uuid The uuid of the {@link Chat} that left\n         */\n\n    }, {\n        key: 'userDisconnect',\n        value: function userDisconnect(uuid) {\n\n            var user = this.users[uuid];\n            delete this.users[uuid];\n\n            // make sure this event is real, user may have already left\n            if (user) {\n\n                /**\n                 * Fired specifically when a {@link User} looses network connection\n                 * to the {@link Chat} involuntarily.\n                 *\n                 * @event Chat#$\".\"offline\".\"disconnect\n                 * @param {Object} data The {@link User} that disconnected\n                 * @param {Object} data.user The {@link User} that disconnected\n                 * @example\n                 * chat.on('$.offline.disconnect', (data) => {\n                 *     console.log('User disconnected from the network:', data.user);\n                 * });\n                 */\n                this.trigger('$.offline.disconnect', { user: user });\n            }\n        }\n\n        /**\n         Set the state for {@link Me} within this {@link User}.\n         Broadcasts the ```$.state``` event on other clients\n          @private\n         @param {Object} state The new state {@link Me} will have within this {@link User}\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state, callback) {\n            this.chatEngine.pubnub.setState({ state: state, channels: [this.chatEngine.global.channel] }, callback);\n        }\n\n        /**\n         Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n         which will emit all old events unless ```config.event``` is supplied.\n         @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n         @param {Event} [config.event] The {@link Event} to search for.\n         @param {User} [config.sender] The {@link User} who sent the message.\n         @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history. Limit will be ignored in case if both 'start' and 'end' timetokens has been passed in search configuration.\n         @param {Number} [config.start=0] The timetoken to begin searching between.\n         @param {Number} [config.end=0] The timetoken to end searching between.\n         @param {Boolean} [config.reverse=false] Search oldest messages first.\n         @return {Search}\n         @example\n        chat.search({\n            event: 'my-custom-event',\n            sender: ChatEngine.me,\n            limit: 20\n        }).on('my-custom-event', (event) => {\n            console.log('this is an old event!', event);\n        }).on('$.search.finish', () => {\n            console.log('we have all our results!')\n        });\n         */\n\n    }, {\n        key: 'search',\n        value: function search(config) {\n\n            if (this.hasConnected) {\n                return new Search(this.chatEngine, this, config);\n            } else {\n                this.chatEngine.throwError(this, 'trigger', 'search', new Error('You must wait for the $.connected event before calling Chat#search'));\n            }\n        }\n\n        /**\n         * Fired when the chat first connects to network.\n         * @private\n         */\n\n    }, {\n        key: 'connectionReady',\n        value: function connectionReady() {\n            var _this7 = this;\n\n            this.connected = true;\n            this.hasConnected = true;\n\n            /**\n             * Broadcast that the {@link Chat} is connected to the network.\n             * @event Chat#$\".\"connected\n             * @example\n             * chat.on('$.connected', () => {\n             *     console.log('chat is ready to go!');\n             * });\n             */\n            this.onConnected();\n\n            if (this.chatEngine.me.session) {\n                this.chatEngine.me.session.join(this);\n            }\n\n            // add self to list of users\n            this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n            // trigger my own online event\n            this.trigger('$.online.join', {\n                user: this.chatEngine.me\n            });\n\n            // global channel updates are triggered manually, only get presence on custom chats\n            if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n                this.getUserUpdates();\n\n                // we may miss updates, so call this again 5 seconds later\n                setTimeout(function () {\n                    _this7.getUserUpdates();\n                }, 5000);\n            }\n\n            this.on('$.system.leave', function (payload) {\n                _this7.userLeave(payload.sender.uuid);\n            });\n        }\n\n        /**\n         * Ask PubNub for information about {@link User}s in this {@link Chat}.\n         */\n\n    }, {\n        key: 'getUserUpdates',\n        value: function getUserUpdates() {\n            var _this8 = this;\n\n            // get a list of users online now\n            // ask PubNub for information about connected users in this channel\n            this.chatEngine.pubnub.hereNow({\n                channels: [this.channel],\n                includeUUIDs: true,\n                includeState: true\n            }, function (s, r) {\n                _this8.onHereNow(s, r);\n            });\n        }\n\n        /**\n         * Establish authentication with the server, then subscribe with PubNub.\n         * @fires Chat#$\".\"ready\n         */\n\n    }, {\n        key: 'connect',\n        value: function connect() {\n            var _this9 = this;\n\n            // establish good will with the server\n            this.handshake(function () {\n\n                // now that we've got connection, do everything else via connectionReady\n                _this9.connectionReady();\n            });\n        }\n\n        /**\n         * Connect to PubNub servers to initialize the chat.\n         * @example\n         * // create a new chatroom, but don't connect to it automatically\n         * let chat = new Chat('some-chat', false)\n         *\n         * // connect to the chat when we feel like it\n         * chat.connect();\n         */\n\n    }, {\n        key: 'handshake',\n        value: function handshake(complete) {\n            var _this10 = this;\n\n            waterfall([function (next) {\n                if (!_this10.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            }, function (next) {\n\n                _this10.chatEngine.request('post', 'grant', { chat: _this10.objectify() }).then(function () {\n                    next();\n                }).catch(next);\n            }, function (next) {\n\n                _this10.chatEngine.request('post', 'join', { chat: _this10.objectify() }).then(function () {\n                    next();\n                }).catch(next);\n            }, function (next) {\n\n                if (_this10.chatEngine.ceConfig.enableMeta) {\n\n                    _this10.chatEngine.request('get', 'chat', {}, { channel: _this10.channel }).then(function (response) {\n\n                        // asign metadata locally\n                        if (response.data.found) {\n                            _this10.meta = response.data.chat.meta;\n                        } else {\n                            _this10.update(_this10.meta);\n                        }\n\n                        next();\n                    }).catch(next);\n                } else {\n                    next();\n                }\n            }], function (error) {\n\n                if (error) {\n                    _this10.chatEngine.throwError(_this10, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error: error });\n                } else {\n                    complete();\n                }\n            });\n        }\n    }]);\n\n    return Chat;\n}(Emitter);\n\nmodule.exports = Chat;"},{"id":62,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":53,"index2":38,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","issuerId":20,"issuerName":"./node_modules/lodash/_freeGlobal.js","profile":{"factory":1,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":20,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":13,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":70,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/augment/sender.js","name":"./src/plugins/augment/sender.js","index":65,"index2":61,"size":811,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","issuerId":1,"issuerName":"./src/modules/emitter.js","profile":{"factory":449,"building":48},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../plugins/augment/sender","loc":"15:20-56"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (chatEngine) {\n\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    // if we should try to restore the sender property\n                    if (payload.sender && typeof payload.sender === 'string') {\n\n                        // get the user from ChatEngine\n                        payload.sender = new chatEngine.User(payload.sender);\n\n                        payload.sender._getStoredState(function () {\n                            next(null, payload);\n                        });\n                    } else {\n                        // there's no \"sender\" in this object, move on\n                        next(null, payload);\n                    }\n                }\n            }\n        }\n    };\n};"},{"id":71,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":66,"index2":93,"size":8048,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":103,"building":212,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"16:13-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\nvar eachSeries = require('async/eachSeries');\n\nvar eventFilter = require('../plugins/filter/event');\nvar senderFilter = require('../plugins/filter/sender');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\n\nvar Search = function (_Emitter) {\n    _inherits(Search, _Emitter);\n\n    function Search(chatEngine, chat) {\n        var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, Search);\n\n        var _this = _possibleConstructorReturn(this, (Search.__proto__ || Object.getPrototypeOf(Search)).call(this, chatEngine));\n\n        _this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        _this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        _this.chat = chat;\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        _this.config = config;\n        _this.config.event = config.event;\n        _this.config.limit = config.limit || 20;\n        _this.config.channel = _this.chat.channel;\n        _this.config.includeTimetoken = true;\n        _this.config.stringifiedTimeToken = true;\n        _this.config.count = _this.config.count || 100;\n        _this.config.pages = _this.config.pages || 10;\n\n        /** @private */\n        _this.maxPage = _this.config.pages;\n        /** @private */\n        _this.numPage = 0;\n\n        /** @private */\n        _this.referenceDate = _this.config.end || 0;\n\n        /**\n         * Flag which represent whether there is potentially more data available in {@link Chat} history. This flag can\n         * be used for conditional call of {@link Chat#search}.\n         * @type {boolean}\n         */\n        _this.hasMore = true;\n        /** @private */\n        _this.messagesBetweenTimetokens = _this.config.start > '0' && _this.config.end > '0';\n        /** @private */\n        _this.needleCount = 0;\n\n        /**\n         * Call PubNub history in a loop.\n         * @private\n         */\n        _this.page = function (pageDone) {\n            var searchConfiguration = Object.assign({}, _this.config, { start: _this.referenceDate });\n            delete searchConfiguration.reverse;\n            delete searchConfiguration.end;\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            _this._emit('$.search.page.request');\n\n            _this.chatEngine.pubnub.history(searchConfiguration, function (status, response) {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                _this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    _this.chatEngine.throwError(_this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n                } else {\n                    var startDate = response.startTimeToken;\n                    _this.referenceDate = response.startTimeToken;\n                    _this.hasMore = response.messages.length === _this.config.count && startDate !== '0';\n\n                    response.messages.sort(function (left, right) {\n                        return left.timetoken < right.timetoken ? -1 : 1;\n                    });\n\n                    if (_this.config.start && startDate < _this.config.start) {\n                        _this.hasMore = false;\n                        response.messages = response.messages.filter(function (event) {\n                            return event.timetoken >= _this.config.start;\n                        });\n                    }\n\n                    pageDone(response);\n                }\n            });\n        };\n\n        /**\n         * @private\n         */\n        _this.triggerHistory = function (message, cb) {\n\n            if (_this.needleCount < _this.config.limit || _this.messagesBetweenTimetokens) {\n\n                message.entry.timetoken = message.timetoken;\n\n                _this.trigger(message.entry.event, message.entry, function (reject) {\n\n                    if (!reject) {\n                        _this.needleCount += 1;\n                    }\n\n                    cb();\n                });\n            } else {\n                cb();\n            }\n        };\n\n        _this.next = function () {\n\n            if (_this.hasMore) {\n\n                _this.maxPage = _this.maxPage + _this.config.pages;\n                _this.find();\n            } else {\n                _this._emit('$.search.finish');\n            }\n        };\n\n        /**\n         * @private\n         */\n        _this.find = function () {\n            _this.page(function (response) {\n                response.messages.reverse();\n\n                eachSeries(response.messages, _this.triggerHistory, function () {\n\n                    if (_this.hasMore && _this.numPage === _this.maxPage) {\n                        _this._emit('$.search.pause');\n                    } else if (_this.hasMore && (_this.needleCount < _this.config.limit || _this.messagesBetweenTimetokens)) {\n                        _this.numPage += 1;\n                        _this.find();\n                    } else {\n\n                        if (_this.needleCount >= _this.config.limit && !_this.messagesBetweenTimetokens) {\n                            _this.hasMore = false;\n                        }\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        _this._emit('$.search.finish');\n                    }\n                });\n            });\n\n            return _this;\n        };\n\n        if (_this.config.event) {\n            _this.plugins.unshift(eventFilter(_this.config.event));\n        }\n\n        if (_this.config.sender) {\n            _this.plugins.unshift(senderFilter(_this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        _this._emit('$.search.start');\n        _this.find();\n        return _this;\n    }\n\n    return Search;\n}(Emitter);\n\nmodule.exports = Search;"},{"id":96,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/filter/event.js","name":"./src/plugins/filter/event.js","index":95,"index2":91,"size":338,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","issuerId":71,"issuerName":"./src/components/search.js","profile":{"factory":340,"building":60},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../plugins/filter/event","loc":"12:18-52"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (event) {\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    var matches = payload && payload.event && payload.event === event;\n\n                    next(!matches, payload);\n                }\n            }\n        }\n    };\n};"},{"id":97,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/filter/sender.js","name":"./src/plugins/filter/sender.js","index":96,"index2":92,"size":346,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","issuerId":71,"issuerName":"./src/components/search.js","profile":{"factory":341,"building":66},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":71,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../plugins/filter/sender","loc":"13:19-54"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":4,"source":"'use strict';\n\nmodule.exports = function (user) {\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n                    var matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                    next(!matches, payload);\n                }\n            }\n        }\n    };\n};"},{"id":98,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/plugins/augment/chat.js","name":"./src/plugins/augment/chat.js","index":97,"index2":94,"size":402,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":52,"issuerName":"./src/components/chat.js","profile":{"factory":107,"building":540},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":52,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../plugins/augment/chat","loc":"18:18-52"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nmodule.exports = function (chat) {\n\n    return {\n        middleware: {\n            on: {\n                '*': function _(payload, next) {\n\n                    // restore chat in payload\n                    if (!payload.chat) {\n                        payload.chat = chat;\n                    }\n\n                    next(null, payload);\n                }\n            }\n        }\n    };\n};"},{"id":99,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":98,"index2":98,"size":4317,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":29,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":291,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"9:9-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar User = require('./user');\nvar Session = require('./session');\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\n\nvar Me = function (_User) {\n    _inherits(Me, _User);\n\n    function Me(chatEngine, uuid) {\n        var _ret;\n\n        _classCallCheck(this, Me);\n\n        var _this = _possibleConstructorReturn(this, (Me.__proto__ || Object.getPrototypeOf(Me)).call(this, chatEngine, uuid));\n\n        // call the User constructor\n\n\n        _this.chatEngine = chatEngine;\n\n        _this.session = false;\n\n        _this.name = 'Me';\n\n        if (_this.chatEngine.ceConfig.enableSync) {\n            _this.session = new Session(chatEngine);\n        }\n\n        return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n\n\n    _createClass(Me, [{\n        key: 'update',\n        value: function update(state) {\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n\n            // assign state values locally before broadcasting them over the network\n            this.assign(state);\n\n            // publish the update over the global channel\n            this.chatEngine.global.setState(state, callback);\n        }\n\n        /**\n         * assign updates from network\n         * @private\n         */\n\n    }, {\n        key: 'assign',\n        value: function assign(state) {\n\n            // run the root update function\n            _get(Me.prototype.__proto__ || Object.getPrototypeOf(Me.prototype), 'assign', this).call(this, state);\n        }\n    }]);\n\n    return Me;\n}(User);\n\nmodule.exports = Me;"},{"id":100,"identifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/session.js","name":"./src/components/session.js","index":100,"index2":97,"size":8790,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","issuerId":99,"issuerName":"./src/components/me.js","profile":{"factory":61,"building":339,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/babel-loader/lib/index.js??ref--1!/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./session","loc":"14:14-34"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Emitter = require('../modules/emitter');\n\nvar Session = function (_Emitter) {\n    _inherits(Session, _Emitter);\n\n    function Session(chatEngine) {\n        _classCallCheck(this, Session);\n\n        var _this = _possibleConstructorReturn(this, (Session.__proto__ || Object.getPrototypeOf(Session)).call(this, chatEngine));\n\n        _this.name = 'Session';\n\n        _this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        _this.chats = {};\n\n        /**\n         * The {@link Chat} that syncs session between instances. Only connects\n         * if \"enableSync\" has been set to true in ceConfig.\n         * @type {this}\n         */\n        _this.sync = null;\n\n        return _this;\n    }\n\n    /**\n     * Forwards sync events from other instances into callback functions\n     * @private\n     */\n\n\n    _createClass(Session, [{\n        key: 'subscribe',\n        value: function subscribe() {\n            var _this2 = this;\n\n            this.sync = new this.chatEngine.Chat([this.chatEngine.global.channel, 'user', this.chatEngine.me.uuid, 'me.', 'sync'].join('#'), false, this.chatEngine.ceConfig.enableSync, {}, 'system');\n\n            // subscribe to the events on our sync chat and forward them\n            this.sync.on('$.session.notify.chat.join', function (payload) {\n                _this2.onJoin(payload.data.subject);\n            });\n\n            this.sync.on('$.session.notify.chat.leave', function (payload) {\n                _this2.onleave(payload.data.subject);\n            });\n        }\n\n        /**\n         * Uses PubNub channel groups to restore a session for this uuid\n         * @private\n         */\n\n    }, {\n        key: 'restore',\n        value: function restore() {\n            var _this3 = this;\n\n            // these are custom groups that separate custom chats from system chats\n            // for better fitlering\n            var groups = ['custom', 'system'];\n\n            // loop through the groups\n            groups.forEach(function (group) {\n\n                // generate the channel group string for PubNub using the current uuid\n                var channelGroup = [_this3.chatEngine.ceConfig.globalChannel, _this3.chatEngine.me.uuid, group].join('#');\n\n                // ask pubnub for a list of channels for this group\n                _this3.chatEngine.pubnub.channelGroups.listChannels({\n                    channelGroup: channelGroup\n                }, function (status, response) {\n\n                    if (status.error) {\n                        _this3.chatEngine.throwError(_this3.chatEngine, '_emit', 'sync', new Error('There was a problem restoring your session from PubNub servers.'), { status: status });\n                    } else {\n\n                        // loop through the returned channels\n                        response.channels.forEach(function (channel) {\n\n                            // call the same callback as if we were notified about them\n                            _this3.onJoin({\n                                channel: channel,\n                                private: _this3.chatEngine.parseChannel(channel).private,\n                                group: group\n                            });\n\n                            /**\n                            Fired when session has been restored at boot. Fired once per\n                            session group.\n                            @event Me#$\".\"session\".\"group\".\"restored\n                            */\n                            _this3.trigger('$.group.restored', { group: group });\n                        });\n                    }\n                });\n            });\n        }\n\n        /**\n         * Callback fired when another instance has joined a chat\n         * @private\n         */\n\n    }, {\n        key: 'join',\n        value: function join(chat) {\n\n            // don't rebroadcast chats in session we've already heard about\n            if (!this.chats[chat.group] || !this.chats[chat.group][chat.channel]) {\n                this.sync.emit('$.session.notify.chat.join', { subject: chat.objectify() });\n            }\n        }\n\n        /**\n         * Callback fired when another instance has left a chat\n         * @private\n         */\n\n    }, {\n        key: 'leave',\n        value: function leave(chat) {\n            this.sync.emit('$.session.notify.chat.leave', { subject: chat.objectify() });\n        }\n\n        /**\n        Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n        @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n        @private\n        */\n\n    }, {\n        key: 'onJoin',\n        value: function onJoin(chat) {\n\n            // create the chat group if it doesn't exist\n            this.chats[chat.group] = this.chats[chat.group] || {};\n\n            // check the chat exists within the global list but is not grouped\n            var existingChat = this.chatEngine.chats[chat.channel];\n\n            // if it exists\n            if (existingChat) {\n\n                // assign it to the group\n                this.chats[chat.group][chat.channel] = existingChat;\n            } else {\n\n                // otherwise, try to recreate it with the server information\n                this.chats[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n                /**\n                Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n                Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n                ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n                @event Me#$\".\"session\".\"chat\".\"join\n                @example\n                *\n                * // Logged in as \"Ian\" in first window\n                * ChatEngine.me.session.on('$.chat.join', (data) => {\n                *     console.log('I joined a new chat in a second window!', data.chat);\n                * });\n                *\n                * // Logged in as \"Ian\" in second window\n                * new ChatEngine.Chat('another-chat');\n                */\n                this.trigger('$.chat.join', { chat: this.chats[chat.group][chat.channel] });\n            }\n        }\n\n        /**\n        Removes {@link Chat} within this.chats\n        @private\n        */\n\n    }, {\n        key: 'onleave',\n        value: function onleave(chat) {\n\n            if (this.chats[chat.group] && this.chats[chat.group][chat.channel]) {\n\n                chat = this.chats[chat.group][chat.channel] || chat;\n\n                /**\n                * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n                * @event Me#$\".\"session\".\"chat\".\"leave\n                */\n\n                delete this.chatEngine.chats[chat.channel];\n                delete this.chats[chat.group][chat.channel];\n            }\n\n            this.trigger('$.chat.leave', { chat: chat });\n        }\n    }]);\n\n    return Session;\n}(Emitter);\n\nmodule.exports = Session;"}],"filteredModules":84,"children":[]}