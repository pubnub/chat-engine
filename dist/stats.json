{"errors":[],"warnings":[],"version":"3.8.1","hash":"33502f2c26b0ec2817b8","publicPath":"","assetsByChunkName":{"main":"chat-engine.js"},"assets":[{"name":"chat-engine.js","size":463765,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"filteredAssets":0,"entrypoints":{"main":{"chunks":[0],"assets":["chat-engine.js"]}},"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":453410,"names":["main"],"files":["chat-engine.js"],"hash":"6018ff857a82608e96a8","parents":[],"modules":[{"id":3,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\webpack\\buildin\\global.js","name":"(webpack)/buildin/global.js","index":37,"index2":31,"size":488,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":161,"building":14},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":27,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\_freeGlobal.js","module":"./node_modules/async/node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/async/node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-47"},{"moduleId":55,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\setimmediate\\setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"},{"id":4,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\webpack\\buildin\\module.js","name":"(webpack)/buildin/module.js","index":38,"index2":34,"size":495,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":162,"building":13},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":74,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\isBuffer.js","module":"./node_modules/async/node_modules/lodash/isBuffer.js","moduleName":"./node_modules/async/node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-47"},{"moduleId":80,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\_nodeUtil.js","module":"./node_modules/async/node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/async/node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-47"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"},{"id":5,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","name":"./src/modules/emitter.js","index":39,"index2":48,"size":7743,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":10,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":60,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\r\nconst RootEmitter = require('./root_emitter');\r\nconst Event = require('../components/event');\r\n\r\n/**\r\n An ChatEngine generic emitter that supports plugins and duplicates\r\n events on the root emitter.\r\n @class Emitter\r\n @extends RootEmitter\r\n */\r\nclass Emitter extends RootEmitter {\r\n\r\n    constructor(chatEngine) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'Emitter';\r\n\r\n        /**\r\n         Stores a list of plugins bound to this object\r\n         @private\r\n         */\r\n        this.plugins = [];\r\n\r\n        /**\r\n         Stores in memory keys and values\r\n         @private\r\n         */\r\n        this._dataset = {};\r\n\r\n        /**\r\n         Emit events locally.\r\n\r\n         @private\r\n         @param {String} event The event payload object\r\n         */\r\n        this._emit = (event, data = {}) => {\r\n\r\n            // all events are forwarded to ChatEngine object\r\n            // so you can globally bind to events with ChatEngine.on()\r\n            this.chatEngine._emit(event, data, this);\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.emit(event, data);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\r\n         * @method\r\n         * @param {String} event The event name\r\n         * @param {Function} cb The function to run when the event is emitted\r\n         * @example\r\n         *\r\n         * // Get notified whenever someone joins the room\r\n         * object.on('event', (payload) => {\r\n         *     console.log('event was fired').\r\n         * })\r\n         *\r\n         * // Get notified of event.a and event.b\r\n         * object.on('event.*', (payload) => {\r\n         *     console.log('event.a or event.b was fired').;\r\n         * })\r\n         */\r\n        this.on = (event, cb) => {\r\n\r\n            // keep track of all events on this emitter\r\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\r\n\r\n            // call the private _on property\r\n            this._on(event, cb);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n    }\r\n\r\n    // add an object as a subobject under a namespoace\r\n    addChild(childName, childOb) {\r\n        // assign the new child object as a property of parent under the\r\n        // given namespace\r\n        this[childName] = childOb;\r\n\r\n        // assign a data set for the namespace if it doesn't exist\r\n        if (!this._dataset[childName]) {\r\n            this._dataset[childName] = {};\r\n        }\r\n\r\n        // the new object can use ```this.parent``` to access\r\n        // the root class\r\n        childOb.parent = this;\r\n\r\n        // bind get() and set() to the data set\r\n        childOb.get = this.get.bind(this._dataset[childName]);\r\n        childOb.set = this.set.bind(this._dataset[childName]);\r\n    }\r\n\r\n    get(key) {\r\n        return this[key];\r\n    }\r\n\r\n    set(key, value) {\r\n        if (this[key] && !value) {\r\n            delete this[key];\r\n        } else {\r\n            this[key] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     Binds a plugin to this object\r\n     @param {Object} module The plugin module\r\n     @tutorial using\r\n     */\r\n    plugin(module) {\r\n\r\n        // add this plugin to a list of plugins for this object\r\n        this.plugins.push(module);\r\n\r\n        // see if there are plugins to attach to this class\r\n        if (module.extends && module.extends[this.name]) {\r\n            // attach the plugins to this class\r\n            // under their namespace\r\n            this.addChild(module.namespace, new module.extends[this.name]());\r\n\r\n            this[module.namespace].ChatEngine = this.chatEngine;\r\n\r\n            // if the plugin has a special construct function\r\n            // run it\r\n            if (this[module.namespace].construct) {\r\n                this[module.namespace].construct();\r\n            }\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    bindProtoPlugins() {\r\n\r\n        if (this.chatEngine.protoPlugins[this.name]) {\r\n\r\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\r\n                this.plugin(module);\r\n            });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Broadcasts an event locally to all listeners.\r\n     @private\r\n     @param {String} event The event name\r\n     @param {Object} payload The event payload object\r\n     */\r\n    trigger(event, payload = {}, done = () => {}) {\r\n\r\n        let complete = () => {\r\n\r\n            // let plugins modify the event\r\n            this.runPluginQueue('on', event, (next) => {\r\n                next(null, payload);\r\n            }, (reject, pluginResponse) => {\r\n\r\n                if (reject) {\r\n                    done(reject);\r\n                } else {\r\n                    // emit this event to any listener\r\n                    this._emit(event, pluginResponse);\r\n                    done(null, event, pluginResponse);\r\n                }\r\n\r\n            });\r\n\r\n        };\r\n\r\n        // this can be made into plugin\r\n        if (typeof payload === 'object') {\r\n\r\n            // restore chat in payload\r\n            if (!payload.chat) {\r\n                payload.chat = this;\r\n            }\r\n\r\n            // if we should try to restore the sender property\r\n            if (payload.sender) {\r\n\r\n                // the user doesn't exist, create it\r\n                payload.sender = new this.chatEngine.User(payload.sender);\r\n\r\n                payload.sender._getState(() => {\r\n                    complete();\r\n                });\r\n\r\n            } else {\r\n                // there's no \"sender\" in this object, move on\r\n                complete();\r\n            }\r\n\r\n        } else {\r\n            // payload is not an object, we want nothing to do with it.\r\n            complete();\r\n        }\r\n    }\r\n\r\n    /**\r\n     Load plugins and attach a queue of functions to execute before and\r\n     after events are trigger or received.\r\n\r\n     @private\r\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\r\n     @param {String} event The event name\r\n     @param {String} first The first function to run before the plugins have run\r\n     @param {String} last The last function to run after the plugins have run\r\n     */\r\n    runPluginQueue(location, event, first, last) {\r\n\r\n        // this assembles a queue of functions to run as middleware\r\n        // event is a triggered event key\r\n        let pluginQueue = [];\r\n\r\n        // the first function is always required\r\n        pluginQueue.push(first);\r\n\r\n        // look through the configured plugins\r\n        this.plugins.forEach((pluginItem) => {\r\n\r\n            // if they have defined a function to run specifically\r\n            // for this event\r\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\r\n\r\n                if (pluginItem.middleware[location][event]) {\r\n                    // add the function to the queue\r\n                    pluginQueue.push(pluginItem.middleware[location][event]);\r\n                }\r\n\r\n                if (pluginItem.middleware[location]['*']) {\r\n                    // add the function to the queue\r\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n\r\n        // waterfall runs the functions in assigned order\r\n        // waiting for one to complete before moving to the next\r\n        // when it's done, the ```last``` parameter is called\r\n        waterfall(pluginQueue, last);\r\n\r\n    }\r\n\r\n    onConstructed() {\r\n\r\n        this.bindProtoPlugins();\r\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Emitter;\r\n"},{"id":14,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4253,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":5},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\r\n// Allows us to create and bind to events. Everything in ChatEngine is an event\r\n// emitter\r\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\r\n\r\n/**\r\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\r\n* ```this.on()```, ```this.emit()```, etc.\r\n* @class RootEmitter\r\n*/\r\nclass RootEmitter {\r\n\r\n    constructor() {\r\n\r\n        /**\r\n        * @private\r\n        */\r\n        this.events = {};\r\n\r\n        this.name = 'RootEmitter';\r\n\r\n        /**\r\n        Create a new EventEmitter2 object for this class.\r\n\r\n        @private\r\n        */\r\n        this.emitter = new EventEmitter2({\r\n            wildcard: true,\r\n            newListener: true,\r\n            maxListeners: 50,\r\n            verboseMemoryLeak: true\r\n        });\r\n\r\n        // we bind to make sure wildcards work\r\n        // https://github.com/asyncly/EventEmitter2/issues/186\r\n\r\n        /**\r\n        Private emit method that broadcasts the event to listeners on this page.\r\n\r\n        @private\r\n        @param {String} event The event name\r\n        @param {Object} the event payload\r\n        */\r\n        this._emit = this.emitter.emit.bind(this.emitter);\r\n\r\n        /**\r\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\r\n\r\n        @private\r\n        @param {String} event The event name\r\n        @param {Function} callback The function to run when the event is emitted\r\n        */\r\n\r\n        this._on = this.emitter.on.bind(this.emitter);\r\n\r\n        /**\r\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @param {Function} cb The function to run when the event is emitted\r\n        * @example\r\n        *\r\n        * // Get notified whenever someone joins the room\r\n        * object.on('event', (payload) => {\r\n        *     console.log('event was fired').\r\n        * })\r\n        *\r\n        * // Get notified of event.a and event.b\r\n        * object.on('event.*', (payload) => {\r\n        *     console.log('event.a or event.b was fired').;\r\n        * })\r\n        */\r\n        this.on = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.on(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Stop a callback from listening to an event.\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @example\r\n        * let callback = function(payload;) {\r\n        *    console.log('something happend!');\r\n        * };\r\n        * object.on('event', callback);\r\n        * // ...\r\n        * object.off('event', callback);\r\n        */\r\n        this.off = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.off(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Listen for any event on this object and fire a callback when it's emitted\r\n        * @method\r\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\r\n        * @example\r\n        * object.onAny((event, payload) => {\r\n        *     console.log('All events trigger this.');\r\n        * });\r\n        */\r\n        this.onAny = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.onAny(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Listen for an event and only fire the callback a single time\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @param {Function} callback The function to run once\r\n        * @example\r\n        * object.once('message', => (event, payload) {\r\n        *     console.log('This is only fired once!');\r\n        * });\r\n        */\r\n        this.once = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.once(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = RootEmitter;\r\n"},{"id":23,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\event.js","name":"./src/components/event.js","index":51,"index2":47,"size":2308,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":20},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\r\n * @class Event\r\n * Represents an event that may be emitted or subscribed to.\r\n */\r\nclass Event {\r\n\r\n    constructor(chatEngine, chat, event) {\r\n\r\n        /**\r\n         Events are always a property of a {@link Chat}. Responsible for\r\n         listening to specific events and firing events when they occur.\r\n         @readonly\r\n         @type String\r\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\r\n         */\r\n        this.channel = chat.channel;\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.chat = chat;\r\n\r\n        this.event = event;\r\n\r\n        this.name = 'Event';\r\n\r\n        /**\r\n         Forwards events to the Chat that registered the event {@link Chat}\r\n\r\n         @private\r\n         @param {Object} data The event payload object\r\n         */\r\n\r\n        // call onMessage when PubNub receives an event\r\n        this.chatEngine.pubnub.addListener({\r\n            message: this.onMessage.bind(this)\r\n        });\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    onMessage(m) {\r\n\r\n        if (this.channel === m.channel && m.message.event === this.event) {\r\n            this.chat.trigger(m.message.event, m.message);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Publishes the event over the PubNub network to the {@link Event} channel\r\n\r\n     @private\r\n     @param {Object} data The event payload object\r\n     */\r\n    publish(m) {\r\n\r\n        m.event = this.event;\r\n\r\n        this.chatEngine.pubnub.publish({\r\n            message: m,\r\n            channel: this.channel\r\n        }, (status) => {\r\n\r\n            if (status.statusCode === 200) {\r\n\r\n                /**\r\n                 * Message successfully published\r\n                 * @event Chat#$\".\"publish\".\"success\r\n                 * @param {Object} data The message object\r\n                 */\r\n                this.chat.trigger('$.publish.success', m);\r\n            } else {\r\n\r\n                /**\r\n                 * There was a problem publishing over the PubNub network.\r\n                 * @event Chat#$\".\"error\".\"publish\r\n                 */\r\n                this.chatEngine.throwError(this.chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), status);\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Event;\r\n"},{"id":29,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\user.js","name":"./src/components/user.js","index":88,"index2":85,"size":5787,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":19,"dependencies":10},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":88,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\r\n\r\n/**\r\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\r\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\r\n@class User\r\n@extends Emitter\r\n@extends RootEmitter\r\n@param {User#uuid} uuid A unique identifier for this user.\r\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\r\n */\r\nclass User extends Emitter {\r\n\r\n    constructor(chatEngine, uuid, state = {}) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'User';\r\n\r\n        /**\r\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\r\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\r\n\r\n         @readonly\r\n         @type String\r\n         */\r\n        this.uuid = uuid;\r\n\r\n        /**\r\n         * Gets the user state. See {@link Me#update} for how to assign state values.\r\n         * @return {Object} Returns a generic JSON object containing state information.\r\n         * @example\r\n         *\r\n         * // State\r\n         * let state = user.state;\r\n         */\r\n        this.state = {};\r\n\r\n        this._stateFetched = false;\r\n\r\n        /**\r\n         * Feed is a Chat that only streams things a User does, like\r\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\r\n         * to a User's feed, but only the User can publish to it. Users will\r\n         * not be able to converse in this channel.\r\n         *\r\n         * @type Chat\r\n         * @example\r\n         * // me\r\n         * me.feed.emit('update', 'I may be away from my computer right now');\r\n         *\r\n         * // another instance\r\n         * them.feed.connect();\r\n         * them.feed.on('update', (payload) => {})\r\n         */\r\n\r\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\r\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\r\n\r\n        /**\r\n         * Direct is a private channel that anybody can publish to but only\r\n         * the user can subscribe to. Great for pushing notifications or\r\n         * inviting to other chats. Users will not be able to communicate\r\n         * with one another inside of this chat. Check out the\r\n         * {@link Chat#invite} method for private chats utilizing\r\n         * {@link User#direct}.\r\n         *\r\n         * @type Chat\r\n         * @example\r\n         * // me\r\n         * me.direct.on('private-message', (payload) -> {\r\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\r\n        * });\r\n         *\r\n         * // another instance\r\n         * them.direct.connect();\r\n         * them.direct.emit('private-message', {secret: 42});\r\n         */\r\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\r\n\r\n        // if the user does not exist at all and we get enough\r\n        // information to build the user\r\n        if (!chatEngine.users[uuid]) {\r\n            chatEngine.users[uuid] = this;\r\n        }\r\n\r\n        // update this user's state in it's created context\r\n        this.assign(state);\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} state The new state for the user\r\n     * @param {Chat} chat Chatroom to retrieve state from\r\n     */\r\n    update(state) {\r\n        let oldState = this.state || {};\r\n        this.state = Object.assign(oldState, state);\r\n    }\r\n\r\n    /**\r\n     this is only called from network updates\r\n\r\n     @private\r\n     */\r\n    assign(state) {\r\n        this.update(state);\r\n    }\r\n\r\n    /**\r\n    Get stored user state from remote server.\r\n    @private\r\n    */\r\n    _getState(callback) {\r\n\r\n        if (!this._stateFetched) {\r\n\r\n            this.chatEngine.pubnub.getState({\r\n                uuid: this.uuid,\r\n                channels: [this.chatEngine.global.channel]\r\n            }, (status, response) => {\r\n\r\n                if (status.statusCode === 200) {\r\n\r\n                    let pnState = response.channels[this.chatEngine.global.channel];\r\n                    if (Object.keys(pnState).length) {\r\n\r\n                        this.assign(response.data);\r\n\r\n                        this._stateFetched = true;\r\n                        callback(this.state);\r\n\r\n                    } else {\r\n\r\n                        this.chatEngine.request('get', 'user_state', {\r\n                            user: this.uuid\r\n                        })\r\n                            .then((res) => {\r\n\r\n                                this.assign(res.data);\r\n\r\n                                this._stateFetched = true;\r\n                                callback(this.state);\r\n\r\n                            })\r\n                            .catch((err) => {\r\n                                // console.log('this is hte err', err);\r\n                                this.chatEngine.throwError(this, 'trigger', 'getState', err);\r\n                            });\r\n\r\n                    }\r\n\r\n                } else {\r\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\r\n                }\r\n\r\n            });\r\n\r\n        } else {\r\n            callback(this.state);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = User;\r\n"},{"id":30,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","name":"./src/index.js","index":0,"index2":88,"size":1764,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":17,"building":15},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\r\nconst init = require('./bootstrap');\r\n\r\n/**\r\nGlobal object used to create an instance of {@link ChatEngine}.\r\n\r\n@alias ChatEngineCore\r\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\r\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\r\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\r\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\r\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\r\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\r\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\r\n@example\r\nChatEngine = ChatEngineCore.create({\r\n    publishKey: 'YOUR_PUB_KEY',\r\n    subscribeKey: 'YOUR_SUB_KEY'\r\n});\r\n*/\r\n\r\nconst create = (pnConfig, ceConfig = {}) => {\r\n\r\n    if (ceConfig.globalChannel) {\r\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\r\n    } else {\r\n        ceConfig.globalChannel = 'chat-engine';\r\n    }\r\n\r\n    if (typeof ceConfig.throwErrors === 'undefined') {\r\n        ceConfig.throwErrors = true;\r\n    }\r\n\r\n    // return an instance of ChatEngine\r\n    return init(ceConfig, pnConfig);\r\n\r\n};\r\n\r\n// export the ChatEngine api\r\nmodule.exports = {\r\n    plugin: {}, // leave a spot for plugins to exist\r\n    create\r\n};\r\n"},{"id":31,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":87,"size":16637,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","issuerId":30,"issuerName":"./src/index.js","profile":{"factory":3,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\r\nconst PubNub = require('pubnub');\r\nconst pack = require('../package.json');\r\n\r\nconst RootEmitter = require('./modules/root_emitter');\r\nconst Chat = require('./components/chat');\r\nconst Me = require('./components/me');\r\nconst User = require('./components/user');\r\nconst async = require('async');\r\n\r\n/**\r\n @class ChatEngine\r\n @extends RootEmitter\r\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\r\n */\r\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\r\n\r\n    // Create the root ChatEngine object\r\n    let ChatEngine = new RootEmitter();\r\n\r\n    ChatEngine.ceConfig = ceConfig;\r\n    ChatEngine.pnConfig = pnConfig;\r\n\r\n    ChatEngine.pnConfig.heartbeatInterval = ChatEngine.pnConfig.heartbeatInterval || 30;\r\n    ChatEngine.pnConfig.presenceTimeout = ChatEngine.pnConfig.presenceTimeout || 60;\r\n\r\n    ChatEngine.ceConfig.endpoint = ChatEngine.ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + ChatEngine.pnConfig.subscribeKey + '/chat-engine-server';\r\n    ChatEngine.ceConfig.globalChannel = ChatEngine.ceConfig.globalChannel || 'chat-engine-global';\r\n\r\n    /**\r\n     * A map of all known {@link User}s in this instance of ChatEngine.\r\n     * @type {Object}\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.users = {};\r\n\r\n    /**\r\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\r\n     * @memberof ChatEngine\r\n     * @type {Object}\r\n     */\r\n    ChatEngine.chats = {};\r\n\r\n    /**\r\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\r\n     * @member {Chat} global\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.global = false;\r\n\r\n    /**\r\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\r\n     * @member {Me} me\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.me = false;\r\n\r\n    /**\r\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\r\n     * @member {Object} pubnub\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.pubnub = false;\r\n\r\n    /**\r\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\r\n     * @member {Object} ready\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.ready = false;\r\n\r\n    /**\r\n     * The package.json for ChatEngine. Used mainly for detecting package version.\r\n     * @type {Object}\r\n     */\r\n    ChatEngine.package = pack;\r\n\r\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\r\n\r\n        if (ceConfig.throwErrors) {\r\n            // throw ceError;\r\n            console.error(payload);\r\n            throw ceError;\r\n        }\r\n\r\n        payload.ceError = ceError.toString();\r\n\r\n        self[cb](['$', 'error', key].join('.'), payload);\r\n\r\n    };\r\n\r\n    if (ceConfig.debug) {\r\n        ChatEngine.onAny((event, payload) => {\r\n            console.info('debug:', event, payload);\r\n        });\r\n    }\r\n\r\n    ChatEngine.protoPlugins = {};\r\n\r\n    /**\r\n     * Bind a plugin to all future instances of a Class.\r\n     * @method ChatEngine#proto\r\n     * @param  {String} className The string representation of a class to bind to\r\n     * @param  {Class} plugin The plugin function.\r\n     */\r\n    ChatEngine.proto = (className, plugin) => {\r\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\r\n        ChatEngine.protoPlugins[className].push(plugin);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\r\n\r\n        let body = {\r\n            uuid: pnConfig.uuid,\r\n            global: ceConfig.globalChannel,\r\n            authData: ChatEngine.me.authData,\r\n            authKey: pnConfig.authKey\r\n        };\r\n\r\n        let params = {\r\n            route\r\n        };\r\n\r\n        body = Object.assign(body, inputBody);\r\n        params = Object.assign(params, inputParams);\r\n\r\n        if (method === 'get' || method === 'delete') {\r\n            params = Object.assign(params, body);\r\n            return axios[method](ceConfig.endpoint, { params });\r\n        } else {\r\n            return axios[method](ceConfig.endpoint, body, { params });\r\n        }\r\n\r\n\r\n    };\r\n\r\n    /**\r\n     * Parse a channel name into chat object parts\r\n     * @private\r\n     */\r\n    ChatEngine.parseChannel = (channel) => {\r\n\r\n        let info = channel.split('#');\r\n\r\n        return {\r\n            global: info[0],\r\n            type: info[1],\r\n            private: info[2] === 'private.'\r\n        };\r\n\r\n    };\r\n\r\n    /**\r\n     * Get the internal channel name of supplied string\r\n     * @private\r\n     */\r\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\r\n\r\n        let channel = original.toString();\r\n\r\n        // public.* has PubNub permissions for everyone to read and write\r\n        // private.* is totally locked down and users must be granted access one by one\r\n        let chanPrivString = 'public.';\r\n\r\n        if (isPrivate) {\r\n            chanPrivString = 'private.';\r\n        }\r\n\r\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\r\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\r\n        }\r\n\r\n        return channel;\r\n\r\n    };\r\n\r\n    /**\r\n     * Connect to realtime service and create instance of {@link Me}\r\n     * @method ChatEngine#connect\r\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\r\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\r\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\r\n     * @param {Object} [authData] Additional data to send to the authentication endpoint to help verify a valid session. ChatEngine SDK does not make use of this, but you might!\r\n     * @fires $\".\"connected\r\n     */\r\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\r\n\r\n        // this creates a user known as Me and\r\n        // connects to the global chatroom\r\n        pnConfig.uuid = uuid;\r\n\r\n        pnConfig.authKey = authKey || pnConfig.uuid;\r\n\r\n        let restoreSession = () => {\r\n\r\n            let groups = ['custom', 'rooms', 'system'];\r\n\r\n            groups.forEach((group) => {\r\n\r\n                let channelGroup = [ceConfig.globalChannel, pnConfig.uuid, group].join('#');\r\n\r\n                ChatEngine.pubnub.channelGroups.listChannels({\r\n                    channelGroup\r\n                }, (status, response) => {\r\n\r\n                    if (status.error) {\r\n                        console.log('operation failed w/ error:', status);\r\n                        return;\r\n                    }\r\n\r\n                    response.channels.forEach((channel) => {\r\n\r\n                        ChatEngine.me.addChatToSession({\r\n                            channel,\r\n                            private: ChatEngine.parseChannel(channel).private,\r\n                            group\r\n                        });\r\n\r\n                    });\r\n\r\n                });\r\n\r\n            });\r\n\r\n        };\r\n\r\n        let complete = () => {\r\n\r\n            ChatEngine.pubnub = new PubNub(pnConfig);\r\n\r\n            // create a new chat to use as global chat\r\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\r\n            ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\r\n\r\n            // build the current user\r\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\r\n            ChatEngine.me.update(state);\r\n\r\n            /**\r\n            * Fired when a {@link Me} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"me\r\n            * @example\r\n            * ChatEngine.on('$.created.me', (data, me) => {\r\n            *     console.log('Me was created', me);\r\n            * });\r\n            */\r\n            ChatEngine.me.onConstructed();\r\n\r\n            ChatEngine.global.on('$.connected', () => {\r\n\r\n                /**\r\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\r\n                 * @event ChatEngine#$\".\"ready\r\n                 * @example\r\n                 * ChatEngine.on('$.ready', (data) => {\r\n                 *     let me = data.me;\r\n                 * })\r\n                 */\r\n                ChatEngine._emit('$.ready', {\r\n                    me: ChatEngine.me\r\n                });\r\n\r\n                ChatEngine.global.getUserUpdates();\r\n\r\n                let chanGroups = [\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\r\n                ];\r\n\r\n                // listen to all PubNub events for this Chat\r\n                ChatEngine.pubnub.addListener({\r\n                    presence: (payload) => {\r\n\r\n                        if (ChatEngine.chats[payload.channel]) {\r\n                            ChatEngine.chats[payload.channel].onPresence(payload);\r\n                        }\r\n\r\n                    }\r\n                });\r\n\r\n                ChatEngine.pubnub.subscribe({\r\n                    channelGroups: chanGroups,\r\n                    withPresence: true\r\n                });\r\n\r\n                ChatEngine.ready = true;\r\n\r\n                restoreSession();\r\n\r\n            });\r\n\r\n            /**\r\n             Fires when PubNub network connection changes.\r\n\r\n             @private\r\n             @param {Object} statusEvent The response status\r\n             */\r\n            ChatEngine.pubnub.addListener({\r\n                status: (statusEvent) => {\r\n\r\n                    /**\r\n                     * SDK detected that network is online.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\r\n                     */\r\n\r\n                    /**\r\n                     * SDK detected that network is down.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\r\n                     */\r\n\r\n                    /**\r\n                     * A subscribe event experienced an exception when running.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\r\n                     */\r\n\r\n                    /**\r\n                     * SDK was able to reconnect to pubnub.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\r\n                     */\r\n\r\n                    /**\r\n                     * SDK subscribed with a new mix of channels.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\r\n                     */\r\n\r\n                    /**\r\n                     * JSON parsing crashed.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\r\n                     */\r\n\r\n                    /**\r\n                     * Server rejected the request.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\r\n                     */\r\n\r\n                    /**\r\n                     * If using decryption strategies and the decryption fails.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\r\n                     */\r\n\r\n                    /**\r\n                     * Request timed out.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\r\n                     */\r\n\r\n                    /**\r\n                     * PAM permission failure.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\r\n                     */\r\n\r\n                    // map the pubnub events into ChatEngine events\r\n                    let categories = {\r\n                        PNNetworkUpCategory: 'up.online',\r\n                        PNNetworkDownCategory: 'down.offline',\r\n                        PNNetworkIssuesCategory: 'down.issue',\r\n                        PNReconnectedCategory: 'up.reconnected',\r\n                        PNConnectedCategory: 'up.connected',\r\n                        PNAccessDeniedCategory: 'down.denied',\r\n                        PNMalformedResponseCategory: 'down.malformed',\r\n                        PNBadRequestCategory: 'down.badrequest',\r\n                        PNDecryptionErrorCategory: 'down.decryption',\r\n                        PNTimeoutCategory: 'down.timeout'\r\n                    };\r\n\r\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\r\n\r\n                    if (statusEvent.affectedChannels) {\r\n                        statusEvent.affectedChannels.forEach((channel) => {\r\n\r\n                            let chat = ChatEngine.chats[channel];\r\n\r\n                            if (chat) {\r\n                                // connected category tells us the chat is ready\r\n                                if (statusEvent.category === 'PNConnectedCategory') {\r\n                                    chat.onConnectionReady();\r\n                                }\r\n\r\n                                // trigger the network events\r\n                                chat.trigger(eventName, statusEvent);\r\n\r\n                            } else {\r\n                                ChatEngine._emit(eventName, statusEvent);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        ChatEngine._emit(eventName, statusEvent);\r\n                    }\r\n                }\r\n            });\r\n        };\r\n\r\n        async.parallel([\r\n            (next) => {\r\n                ChatEngine.request('post', 'bootstrap').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'user_read').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'user_write').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'group').then(complete).catch(next);\r\n            }\r\n        ], (error) => {\r\n            if (error) {\r\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    /**\r\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\r\n     * @member {Chat} Chat\r\n     * @memberof ChatEngine\r\n     * @see {@link Chat}\r\n     */\r\n    ChatEngine.Chat = function (...args) {\r\n\r\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\r\n\r\n        if (ChatEngine.chats[internalChannel]) {\r\n            return ChatEngine.chats[internalChannel];\r\n        } else {\r\n\r\n            let newChat = new Chat(ChatEngine, ...args);\r\n\r\n            /**\r\n            * Fired when a {@link Chat} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"chat\r\n            * @example\r\n            * ChatEngine.on('$.created.chat', (data, chat) => {\r\n            *     console.log('Chat was created', chat);\r\n            * });\r\n            */\r\n            newChat.onConstructed();\r\n\r\n            return newChat;\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\r\n     * @member {User} User\r\n     * @memberof ChatEngine\r\n     * @see {@link User}\r\n     */\r\n    ChatEngine.User = function (...args) {\r\n\r\n        if (ChatEngine.me.uuid === args[0]) {\r\n            return ChatEngine.me;\r\n        } else if (ChatEngine.users[args[0]]) {\r\n            return ChatEngine.users[args[0]];\r\n        } else {\r\n\r\n            let newUser = new User(ChatEngine, ...args);\r\n\r\n            /**\r\n            * Fired when a {@link User} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"user\r\n            * @example\r\n            * ChatEngine.on('$.created.user', (data, user) => {\r\n            *     console.log('Chat was created', user);\r\n            * });\r\n            */\r\n            newUser.onConstructed();\r\n\r\n            return newUser;\r\n\r\n        }\r\n\r\n    };\r\n\r\n    return ChatEngine;\r\n\r\n};\r\n"},{"id":52,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\json-loader\\index.js!C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\package.json","name":"./package.json","index":30,"index2":28,"size":1345,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":39,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.8.4\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^2.2.1\",\"pubnub\":\"^4.17.0\"}}"},{"id":54,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","name":"./src/components/chat.js","index":33,"index2":84,"size":22461,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":15,"dependencies":15},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\r\nconst Emitter = require('../modules/emitter');\r\nconst Event = require('../components/event');\r\nconst Search = require('../components/search');\r\n\r\n/**\r\n This is the root {@link Chat} class that represents a chat room\r\n\r\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\r\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\r\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\r\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\r\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\r\n @class Chat\r\n @extends Emitter\r\n @extends RootEmitter\r\n @fires Chat#$\".\"ready\r\n @fires Chat#$\".\"state\r\n @fires Chat#$\".\"online\".\"*\r\n @fires Chat#$\".\"offline\".\"*\r\n */\r\nclass Chat extends Emitter {\r\n\r\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\r\n\r\n        super(chatEngine);\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'Chat';\r\n\r\n        /**\r\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\r\n        * @type Boolean\r\n        * @readonly\r\n        * @private\r\n        */\r\n        this.group = group;\r\n\r\n        /**\r\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\r\n        * @type Boolean\r\n        * @readonly\r\n        */\r\n        this.isPrivate = isPrivate;\r\n\r\n        /**\r\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\r\n         * @type Object\r\n         * @readonly\r\n         */\r\n        this.meta = meta || {};\r\n\r\n        /**\r\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly granted access.\r\n        * @type Boolean\r\n        * @see  {@tutorial privacy}\r\n        * @readonly\r\n        */\r\n        this.isPrivate = isPrivate;\r\n\r\n        /**\r\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\r\n         * @type String\r\n         * @readonly\r\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\r\n         */\r\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\r\n\r\n        /**\r\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\r\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\r\n\r\n         @type Object\r\n         @readonly\r\n         */\r\n        this.users = {};\r\n\r\n        /**\r\n         * Boolean value that indicates of the Chat is connected to the network\r\n         * @type {Boolean}\r\n         */\r\n        this.connected = false;\r\n\r\n        this.chatEngine.chats[this.channel] = this;\r\n\r\n        if (autoConnect) {\r\n            this.connect();\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     Updates list of {@link User}s in this {@link Chat}\r\n     based on who is online now.\r\n\r\n     @private\r\n     @param {Object} status The response status\r\n     @param {Object} response The response payload object\r\n     */\r\n    onHereNow(status, response) {\r\n\r\n        if (status.error) {\r\n\r\n            /**\r\n             * There was a problem fetching the presence of this chat\r\n             * @event Chat#$\".\"error\".\"presence\r\n             */\r\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), status);\r\n\r\n        } else {\r\n\r\n            // get the list of occupants in this channel\r\n            let occupants = response.channels[this.channel].occupants;\r\n\r\n            // format the userList for rltm.js standard\r\n            occupants.forEach((occupant) => {\r\n                this.userUpdate(occupant.uuid, occupant.state);\r\n            });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * Turns a {@link Chat} into a JSON representation.\r\n    * @return {Object}\r\n    */\r\n    objectify() {\r\n\r\n        return {\r\n            channel: this.channel,\r\n            group: this.group,\r\n            private: this.isPrivate,\r\n            meta: this.meta\r\n        };\r\n\r\n    }\r\n\r\n    /**\r\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\r\n     * @param {User} user The {@link User} to invite to this chatroom.\r\n     * @fires Me#event:$\".\"invite\r\n     * @example\r\n     * // one user running ChatEngine\r\n     * let secretChat = new ChatEngine.Chat('secret-channel');\r\n     * secretChat.invite(someoneElse);\r\n     *\r\n     * // someoneElse in another instance of ChatEngine\r\n     * me.direct.on('$.invite', (payload) => {\r\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\r\n     * });\r\n     */\r\n    invite(user) {\r\n\r\n        this.chatEngine.request('post', 'invite', {\r\n            to: user.uuid,\r\n            chat: this.objectify()\r\n        })\r\n            .then(() => {\r\n\r\n                let send = () => {\r\n\r\n                    /**\r\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\r\n                     * Fired by the {@link Chat#invite} method.\r\n                     * @event Me#$\".\"invite\r\n                     * @tutorial private\r\n                     * @example\r\n                     * me.direct.on('$.invite', (payload) => {\r\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\r\n                     * });\r\n                     */\r\n                    user.direct.emit('$.invite', {\r\n                        channel: this.channel\r\n                    });\r\n\r\n                };\r\n\r\n                if (!user.direct.connected) {\r\n                    user.direct.connect();\r\n                    user.direct.on('$.connected', send);\r\n                } else {\r\n                    send();\r\n                }\r\n\r\n            })\r\n            .catch((error) => {\r\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\r\n\r\n     @private\r\n     @param {Object} data The PubNub presence response for this event\r\n     */\r\n    onPresence(presenceEvent) {\r\n\r\n        // make sure channel matches this channel\r\n\r\n        // someone joins channel\r\n        if (presenceEvent.action === 'join') {\r\n\r\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\r\n\r\n            /**\r\n             * Fired when a {@link User} has joined the room.\r\n             *\r\n             * @event Chat#$\".\"online\".\"join\r\n             * @param {Object} data The payload returned by the event\r\n             * @param {User} data.user The {@link User} that came online\r\n             * @example\r\n             * chat.on('$.join', (data) => {\r\n                          *     console.log('User has joined the room!', data.user);\r\n                          * });\r\n             */\r\n\r\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\r\n            // Avoid firing duplicate $.online events.\r\n            if (!this.users[user.uuid]) {\r\n                this.trigger('$.online.join', { user });\r\n            }\r\n\r\n        }\r\n\r\n        // someone leaves channel\r\n        if (presenceEvent.action === 'leave') {\r\n            this.userLeave(presenceEvent.uuid);\r\n        }\r\n\r\n        // someone timesout\r\n        if (presenceEvent.action === 'timeout') {\r\n            this.userDisconnect(presenceEvent.uuid);\r\n        }\r\n\r\n        // someone's state is updated\r\n        if (presenceEvent.action === 'state-change') {\r\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Update the {@link Chat} metadata on the server.\r\n     * @param  {object} data JSON object representing chat metadta.\r\n     */\r\n    update(data) {\r\n\r\n        let oldMeta = this.meta || {};\r\n        this.meta = Object.assign(oldMeta, data);\r\n\r\n        this.chatEngine.request('post', 'chat', {\r\n            chat: this.objectify()\r\n        }).then(() => {\r\n        }).catch((error) => {\r\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Send events to other clients in this {@link User}.\r\n     * Events are trigger over the network  and all events are made\r\n     * on behalf of {@link Me}\r\n     *\r\n     * @param {String} event The event name\r\n     * @param {Object} data The event payload object\r\n     * @example\r\n     * chat.emit('custom-event', {value: true});\r\n     * chat.on('custom-event', (payload) => {\r\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\r\n      * });\r\n     */\r\n    emit(event, data) {\r\n        if (event === 'message' && typeof data !== 'object') {\r\n            throw new Error('the payload has to be an object');\r\n        }\r\n\r\n        // create a standardized payload object\r\n        let payload = {\r\n            data, // the data supplied from params\r\n            sender: this.chatEngine.me.uuid, // my own uuid\r\n            chat: this, // an instance of this chat\r\n            event,\r\n            chatengineSDK: this.chatEngine.package.version\r\n        };\r\n\r\n        // run the plugin queue to modify the event\r\n        this.runPluginQueue('emit', event, (next) => {\r\n            next(null, payload);\r\n        }, (err, pluginResponse) => {\r\n\r\n            // remove chat otherwise it would be serialized\r\n            // instead, it's rebuilt on the other end.\r\n            // see this.trigger\r\n            delete pluginResponse.chat;\r\n\r\n            // publish the event and data over the configured channel\r\n\r\n            // ensure the event exists within the global space\r\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\r\n\r\n            this.events[event].publish(pluginResponse);\r\n\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\r\n\r\n     @private\r\n     @param {String} uuid The user uuid\r\n     @param {Object} state The user initial state\r\n     @param {Boolean} trigger Force a trigger that this user is online\r\n     */\r\n    createUser(uuid, state) {\r\n\r\n        // Ensure that this user exists in the global list\r\n        // so we can reference it from here out\r\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\r\n        this.chatEngine.users[uuid].assign(state);\r\n\r\n        // trigger the join event over this chatroom\r\n        if (!this.users[uuid]) {\r\n\r\n            /**\r\n             * Broadcast that a {@link User} has come online. This is when\r\n             * the framework firsts learn of a user. This can be triggered\r\n             * by, ```$.join```, or other network events that\r\n             * notify the framework of a new user.\r\n             *\r\n             * @event Chat#$\".\"online\".\"here\r\n             * @param {Object} data The payload returned by the event\r\n             * @param {User} data.user The {@link User} that came online\r\n             * @example\r\n             * chat.on('$.online.here', (data) => {\r\n                      *     console.log('User has come online:', data.user);\r\n                      * });\r\n             */\r\n\r\n            this.trigger('$.online.here', {\r\n                user: this.chatEngine.users[uuid]\r\n            });\r\n\r\n        }\r\n\r\n        // store this user in the chatroom\r\n        this.users[uuid] = this.chatEngine.users[uuid];\r\n\r\n        // return the instance of this user\r\n        return this.chatEngine.users[uuid];\r\n\r\n    }\r\n\r\n    /**\r\n     * Update a user's state.\r\n     * @private\r\n     * @param {String} uuid The {@link User} uuid\r\n     * @param {Object} state State to update for the user\r\n     */\r\n    userUpdate(uuid, state) {\r\n\r\n        // ensure the user exists within the global space\r\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\r\n\r\n        // if we don't know about this user\r\n        if (!this.users[uuid]) {\r\n            // do the whole join thing\r\n            this.createUser(uuid, state);\r\n        }\r\n\r\n        // update this user's state in this chatroom\r\n        this.users[uuid].assign(state);\r\n\r\n        /**\r\n         * Broadcast that a {@link User} has changed state.\r\n         * @event ChatEngine#$\".\"state\r\n         * @param {Object} data The payload returned by the event\r\n         * @param {User} data.user The {@link User} that changed state\r\n         * @param {Object} data.state The new user state\r\n         * @example\r\n         * ChatEngine.on('$.state', (data) => {\r\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\r\n         * });\r\n         */\r\n        this.chatEngine._emit('$.state', {\r\n            user: this.users[uuid],\r\n            state: this.users[uuid].state\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\r\n     * receiving events.\r\n     * @fires Chat#event:$\".\"offline\".\"leave\r\n     * @example\r\n     * chat.leave();\r\n     */\r\n    leave() {\r\n\r\n        // unsubscribe from the channel locally\r\n        this.chatEngine.pubnub.unsubscribe({\r\n            channels: [this.channel]\r\n        });\r\n\r\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\r\n            .then(() => {\r\n\r\n                this.connected = false;\r\n\r\n                this.trigger('$.disconnected');\r\n\r\n                this.chatEngine.me.sync.emit('$.session.chat.leave', { subject: this.objectify() });\r\n\r\n            })\r\n            .catch((error) => {\r\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     Perform updates when a user has left the {@link Chat}.\r\n\r\n     @private\r\n     */\r\n    userLeave(uuid) {\r\n\r\n        // make sure this event is real, user may have already left\r\n        if (this.users[uuid]) {\r\n\r\n            // if a user leaves, trigger the event\r\n\r\n            /**\r\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\r\n             *\r\n             * @event Chat#$\".\"offline\".\"leave\r\n             * @param {Object} data The data payload from the event\r\n             * @param {User} user The {@link User} that has left the room\r\n             * @example\r\n             * chat.on('$.offline.leave', (data) => {\r\n                      *     console.log('User left the room manually:', data.user);\r\n                      * });\r\n             */\r\n            this.trigger('$.offline.leave', {\r\n                user: this.users[uuid]\r\n            });\r\n\r\n            // remove the user from the local list of users\r\n            delete this.users[uuid];\r\n\r\n            // we don't remove the user from the global list,\r\n            // because they may be online in other channels\r\n\r\n        } else {\r\n\r\n            // that user isn't in the user list\r\n            // we never knew about this user or they already left\r\n\r\n            // console.log('user already left');\r\n        }\r\n    }\r\n\r\n    /**\r\n     Fired when a user disconnects from the {@link Chat}\r\n\r\n     @private\r\n     @param {String} uuid The uuid of the {@link Chat} that left\r\n     */\r\n    userDisconnect(uuid) {\r\n\r\n        // make sure this event is real, user may have already left\r\n        if (this.users[uuid]) {\r\n\r\n            /**\r\n             * Fired specifically when a {@link User} looses network connection\r\n             * to the {@link Chat} involuntarily.\r\n             *\r\n             * @event Chat#$\".\"offline\".\"disconnect\r\n             * @param {Object} data The {@link User} that disconnected\r\n             * @param {Object} data.user The {@link User} that disconnected\r\n             * @example\r\n             * chat.on('$.offline.disconnect', (data) => {\r\n                      *     console.log('User disconnected from the network:', data.user);\r\n                      * });\r\n             */\r\n\r\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Set the state for {@link Me} within this {@link User}.\r\n     Broadcasts the ```$.state``` event on other clients\r\n\r\n     @private\r\n     @param {Object} state The new state {@link Me} will have within this {@link User}\r\n     */\r\n    setState(state) {\r\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\r\n            // handle status, response\r\n        });\r\n    }\r\n\r\n    /**\r\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\r\n     which will emit all old events unless ```config.event``` is supplied.\r\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\r\n     @param {Event} [config.event] The {@link Event} to search for.\r\n     @param {User} [config.sender] The {@link User} who sent the message.\r\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history.\r\n     @param {Number} [config.start=0] The timetoken to begin searching between.\r\n     @param {Number} [config.end=0] The timetoken to end searching between.\r\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\r\n     @return {Search}\r\n     @example\r\n    chat.search({\r\n        event: 'my-custom-event',\r\n        sender: ChatEngine.me,\r\n        limit: 20\r\n    }).on('my-custom-event', (event) => {\r\n        console.log('this is an old event!', event);\r\n    }).on('$.search.finish', () => {\r\n        console.log('we have all our results!')\r\n    });\r\n     */\r\n    search(config) {\r\n        return new Search(this.chatEngine, this, config);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    onConnectionReady() {\r\n\r\n        /**\r\n         * Broadcast that the {@link Chat} is connected to the network.\r\n         * @event Chat#$\".\"connected\r\n         * @example\r\n         * chat.on('$.connected', () => {\r\n         *     console.log('chat is ready to go!');\r\n         * });\r\n         */\r\n        this.trigger('$.connected');\r\n\r\n        this.chatEngine.me.sync.emit('$.session.chat.join', { subject: this.objectify() });\r\n\r\n        this.connected = true;\r\n\r\n        // add self to list of users\r\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\r\n\r\n        // trigger my own online event\r\n        this.trigger('$.online.join', {\r\n            user: this.chatEngine.me\r\n        });\r\n\r\n        // global channel updates are triggered manually, only get presence on custom chats\r\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\r\n\r\n            this.getUserUpdates();\r\n\r\n            // we may miss updates, so call this again 5 seconds later\r\n            setTimeout(() => {\r\n                this.getUserUpdates();\r\n            }, 5000);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    getUserUpdates() {\r\n\r\n        // get a list of users online now\r\n        // ask PubNub for information about connected users in this channel\r\n        this.chatEngine.pubnub.hereNow({\r\n            channels: [this.channel],\r\n            includeUUIDs: true,\r\n            includeState: true\r\n        }, this.onHereNow.bind(this));\r\n\r\n    }\r\n\r\n    /**\r\n     * Connect to PubNub servers to initialize the chat.\r\n     * @example\r\n     * // create a new chatroom, but don't connect to it automatically\r\n     * let chat = new Chat('some-chat', false)\r\n     *\r\n     * // connect to the chat when we feel like it\r\n     * chat.connect();\r\n     */\r\n    connect() {\r\n\r\n        async.waterfall([\r\n            (next) => {\r\n                if (!this.chatEngine.pubnub) {\r\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\r\n                } else {\r\n                    next();\r\n                }\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\r\n                    .then(() => {\r\n                        next();\r\n                    })\r\n                    .catch(next);\r\n\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\r\n                    .then(() => {\r\n                        next();\r\n                    })\r\n                    .catch(next);\r\n\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\r\n                    .then((response) => {\r\n\r\n                        if (response.data.found) {\r\n                            this.meta = response.data.chat.meta;\r\n                        } else {\r\n                            this.update(this.meta);\r\n                        }\r\n\r\n                        this.onConnectionReady();\r\n\r\n                    })\r\n                    .catch(next);\r\n\r\n            }\r\n        ], (error) => {\r\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Chat;\r\n"},{"id":60,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\search.js","name":"./src/components/search.js","index":52,"index2":83,"size":7010,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":17,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\r\nconst eachSeries = require('async/eachSeries');\r\n/**\r\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\r\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\r\n@class Search\r\n@extends Emitter\r\n@extends RootEmitter\r\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\r\n@param {Chat} chat The {@link Chat} object to search.\r\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\r\n*/\r\nclass Search extends Emitter {\r\n\r\n    constructor(chatEngine, chat, config = {}) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        /**\r\n        Handy property to identify what this class is.\r\n        @type String\r\n        */\r\n        this.name = 'Search';\r\n\r\n        /**\r\n        The {@link Chat} used for searching.\r\n        @type Chat\r\n        */\r\n        this.chat = chat;\r\n\r\n        /**\r\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\r\n        @type {Object}\r\n        */\r\n        this.config = config;\r\n        this.config.event = config.event;\r\n        this.config.limit = config.limit || 20;\r\n        this.config.channel = this.chat.channel;\r\n        this.config.includeTimetoken = true;\r\n        this.config.stringifiedTimeToken = true;\r\n        this.config.count = this.config.count || 100;\r\n\r\n        this.config.pages = this.config.pages || 10;\r\n\r\n        this.needleCount = 0;\r\n\r\n        this.firstTT = 0;\r\n        this.lastTT = 0;\r\n\r\n        this.firstPage = true;\r\n\r\n        /**\r\n        * @private\r\n        */\r\n        this.sortHistory = (messages, desc) => {\r\n\r\n            messages.sort((a, b) => {\r\n                let e1 = desc ? b : a;\r\n                let e2 = desc ? a : b;\r\n                return parseInt(e1.timetoken, 10) - parseInt(e2.timetoken, 10);\r\n            });\r\n\r\n            return messages;\r\n\r\n        };\r\n\r\n        /**\r\n         * Call PubNub history in a loop.\r\n         * Unapologetically stolen from https://www.pubnub.com/docs/web-javascript/storage-and-history\r\n         * @private\r\n         */\r\n        this.page = (pageDone) => {\r\n\r\n            /**\r\n             * Requesting another page from PubNub History.\r\n             * @event Search#$\".\"page\".\"request\r\n             */\r\n            this._emit('$.search.page.request');\r\n\r\n            // only set start if this is the first call and the user hasn't set it themselves\r\n            this.config.start = this.config.reverse ? this.lastTT : this.firstTT;\r\n\r\n            this.firstPage = false;\r\n\r\n            this.chatEngine.pubnub.history(this.config, (status, response) => {\r\n\r\n                /**\r\n                 * PubNub History returned a response.\r\n                 * @event Search#$\".\"page\".\"response\r\n                 */\r\n                this._emit('$.search.page.response');\r\n\r\n                if (status.error) {\r\n\r\n                    /**\r\n                     * There was a problem fetching the history of this chat\r\n                     * @event Chat#$\".\"error\".\"history\r\n                     */\r\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\r\n\r\n                } else {\r\n\r\n                    // timetoken of the first message in response\r\n                    this.firstTT = response.startTimeToken;\r\n                    // timetoken of the last message in response\r\n                    this.lastTT = response.endTimeToken;\r\n\r\n                    response.messages = this.sortHistory(response.messages);\r\n\r\n                    pageDone(response);\r\n\r\n                }\r\n\r\n            });\r\n        };\r\n\r\n        let eventFilter = (event) => {\r\n            return {\r\n                middleware: {\r\n                    on: {\r\n                        '*': (payload, next) => {\r\n                            let matches = payload && payload.event && payload.event === event;\r\n                            next(!matches, payload);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        let senderFilter = (user) => {\r\n            return {\r\n                middleware: {\r\n                    on: {\r\n                        '*': (payload, next) => {\r\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\r\n                            next(!matches, payload);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        this.needleCount = 0;\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.triggerHistory = (message, cb) => {\r\n\r\n            if (this.needleCount < this.config.limit) {\r\n\r\n                this.trigger(message.entry.event, message.entry, (reject) => {\r\n\r\n                    if (!reject) {\r\n                        this.needleCount += 1;\r\n                    }\r\n                    cb();\r\n\r\n                });\r\n\r\n            } else {\r\n                cb();\r\n            }\r\n\r\n        };\r\n\r\n        this.maxPage = 10;\r\n        this.numPage = 0;\r\n\r\n        this.next = () => {\r\n\r\n            this.maxPage = this.maxPage + this.config.pages;\r\n\r\n            this.find();\r\n\r\n        };\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.find = () => {\r\n\r\n            this.page((response) => {\r\n\r\n                if (!this.config.reverse) {\r\n                    response.messages.reverse();\r\n                }\r\n\r\n                eachSeries(response.messages, this.triggerHistory, () => {\r\n\r\n                    if (this.numPage === this.maxPage) {\r\n                        this._emit('$.search.pause');\r\n                    } else if (\r\n                        response.messages &&\r\n                        response.messages.length === this.config.count &&\r\n                        this.needleCount < this.config.limit) {\r\n                        this.numPage += 1;\r\n                        this.find();\r\n                    } else {\r\n\r\n                        /**\r\n                         * Search has returned all results or reached the end of history.\r\n                         * @event Search#$\".\"search\".\"finish\r\n                         */\r\n                        this._emit('$.search.finish');\r\n                    }\r\n\r\n                });\r\n\r\n            });\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        if (this.config.event) {\r\n            this.plugin(eventFilter(this.config.event));\r\n        }\r\n\r\n        if (this.config.sender) {\r\n            this.plugin(senderFilter(this.config.sender));\r\n        }\r\n\r\n        /**\r\n         * Search has started.\r\n         * @event Search#$\".\"search\".\"start\r\n         */\r\n        this._emit('$.search.start');\r\n        this.find();\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Search;\r\n"},{"id":88,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\me.js","name":"./src/components/me.js","index":87,"index2":86,"size":5075,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":23,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\r\n\r\n/**\r\n Represents the client connection as a special {@link User} with write permissions.\r\n Has the ability to update it's state on the network. An instance of\r\n {@link Me} is returned by the ```ChatEngine.connect()```\r\n method.\r\n\r\n @class Me\r\n @extends User\r\n @extends Emitter\r\n @extends RootEmitter\r\n @param {String} uuid The uuid of this user\r\n */\r\nclass Me extends User {\r\n\r\n    constructor(chatEngine, uuid, authData) {\r\n\r\n        // call the User constructor\r\n        super(chatEngine, uuid);\r\n\r\n        this.name = 'Me';\r\n\r\n        this.authData = authData;\r\n        this.chatEngine = chatEngine;\r\n\r\n        /**\r\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\r\n         * @type {Object}\r\n         */\r\n        this.session = {};\r\n\r\n        this.sync = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'me.', 'sync'].join('#'), false, true, {}, 'system');\r\n\r\n        this.sync.on('$.session.chat.join', (payload) => {\r\n            this.addChatToSession(payload.data.subject);\r\n        });\r\n\r\n        this.sync.on('$.session.chat.leave', (payload) => {\r\n            this.removeChatFromSession(payload.data.subject);\r\n        });\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * assign updates from network\r\n     * @private\r\n     */\r\n    assign(state) {\r\n        // we call \"update\" because calling \"super.assign\"\r\n        // will direct back to \"this.update\" which creates\r\n        // a loop of network updates\r\n        super.update(state);\r\n    }\r\n\r\n    /**\r\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\r\n     * will be notified of this change via ```$.state```.\r\n     * Retrieve state at any time with {@link User#state}.\r\n     * @param {Object} state The new state for {@link Me}\r\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\r\n     * Defaults to ```ChatEngine.global```.\r\n     * @fires Chat#event:$\".\"state\r\n     * @example\r\n     * // update state\r\n     * me.update({value: true});\r\n     */\r\n    update(state) {\r\n\r\n        // run the root update function\r\n        super.update(state);\r\n\r\n        // publish the update over the global channel\r\n        this.chatEngine.global.setState(state);\r\n\r\n    }\r\n\r\n    /**\r\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\r\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\r\n    @private\r\n    */\r\n    addChatToSession(chat) {\r\n\r\n        // create the chat group if it doesn't exist\r\n        this.session[chat.group] = this.session[chat.group] || {};\r\n\r\n        // check the chat exists within the global list but is not grouped\r\n        let existingChat = this.chatEngine.chats[chat.channel];\r\n\r\n        // if it exists\r\n        if (existingChat) {\r\n            // assign it to the group\r\n            this.session[chat.group][chat.channel] = existingChat;\r\n        } else {\r\n\r\n            // otherwise, try to recreate it with the server information\r\n            this.session[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\r\n\r\n            /**\r\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\r\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\r\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\r\n            @event Me#$\".\"session\".\"chat\".\"join\r\n            @example\r\n            *\r\n            * // Logged in as \"Ian\" in first window\r\n            * ChatEngine.me.on('$.session.chat.join', (data) => {\r\n            *     console.log('I joined a new chat in a second window!', data.chat);\r\n            * });\r\n            *\r\n            * // Logged in as \"Ian\" in second window\r\n            * new ChatEngine.Chat('another-chat');\r\n            */\r\n            // this.trigger('$.session.chat.join', {\r\n            //     chat: this.session[chat.group][chat.channel]\r\n            // });\r\n            //\r\n            this.trigger('$.session.chat.join', { chat: this.session[chat.group][chat.channel] });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    Removes {@link Chat} within this.session\r\n    @private\r\n    */\r\n    removeChatFromSession(chat) {\r\n\r\n        if (this.session[chat.group] && this.session[chat.group][chat.channel]) {\r\n\r\n            chat = this.session[chat.group][chat.channel] || chat;\r\n\r\n            /**\r\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\r\n            * @event Me#$\".\"session\".\"chat\".\"leave\r\n            */\r\n\r\n            delete this.chatEngine.chats[chat.channel];\r\n            delete this.session[chat.group][chat.channel];\r\n\r\n            this.trigger('$.session.chat.leave', { chat });\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Me;\r\n"}],"filteredModules":77,"origins":[{"moduleId":30,"module":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":3,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\webpack\\buildin\\global.js","name":"(webpack)/buildin/global.js","index":37,"index2":31,"size":488,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":161,"building":14},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":27,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\_freeGlobal.js","module":"./node_modules/async/node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/async/node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-47"},{"moduleId":55,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\setimmediate\\setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"},{"id":4,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\webpack\\buildin\\module.js","name":"(webpack)/buildin/module.js","index":38,"index2":34,"size":495,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":162,"building":13},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\dist\\async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":74,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\isBuffer.js","module":"./node_modules/async/node_modules/lodash/isBuffer.js","moduleName":"./node_modules/async/node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-47"},{"moduleId":80,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\async\\node_modules\\lodash\\_nodeUtil.js","module":"./node_modules/async/node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/async/node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-47"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"},{"id":5,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","name":"./src/modules/emitter.js","index":39,"index2":48,"size":7743,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":10,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":60,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\r\nconst RootEmitter = require('./root_emitter');\r\nconst Event = require('../components/event');\r\n\r\n/**\r\n An ChatEngine generic emitter that supports plugins and duplicates\r\n events on the root emitter.\r\n @class Emitter\r\n @extends RootEmitter\r\n */\r\nclass Emitter extends RootEmitter {\r\n\r\n    constructor(chatEngine) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'Emitter';\r\n\r\n        /**\r\n         Stores a list of plugins bound to this object\r\n         @private\r\n         */\r\n        this.plugins = [];\r\n\r\n        /**\r\n         Stores in memory keys and values\r\n         @private\r\n         */\r\n        this._dataset = {};\r\n\r\n        /**\r\n         Emit events locally.\r\n\r\n         @private\r\n         @param {String} event The event payload object\r\n         */\r\n        this._emit = (event, data = {}) => {\r\n\r\n            // all events are forwarded to ChatEngine object\r\n            // so you can globally bind to events with ChatEngine.on()\r\n            this.chatEngine._emit(event, data, this);\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.emit(event, data);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\r\n         * @method\r\n         * @param {String} event The event name\r\n         * @param {Function} cb The function to run when the event is emitted\r\n         * @example\r\n         *\r\n         * // Get notified whenever someone joins the room\r\n         * object.on('event', (payload) => {\r\n         *     console.log('event was fired').\r\n         * })\r\n         *\r\n         * // Get notified of event.a and event.b\r\n         * object.on('event.*', (payload) => {\r\n         *     console.log('event.a or event.b was fired').;\r\n         * })\r\n         */\r\n        this.on = (event, cb) => {\r\n\r\n            // keep track of all events on this emitter\r\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\r\n\r\n            // call the private _on property\r\n            this._on(event, cb);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n    }\r\n\r\n    // add an object as a subobject under a namespoace\r\n    addChild(childName, childOb) {\r\n        // assign the new child object as a property of parent under the\r\n        // given namespace\r\n        this[childName] = childOb;\r\n\r\n        // assign a data set for the namespace if it doesn't exist\r\n        if (!this._dataset[childName]) {\r\n            this._dataset[childName] = {};\r\n        }\r\n\r\n        // the new object can use ```this.parent``` to access\r\n        // the root class\r\n        childOb.parent = this;\r\n\r\n        // bind get() and set() to the data set\r\n        childOb.get = this.get.bind(this._dataset[childName]);\r\n        childOb.set = this.set.bind(this._dataset[childName]);\r\n    }\r\n\r\n    get(key) {\r\n        return this[key];\r\n    }\r\n\r\n    set(key, value) {\r\n        if (this[key] && !value) {\r\n            delete this[key];\r\n        } else {\r\n            this[key] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     Binds a plugin to this object\r\n     @param {Object} module The plugin module\r\n     @tutorial using\r\n     */\r\n    plugin(module) {\r\n\r\n        // add this plugin to a list of plugins for this object\r\n        this.plugins.push(module);\r\n\r\n        // see if there are plugins to attach to this class\r\n        if (module.extends && module.extends[this.name]) {\r\n            // attach the plugins to this class\r\n            // under their namespace\r\n            this.addChild(module.namespace, new module.extends[this.name]());\r\n\r\n            this[module.namespace].ChatEngine = this.chatEngine;\r\n\r\n            // if the plugin has a special construct function\r\n            // run it\r\n            if (this[module.namespace].construct) {\r\n                this[module.namespace].construct();\r\n            }\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    bindProtoPlugins() {\r\n\r\n        if (this.chatEngine.protoPlugins[this.name]) {\r\n\r\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\r\n                this.plugin(module);\r\n            });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Broadcasts an event locally to all listeners.\r\n     @private\r\n     @param {String} event The event name\r\n     @param {Object} payload The event payload object\r\n     */\r\n    trigger(event, payload = {}, done = () => {}) {\r\n\r\n        let complete = () => {\r\n\r\n            // let plugins modify the event\r\n            this.runPluginQueue('on', event, (next) => {\r\n                next(null, payload);\r\n            }, (reject, pluginResponse) => {\r\n\r\n                if (reject) {\r\n                    done(reject);\r\n                } else {\r\n                    // emit this event to any listener\r\n                    this._emit(event, pluginResponse);\r\n                    done(null, event, pluginResponse);\r\n                }\r\n\r\n            });\r\n\r\n        };\r\n\r\n        // this can be made into plugin\r\n        if (typeof payload === 'object') {\r\n\r\n            // restore chat in payload\r\n            if (!payload.chat) {\r\n                payload.chat = this;\r\n            }\r\n\r\n            // if we should try to restore the sender property\r\n            if (payload.sender) {\r\n\r\n                // the user doesn't exist, create it\r\n                payload.sender = new this.chatEngine.User(payload.sender);\r\n\r\n                payload.sender._getState(() => {\r\n                    complete();\r\n                });\r\n\r\n            } else {\r\n                // there's no \"sender\" in this object, move on\r\n                complete();\r\n            }\r\n\r\n        } else {\r\n            // payload is not an object, we want nothing to do with it.\r\n            complete();\r\n        }\r\n    }\r\n\r\n    /**\r\n     Load plugins and attach a queue of functions to execute before and\r\n     after events are trigger or received.\r\n\r\n     @private\r\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\r\n     @param {String} event The event name\r\n     @param {String} first The first function to run before the plugins have run\r\n     @param {String} last The last function to run after the plugins have run\r\n     */\r\n    runPluginQueue(location, event, first, last) {\r\n\r\n        // this assembles a queue of functions to run as middleware\r\n        // event is a triggered event key\r\n        let pluginQueue = [];\r\n\r\n        // the first function is always required\r\n        pluginQueue.push(first);\r\n\r\n        // look through the configured plugins\r\n        this.plugins.forEach((pluginItem) => {\r\n\r\n            // if they have defined a function to run specifically\r\n            // for this event\r\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\r\n\r\n                if (pluginItem.middleware[location][event]) {\r\n                    // add the function to the queue\r\n                    pluginQueue.push(pluginItem.middleware[location][event]);\r\n                }\r\n\r\n                if (pluginItem.middleware[location]['*']) {\r\n                    // add the function to the queue\r\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n\r\n        // waterfall runs the functions in assigned order\r\n        // waiting for one to complete before moving to the next\r\n        // when it's done, the ```last``` parameter is called\r\n        waterfall(pluginQueue, last);\r\n\r\n    }\r\n\r\n    onConstructed() {\r\n\r\n        this.bindProtoPlugins();\r\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Emitter;\r\n"},{"id":14,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4253,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":5},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\r\n// Allows us to create and bind to events. Everything in ChatEngine is an event\r\n// emitter\r\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\r\n\r\n/**\r\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\r\n* ```this.on()```, ```this.emit()```, etc.\r\n* @class RootEmitter\r\n*/\r\nclass RootEmitter {\r\n\r\n    constructor() {\r\n\r\n        /**\r\n        * @private\r\n        */\r\n        this.events = {};\r\n\r\n        this.name = 'RootEmitter';\r\n\r\n        /**\r\n        Create a new EventEmitter2 object for this class.\r\n\r\n        @private\r\n        */\r\n        this.emitter = new EventEmitter2({\r\n            wildcard: true,\r\n            newListener: true,\r\n            maxListeners: 50,\r\n            verboseMemoryLeak: true\r\n        });\r\n\r\n        // we bind to make sure wildcards work\r\n        // https://github.com/asyncly/EventEmitter2/issues/186\r\n\r\n        /**\r\n        Private emit method that broadcasts the event to listeners on this page.\r\n\r\n        @private\r\n        @param {String} event The event name\r\n        @param {Object} the event payload\r\n        */\r\n        this._emit = this.emitter.emit.bind(this.emitter);\r\n\r\n        /**\r\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\r\n\r\n        @private\r\n        @param {String} event The event name\r\n        @param {Function} callback The function to run when the event is emitted\r\n        */\r\n\r\n        this._on = this.emitter.on.bind(this.emitter);\r\n\r\n        /**\r\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @param {Function} cb The function to run when the event is emitted\r\n        * @example\r\n        *\r\n        * // Get notified whenever someone joins the room\r\n        * object.on('event', (payload) => {\r\n        *     console.log('event was fired').\r\n        * })\r\n        *\r\n        * // Get notified of event.a and event.b\r\n        * object.on('event.*', (payload) => {\r\n        *     console.log('event.a or event.b was fired').;\r\n        * })\r\n        */\r\n        this.on = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.on(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Stop a callback from listening to an event.\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @example\r\n        * let callback = function(payload;) {\r\n        *    console.log('something happend!');\r\n        * };\r\n        * object.on('event', callback);\r\n        * // ...\r\n        * object.off('event', callback);\r\n        */\r\n        this.off = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.off(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Listen for any event on this object and fire a callback when it's emitted\r\n        * @method\r\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\r\n        * @example\r\n        * object.onAny((event, payload) => {\r\n        *     console.log('All events trigger this.');\r\n        * });\r\n        */\r\n        this.onAny = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.onAny(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        /**\r\n        * Listen for an event and only fire the callback a single time\r\n        * @method\r\n        * @param {String} event The event name\r\n        * @param {Function} callback The function to run once\r\n        * @example\r\n        * object.once('message', => (event, payload) {\r\n        *     console.log('This is only fired once!');\r\n        * });\r\n        */\r\n        this.once = (event, callback) => {\r\n\r\n            // emit the event from the object that created it\r\n            this.emitter.once(event, callback);\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = RootEmitter;\r\n"},{"id":23,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\event.js","name":"./src/components/event.js","index":51,"index2":47,"size":2308,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":20},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\modules\\emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\r\n * @class Event\r\n * Represents an event that may be emitted or subscribed to.\r\n */\r\nclass Event {\r\n\r\n    constructor(chatEngine, chat, event) {\r\n\r\n        /**\r\n         Events are always a property of a {@link Chat}. Responsible for\r\n         listening to specific events and firing events when they occur.\r\n         @readonly\r\n         @type String\r\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\r\n         */\r\n        this.channel = chat.channel;\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.chat = chat;\r\n\r\n        this.event = event;\r\n\r\n        this.name = 'Event';\r\n\r\n        /**\r\n         Forwards events to the Chat that registered the event {@link Chat}\r\n\r\n         @private\r\n         @param {Object} data The event payload object\r\n         */\r\n\r\n        // call onMessage when PubNub receives an event\r\n        this.chatEngine.pubnub.addListener({\r\n            message: this.onMessage.bind(this)\r\n        });\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    onMessage(m) {\r\n\r\n        if (this.channel === m.channel && m.message.event === this.event) {\r\n            this.chat.trigger(m.message.event, m.message);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Publishes the event over the PubNub network to the {@link Event} channel\r\n\r\n     @private\r\n     @param {Object} data The event payload object\r\n     */\r\n    publish(m) {\r\n\r\n        m.event = this.event;\r\n\r\n        this.chatEngine.pubnub.publish({\r\n            message: m,\r\n            channel: this.channel\r\n        }, (status) => {\r\n\r\n            if (status.statusCode === 200) {\r\n\r\n                /**\r\n                 * Message successfully published\r\n                 * @event Chat#$\".\"publish\".\"success\r\n                 * @param {Object} data The message object\r\n                 */\r\n                this.chat.trigger('$.publish.success', m);\r\n            } else {\r\n\r\n                /**\r\n                 * There was a problem publishing over the PubNub network.\r\n                 * @event Chat#$\".\"error\".\"publish\r\n                 */\r\n                this.chatEngine.throwError(this.chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), status);\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Event;\r\n"},{"id":29,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\user.js","name":"./src/components/user.js","index":88,"index2":85,"size":5787,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":19,"dependencies":10},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":88,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\r\n\r\n/**\r\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\r\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\r\n@class User\r\n@extends Emitter\r\n@extends RootEmitter\r\n@param {User#uuid} uuid A unique identifier for this user.\r\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\r\n */\r\nclass User extends Emitter {\r\n\r\n    constructor(chatEngine, uuid, state = {}) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'User';\r\n\r\n        /**\r\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\r\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\r\n\r\n         @readonly\r\n         @type String\r\n         */\r\n        this.uuid = uuid;\r\n\r\n        /**\r\n         * Gets the user state. See {@link Me#update} for how to assign state values.\r\n         * @return {Object} Returns a generic JSON object containing state information.\r\n         * @example\r\n         *\r\n         * // State\r\n         * let state = user.state;\r\n         */\r\n        this.state = {};\r\n\r\n        this._stateFetched = false;\r\n\r\n        /**\r\n         * Feed is a Chat that only streams things a User does, like\r\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\r\n         * to a User's feed, but only the User can publish to it. Users will\r\n         * not be able to converse in this channel.\r\n         *\r\n         * @type Chat\r\n         * @example\r\n         * // me\r\n         * me.feed.emit('update', 'I may be away from my computer right now');\r\n         *\r\n         * // another instance\r\n         * them.feed.connect();\r\n         * them.feed.on('update', (payload) => {})\r\n         */\r\n\r\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\r\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\r\n\r\n        /**\r\n         * Direct is a private channel that anybody can publish to but only\r\n         * the user can subscribe to. Great for pushing notifications or\r\n         * inviting to other chats. Users will not be able to communicate\r\n         * with one another inside of this chat. Check out the\r\n         * {@link Chat#invite} method for private chats utilizing\r\n         * {@link User#direct}.\r\n         *\r\n         * @type Chat\r\n         * @example\r\n         * // me\r\n         * me.direct.on('private-message', (payload) -> {\r\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\r\n        * });\r\n         *\r\n         * // another instance\r\n         * them.direct.connect();\r\n         * them.direct.emit('private-message', {secret: 42});\r\n         */\r\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\r\n\r\n        // if the user does not exist at all and we get enough\r\n        // information to build the user\r\n        if (!chatEngine.users[uuid]) {\r\n            chatEngine.users[uuid] = this;\r\n        }\r\n\r\n        // update this user's state in it's created context\r\n        this.assign(state);\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} state The new state for the user\r\n     * @param {Chat} chat Chatroom to retrieve state from\r\n     */\r\n    update(state) {\r\n        let oldState = this.state || {};\r\n        this.state = Object.assign(oldState, state);\r\n    }\r\n\r\n    /**\r\n     this is only called from network updates\r\n\r\n     @private\r\n     */\r\n    assign(state) {\r\n        this.update(state);\r\n    }\r\n\r\n    /**\r\n    Get stored user state from remote server.\r\n    @private\r\n    */\r\n    _getState(callback) {\r\n\r\n        if (!this._stateFetched) {\r\n\r\n            this.chatEngine.pubnub.getState({\r\n                uuid: this.uuid,\r\n                channels: [this.chatEngine.global.channel]\r\n            }, (status, response) => {\r\n\r\n                if (status.statusCode === 200) {\r\n\r\n                    let pnState = response.channels[this.chatEngine.global.channel];\r\n                    if (Object.keys(pnState).length) {\r\n\r\n                        this.assign(response.data);\r\n\r\n                        this._stateFetched = true;\r\n                        callback(this.state);\r\n\r\n                    } else {\r\n\r\n                        this.chatEngine.request('get', 'user_state', {\r\n                            user: this.uuid\r\n                        })\r\n                            .then((res) => {\r\n\r\n                                this.assign(res.data);\r\n\r\n                                this._stateFetched = true;\r\n                                callback(this.state);\r\n\r\n                            })\r\n                            .catch((err) => {\r\n                                // console.log('this is hte err', err);\r\n                                this.chatEngine.throwError(this, 'trigger', 'getState', err);\r\n                            });\r\n\r\n                    }\r\n\r\n                } else {\r\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\r\n                }\r\n\r\n            });\r\n\r\n        } else {\r\n            callback(this.state);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = User;\r\n"},{"id":30,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","name":"./src/index.js","index":0,"index2":88,"size":1764,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":17,"building":15},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\r\nconst init = require('./bootstrap');\r\n\r\n/**\r\nGlobal object used to create an instance of {@link ChatEngine}.\r\n\r\n@alias ChatEngineCore\r\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\r\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\r\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\r\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\r\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\r\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\r\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\r\n@example\r\nChatEngine = ChatEngineCore.create({\r\n    publishKey: 'YOUR_PUB_KEY',\r\n    subscribeKey: 'YOUR_SUB_KEY'\r\n});\r\n*/\r\n\r\nconst create = (pnConfig, ceConfig = {}) => {\r\n\r\n    if (ceConfig.globalChannel) {\r\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\r\n    } else {\r\n        ceConfig.globalChannel = 'chat-engine';\r\n    }\r\n\r\n    if (typeof ceConfig.throwErrors === 'undefined') {\r\n        ceConfig.throwErrors = true;\r\n    }\r\n\r\n    // return an instance of ChatEngine\r\n    return init(ceConfig, pnConfig);\r\n\r\n};\r\n\r\n// export the ChatEngine api\r\nmodule.exports = {\r\n    plugin: {}, // leave a spot for plugins to exist\r\n    create\r\n};\r\n"},{"id":31,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":87,"size":16637,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","issuerId":30,"issuerName":"./src/index.js","profile":{"factory":3,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\r\nconst PubNub = require('pubnub');\r\nconst pack = require('../package.json');\r\n\r\nconst RootEmitter = require('./modules/root_emitter');\r\nconst Chat = require('./components/chat');\r\nconst Me = require('./components/me');\r\nconst User = require('./components/user');\r\nconst async = require('async');\r\n\r\n/**\r\n @class ChatEngine\r\n @extends RootEmitter\r\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\r\n */\r\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\r\n\r\n    // Create the root ChatEngine object\r\n    let ChatEngine = new RootEmitter();\r\n\r\n    ChatEngine.ceConfig = ceConfig;\r\n    ChatEngine.pnConfig = pnConfig;\r\n\r\n    ChatEngine.pnConfig.heartbeatInterval = ChatEngine.pnConfig.heartbeatInterval || 30;\r\n    ChatEngine.pnConfig.presenceTimeout = ChatEngine.pnConfig.presenceTimeout || 60;\r\n\r\n    ChatEngine.ceConfig.endpoint = ChatEngine.ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + ChatEngine.pnConfig.subscribeKey + '/chat-engine-server';\r\n    ChatEngine.ceConfig.globalChannel = ChatEngine.ceConfig.globalChannel || 'chat-engine-global';\r\n\r\n    /**\r\n     * A map of all known {@link User}s in this instance of ChatEngine.\r\n     * @type {Object}\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.users = {};\r\n\r\n    /**\r\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\r\n     * @memberof ChatEngine\r\n     * @type {Object}\r\n     */\r\n    ChatEngine.chats = {};\r\n\r\n    /**\r\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\r\n     * @member {Chat} global\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.global = false;\r\n\r\n    /**\r\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\r\n     * @member {Me} me\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.me = false;\r\n\r\n    /**\r\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\r\n     * @member {Object} pubnub\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.pubnub = false;\r\n\r\n    /**\r\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\r\n     * @member {Object} ready\r\n     * @memberof ChatEngine\r\n     */\r\n    ChatEngine.ready = false;\r\n\r\n    /**\r\n     * The package.json for ChatEngine. Used mainly for detecting package version.\r\n     * @type {Object}\r\n     */\r\n    ChatEngine.package = pack;\r\n\r\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\r\n\r\n        if (ceConfig.throwErrors) {\r\n            // throw ceError;\r\n            console.error(payload);\r\n            throw ceError;\r\n        }\r\n\r\n        payload.ceError = ceError.toString();\r\n\r\n        self[cb](['$', 'error', key].join('.'), payload);\r\n\r\n    };\r\n\r\n    if (ceConfig.debug) {\r\n        ChatEngine.onAny((event, payload) => {\r\n            console.info('debug:', event, payload);\r\n        });\r\n    }\r\n\r\n    ChatEngine.protoPlugins = {};\r\n\r\n    /**\r\n     * Bind a plugin to all future instances of a Class.\r\n     * @method ChatEngine#proto\r\n     * @param  {String} className The string representation of a class to bind to\r\n     * @param  {Class} plugin The plugin function.\r\n     */\r\n    ChatEngine.proto = (className, plugin) => {\r\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\r\n        ChatEngine.protoPlugins[className].push(plugin);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\r\n\r\n        let body = {\r\n            uuid: pnConfig.uuid,\r\n            global: ceConfig.globalChannel,\r\n            authData: ChatEngine.me.authData,\r\n            authKey: pnConfig.authKey\r\n        };\r\n\r\n        let params = {\r\n            route\r\n        };\r\n\r\n        body = Object.assign(body, inputBody);\r\n        params = Object.assign(params, inputParams);\r\n\r\n        if (method === 'get' || method === 'delete') {\r\n            params = Object.assign(params, body);\r\n            return axios[method](ceConfig.endpoint, { params });\r\n        } else {\r\n            return axios[method](ceConfig.endpoint, body, { params });\r\n        }\r\n\r\n\r\n    };\r\n\r\n    /**\r\n     * Parse a channel name into chat object parts\r\n     * @private\r\n     */\r\n    ChatEngine.parseChannel = (channel) => {\r\n\r\n        let info = channel.split('#');\r\n\r\n        return {\r\n            global: info[0],\r\n            type: info[1],\r\n            private: info[2] === 'private.'\r\n        };\r\n\r\n    };\r\n\r\n    /**\r\n     * Get the internal channel name of supplied string\r\n     * @private\r\n     */\r\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\r\n\r\n        let channel = original.toString();\r\n\r\n        // public.* has PubNub permissions for everyone to read and write\r\n        // private.* is totally locked down and users must be granted access one by one\r\n        let chanPrivString = 'public.';\r\n\r\n        if (isPrivate) {\r\n            chanPrivString = 'private.';\r\n        }\r\n\r\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\r\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\r\n        }\r\n\r\n        return channel;\r\n\r\n    };\r\n\r\n    /**\r\n     * Connect to realtime service and create instance of {@link Me}\r\n     * @method ChatEngine#connect\r\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\r\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\r\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\r\n     * @param {Object} [authData] Additional data to send to the authentication endpoint to help verify a valid session. ChatEngine SDK does not make use of this, but you might!\r\n     * @fires $\".\"connected\r\n     */\r\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\r\n\r\n        // this creates a user known as Me and\r\n        // connects to the global chatroom\r\n        pnConfig.uuid = uuid;\r\n\r\n        pnConfig.authKey = authKey || pnConfig.uuid;\r\n\r\n        let restoreSession = () => {\r\n\r\n            let groups = ['custom', 'rooms', 'system'];\r\n\r\n            groups.forEach((group) => {\r\n\r\n                let channelGroup = [ceConfig.globalChannel, pnConfig.uuid, group].join('#');\r\n\r\n                ChatEngine.pubnub.channelGroups.listChannels({\r\n                    channelGroup\r\n                }, (status, response) => {\r\n\r\n                    if (status.error) {\r\n                        console.log('operation failed w/ error:', status);\r\n                        return;\r\n                    }\r\n\r\n                    response.channels.forEach((channel) => {\r\n\r\n                        ChatEngine.me.addChatToSession({\r\n                            channel,\r\n                            private: ChatEngine.parseChannel(channel).private,\r\n                            group\r\n                        });\r\n\r\n                    });\r\n\r\n                });\r\n\r\n            });\r\n\r\n        };\r\n\r\n        let complete = () => {\r\n\r\n            ChatEngine.pubnub = new PubNub(pnConfig);\r\n\r\n            // create a new chat to use as global chat\r\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\r\n            ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\r\n\r\n            // build the current user\r\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\r\n            ChatEngine.me.update(state);\r\n\r\n            /**\r\n            * Fired when a {@link Me} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"me\r\n            * @example\r\n            * ChatEngine.on('$.created.me', (data, me) => {\r\n            *     console.log('Me was created', me);\r\n            * });\r\n            */\r\n            ChatEngine.me.onConstructed();\r\n\r\n            ChatEngine.global.on('$.connected', () => {\r\n\r\n                /**\r\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\r\n                 * @event ChatEngine#$\".\"ready\r\n                 * @example\r\n                 * ChatEngine.on('$.ready', (data) => {\r\n                 *     let me = data.me;\r\n                 * })\r\n                 */\r\n                ChatEngine._emit('$.ready', {\r\n                    me: ChatEngine.me\r\n                });\r\n\r\n                ChatEngine.global.getUserUpdates();\r\n\r\n                let chanGroups = [\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\r\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\r\n                ];\r\n\r\n                // listen to all PubNub events for this Chat\r\n                ChatEngine.pubnub.addListener({\r\n                    presence: (payload) => {\r\n\r\n                        if (ChatEngine.chats[payload.channel]) {\r\n                            ChatEngine.chats[payload.channel].onPresence(payload);\r\n                        }\r\n\r\n                    }\r\n                });\r\n\r\n                ChatEngine.pubnub.subscribe({\r\n                    channelGroups: chanGroups,\r\n                    withPresence: true\r\n                });\r\n\r\n                ChatEngine.ready = true;\r\n\r\n                restoreSession();\r\n\r\n            });\r\n\r\n            /**\r\n             Fires when PubNub network connection changes.\r\n\r\n             @private\r\n             @param {Object} statusEvent The response status\r\n             */\r\n            ChatEngine.pubnub.addListener({\r\n                status: (statusEvent) => {\r\n\r\n                    /**\r\n                     * SDK detected that network is online.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\r\n                     */\r\n\r\n                    /**\r\n                     * SDK detected that network is down.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\r\n                     */\r\n\r\n                    /**\r\n                     * A subscribe event experienced an exception when running.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\r\n                     */\r\n\r\n                    /**\r\n                     * SDK was able to reconnect to pubnub.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\r\n                     */\r\n\r\n                    /**\r\n                     * SDK subscribed with a new mix of channels.\r\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\r\n                     */\r\n\r\n                    /**\r\n                     * JSON parsing crashed.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\r\n                     */\r\n\r\n                    /**\r\n                     * Server rejected the request.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\r\n                     */\r\n\r\n                    /**\r\n                     * If using decryption strategies and the decryption fails.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\r\n                     */\r\n\r\n                    /**\r\n                     * Request timed out.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\r\n                     */\r\n\r\n                    /**\r\n                     * PAM permission failure.\r\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\r\n                     */\r\n\r\n                    // map the pubnub events into ChatEngine events\r\n                    let categories = {\r\n                        PNNetworkUpCategory: 'up.online',\r\n                        PNNetworkDownCategory: 'down.offline',\r\n                        PNNetworkIssuesCategory: 'down.issue',\r\n                        PNReconnectedCategory: 'up.reconnected',\r\n                        PNConnectedCategory: 'up.connected',\r\n                        PNAccessDeniedCategory: 'down.denied',\r\n                        PNMalformedResponseCategory: 'down.malformed',\r\n                        PNBadRequestCategory: 'down.badrequest',\r\n                        PNDecryptionErrorCategory: 'down.decryption',\r\n                        PNTimeoutCategory: 'down.timeout'\r\n                    };\r\n\r\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\r\n\r\n                    if (statusEvent.affectedChannels) {\r\n                        statusEvent.affectedChannels.forEach((channel) => {\r\n\r\n                            let chat = ChatEngine.chats[channel];\r\n\r\n                            if (chat) {\r\n                                // connected category tells us the chat is ready\r\n                                if (statusEvent.category === 'PNConnectedCategory') {\r\n                                    chat.onConnectionReady();\r\n                                }\r\n\r\n                                // trigger the network events\r\n                                chat.trigger(eventName, statusEvent);\r\n\r\n                            } else {\r\n                                ChatEngine._emit(eventName, statusEvent);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        ChatEngine._emit(eventName, statusEvent);\r\n                    }\r\n                }\r\n            });\r\n        };\r\n\r\n        async.parallel([\r\n            (next) => {\r\n                ChatEngine.request('post', 'bootstrap').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'user_read').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'user_write').then(() => {\r\n                    next(null);\r\n                }).catch(next);\r\n            },\r\n            (next) => {\r\n                ChatEngine.request('post', 'group').then(complete).catch(next);\r\n            }\r\n        ], (error) => {\r\n            if (error) {\r\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    /**\r\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\r\n     * @member {Chat} Chat\r\n     * @memberof ChatEngine\r\n     * @see {@link Chat}\r\n     */\r\n    ChatEngine.Chat = function (...args) {\r\n\r\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\r\n\r\n        if (ChatEngine.chats[internalChannel]) {\r\n            return ChatEngine.chats[internalChannel];\r\n        } else {\r\n\r\n            let newChat = new Chat(ChatEngine, ...args);\r\n\r\n            /**\r\n            * Fired when a {@link Chat} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"chat\r\n            * @example\r\n            * ChatEngine.on('$.created.chat', (data, chat) => {\r\n            *     console.log('Chat was created', chat);\r\n            * });\r\n            */\r\n            newChat.onConstructed();\r\n\r\n            return newChat;\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\r\n     * @member {User} User\r\n     * @memberof ChatEngine\r\n     * @see {@link User}\r\n     */\r\n    ChatEngine.User = function (...args) {\r\n\r\n        if (ChatEngine.me.uuid === args[0]) {\r\n            return ChatEngine.me;\r\n        } else if (ChatEngine.users[args[0]]) {\r\n            return ChatEngine.users[args[0]];\r\n        } else {\r\n\r\n            let newUser = new User(ChatEngine, ...args);\r\n\r\n            /**\r\n            * Fired when a {@link User} has been created within ChatEngine.\r\n            * @event ChatEngine#$\".\"created\".\"user\r\n            * @example\r\n            * ChatEngine.on('$.created.user', (data, user) => {\r\n            *     console.log('Chat was created', user);\r\n            * });\r\n            */\r\n            newUser.onConstructed();\r\n\r\n            return newUser;\r\n\r\n        }\r\n\r\n    };\r\n\r\n    return ChatEngine;\r\n\r\n};\r\n"},{"id":52,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\node_modules\\json-loader\\index.js!C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\package.json","name":"./package.json","index":30,"index2":28,"size":1345,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":39,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.8.4\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^2.2.1\",\"pubnub\":\"^4.17.0\"}}"},{"id":54,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","name":"./src/components/chat.js","index":33,"index2":84,"size":22461,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":15,"dependencies":15},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\r\nconst Emitter = require('../modules/emitter');\r\nconst Event = require('../components/event');\r\nconst Search = require('../components/search');\r\n\r\n/**\r\n This is the root {@link Chat} class that represents a chat room\r\n\r\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\r\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\r\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\r\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\r\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\r\n @class Chat\r\n @extends Emitter\r\n @extends RootEmitter\r\n @fires Chat#$\".\"ready\r\n @fires Chat#$\".\"state\r\n @fires Chat#$\".\"online\".\"*\r\n @fires Chat#$\".\"offline\".\"*\r\n */\r\nclass Chat extends Emitter {\r\n\r\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\r\n\r\n        super(chatEngine);\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        this.name = 'Chat';\r\n\r\n        /**\r\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\r\n        * @type Boolean\r\n        * @readonly\r\n        * @private\r\n        */\r\n        this.group = group;\r\n\r\n        /**\r\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\r\n        * @type Boolean\r\n        * @readonly\r\n        */\r\n        this.isPrivate = isPrivate;\r\n\r\n        /**\r\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\r\n         * @type Object\r\n         * @readonly\r\n         */\r\n        this.meta = meta || {};\r\n\r\n        /**\r\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly granted access.\r\n        * @type Boolean\r\n        * @see  {@tutorial privacy}\r\n        * @readonly\r\n        */\r\n        this.isPrivate = isPrivate;\r\n\r\n        /**\r\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\r\n         * @type String\r\n         * @readonly\r\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\r\n         */\r\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\r\n\r\n        /**\r\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\r\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\r\n\r\n         @type Object\r\n         @readonly\r\n         */\r\n        this.users = {};\r\n\r\n        /**\r\n         * Boolean value that indicates of the Chat is connected to the network\r\n         * @type {Boolean}\r\n         */\r\n        this.connected = false;\r\n\r\n        this.chatEngine.chats[this.channel] = this;\r\n\r\n        if (autoConnect) {\r\n            this.connect();\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     Updates list of {@link User}s in this {@link Chat}\r\n     based on who is online now.\r\n\r\n     @private\r\n     @param {Object} status The response status\r\n     @param {Object} response The response payload object\r\n     */\r\n    onHereNow(status, response) {\r\n\r\n        if (status.error) {\r\n\r\n            /**\r\n             * There was a problem fetching the presence of this chat\r\n             * @event Chat#$\".\"error\".\"presence\r\n             */\r\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), status);\r\n\r\n        } else {\r\n\r\n            // get the list of occupants in this channel\r\n            let occupants = response.channels[this.channel].occupants;\r\n\r\n            // format the userList for rltm.js standard\r\n            occupants.forEach((occupant) => {\r\n                this.userUpdate(occupant.uuid, occupant.state);\r\n            });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * Turns a {@link Chat} into a JSON representation.\r\n    * @return {Object}\r\n    */\r\n    objectify() {\r\n\r\n        return {\r\n            channel: this.channel,\r\n            group: this.group,\r\n            private: this.isPrivate,\r\n            meta: this.meta\r\n        };\r\n\r\n    }\r\n\r\n    /**\r\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\r\n     * @param {User} user The {@link User} to invite to this chatroom.\r\n     * @fires Me#event:$\".\"invite\r\n     * @example\r\n     * // one user running ChatEngine\r\n     * let secretChat = new ChatEngine.Chat('secret-channel');\r\n     * secretChat.invite(someoneElse);\r\n     *\r\n     * // someoneElse in another instance of ChatEngine\r\n     * me.direct.on('$.invite', (payload) => {\r\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\r\n     * });\r\n     */\r\n    invite(user) {\r\n\r\n        this.chatEngine.request('post', 'invite', {\r\n            to: user.uuid,\r\n            chat: this.objectify()\r\n        })\r\n            .then(() => {\r\n\r\n                let send = () => {\r\n\r\n                    /**\r\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\r\n                     * Fired by the {@link Chat#invite} method.\r\n                     * @event Me#$\".\"invite\r\n                     * @tutorial private\r\n                     * @example\r\n                     * me.direct.on('$.invite', (payload) => {\r\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\r\n                     * });\r\n                     */\r\n                    user.direct.emit('$.invite', {\r\n                        channel: this.channel\r\n                    });\r\n\r\n                };\r\n\r\n                if (!user.direct.connected) {\r\n                    user.direct.connect();\r\n                    user.direct.on('$.connected', send);\r\n                } else {\r\n                    send();\r\n                }\r\n\r\n            })\r\n            .catch((error) => {\r\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\r\n\r\n     @private\r\n     @param {Object} data The PubNub presence response for this event\r\n     */\r\n    onPresence(presenceEvent) {\r\n\r\n        // make sure channel matches this channel\r\n\r\n        // someone joins channel\r\n        if (presenceEvent.action === 'join') {\r\n\r\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\r\n\r\n            /**\r\n             * Fired when a {@link User} has joined the room.\r\n             *\r\n             * @event Chat#$\".\"online\".\"join\r\n             * @param {Object} data The payload returned by the event\r\n             * @param {User} data.user The {@link User} that came online\r\n             * @example\r\n             * chat.on('$.join', (data) => {\r\n                          *     console.log('User has joined the room!', data.user);\r\n                          * });\r\n             */\r\n\r\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\r\n            // Avoid firing duplicate $.online events.\r\n            if (!this.users[user.uuid]) {\r\n                this.trigger('$.online.join', { user });\r\n            }\r\n\r\n        }\r\n\r\n        // someone leaves channel\r\n        if (presenceEvent.action === 'leave') {\r\n            this.userLeave(presenceEvent.uuid);\r\n        }\r\n\r\n        // someone timesout\r\n        if (presenceEvent.action === 'timeout') {\r\n            this.userDisconnect(presenceEvent.uuid);\r\n        }\r\n\r\n        // someone's state is updated\r\n        if (presenceEvent.action === 'state-change') {\r\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Update the {@link Chat} metadata on the server.\r\n     * @param  {object} data JSON object representing chat metadta.\r\n     */\r\n    update(data) {\r\n\r\n        let oldMeta = this.meta || {};\r\n        this.meta = Object.assign(oldMeta, data);\r\n\r\n        this.chatEngine.request('post', 'chat', {\r\n            chat: this.objectify()\r\n        }).then(() => {\r\n        }).catch((error) => {\r\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Send events to other clients in this {@link User}.\r\n     * Events are trigger over the network  and all events are made\r\n     * on behalf of {@link Me}\r\n     *\r\n     * @param {String} event The event name\r\n     * @param {Object} data The event payload object\r\n     * @example\r\n     * chat.emit('custom-event', {value: true});\r\n     * chat.on('custom-event', (payload) => {\r\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\r\n      * });\r\n     */\r\n    emit(event, data) {\r\n        if (event === 'message' && typeof data !== 'object') {\r\n            throw new Error('the payload has to be an object');\r\n        }\r\n\r\n        // create a standardized payload object\r\n        let payload = {\r\n            data, // the data supplied from params\r\n            sender: this.chatEngine.me.uuid, // my own uuid\r\n            chat: this, // an instance of this chat\r\n            event,\r\n            chatengineSDK: this.chatEngine.package.version\r\n        };\r\n\r\n        // run the plugin queue to modify the event\r\n        this.runPluginQueue('emit', event, (next) => {\r\n            next(null, payload);\r\n        }, (err, pluginResponse) => {\r\n\r\n            // remove chat otherwise it would be serialized\r\n            // instead, it's rebuilt on the other end.\r\n            // see this.trigger\r\n            delete pluginResponse.chat;\r\n\r\n            // publish the event and data over the configured channel\r\n\r\n            // ensure the event exists within the global space\r\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\r\n\r\n            this.events[event].publish(pluginResponse);\r\n\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\r\n\r\n     @private\r\n     @param {String} uuid The user uuid\r\n     @param {Object} state The user initial state\r\n     @param {Boolean} trigger Force a trigger that this user is online\r\n     */\r\n    createUser(uuid, state) {\r\n\r\n        // Ensure that this user exists in the global list\r\n        // so we can reference it from here out\r\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\r\n        this.chatEngine.users[uuid].assign(state);\r\n\r\n        // trigger the join event over this chatroom\r\n        if (!this.users[uuid]) {\r\n\r\n            /**\r\n             * Broadcast that a {@link User} has come online. This is when\r\n             * the framework firsts learn of a user. This can be triggered\r\n             * by, ```$.join```, or other network events that\r\n             * notify the framework of a new user.\r\n             *\r\n             * @event Chat#$\".\"online\".\"here\r\n             * @param {Object} data The payload returned by the event\r\n             * @param {User} data.user The {@link User} that came online\r\n             * @example\r\n             * chat.on('$.online.here', (data) => {\r\n                      *     console.log('User has come online:', data.user);\r\n                      * });\r\n             */\r\n\r\n            this.trigger('$.online.here', {\r\n                user: this.chatEngine.users[uuid]\r\n            });\r\n\r\n        }\r\n\r\n        // store this user in the chatroom\r\n        this.users[uuid] = this.chatEngine.users[uuid];\r\n\r\n        // return the instance of this user\r\n        return this.chatEngine.users[uuid];\r\n\r\n    }\r\n\r\n    /**\r\n     * Update a user's state.\r\n     * @private\r\n     * @param {String} uuid The {@link User} uuid\r\n     * @param {Object} state State to update for the user\r\n     */\r\n    userUpdate(uuid, state) {\r\n\r\n        // ensure the user exists within the global space\r\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\r\n\r\n        // if we don't know about this user\r\n        if (!this.users[uuid]) {\r\n            // do the whole join thing\r\n            this.createUser(uuid, state);\r\n        }\r\n\r\n        // update this user's state in this chatroom\r\n        this.users[uuid].assign(state);\r\n\r\n        /**\r\n         * Broadcast that a {@link User} has changed state.\r\n         * @event ChatEngine#$\".\"state\r\n         * @param {Object} data The payload returned by the event\r\n         * @param {User} data.user The {@link User} that changed state\r\n         * @param {Object} data.state The new user state\r\n         * @example\r\n         * ChatEngine.on('$.state', (data) => {\r\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\r\n         * });\r\n         */\r\n        this.chatEngine._emit('$.state', {\r\n            user: this.users[uuid],\r\n            state: this.users[uuid].state\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\r\n     * receiving events.\r\n     * @fires Chat#event:$\".\"offline\".\"leave\r\n     * @example\r\n     * chat.leave();\r\n     */\r\n    leave() {\r\n\r\n        // unsubscribe from the channel locally\r\n        this.chatEngine.pubnub.unsubscribe({\r\n            channels: [this.channel]\r\n        });\r\n\r\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\r\n            .then(() => {\r\n\r\n                this.connected = false;\r\n\r\n                this.trigger('$.disconnected');\r\n\r\n                this.chatEngine.me.sync.emit('$.session.chat.leave', { subject: this.objectify() });\r\n\r\n            })\r\n            .catch((error) => {\r\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     Perform updates when a user has left the {@link Chat}.\r\n\r\n     @private\r\n     */\r\n    userLeave(uuid) {\r\n\r\n        // make sure this event is real, user may have already left\r\n        if (this.users[uuid]) {\r\n\r\n            // if a user leaves, trigger the event\r\n\r\n            /**\r\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\r\n             *\r\n             * @event Chat#$\".\"offline\".\"leave\r\n             * @param {Object} data The data payload from the event\r\n             * @param {User} user The {@link User} that has left the room\r\n             * @example\r\n             * chat.on('$.offline.leave', (data) => {\r\n                      *     console.log('User left the room manually:', data.user);\r\n                      * });\r\n             */\r\n            this.trigger('$.offline.leave', {\r\n                user: this.users[uuid]\r\n            });\r\n\r\n            // remove the user from the local list of users\r\n            delete this.users[uuid];\r\n\r\n            // we don't remove the user from the global list,\r\n            // because they may be online in other channels\r\n\r\n        } else {\r\n\r\n            // that user isn't in the user list\r\n            // we never knew about this user or they already left\r\n\r\n            // console.log('user already left');\r\n        }\r\n    }\r\n\r\n    /**\r\n     Fired when a user disconnects from the {@link Chat}\r\n\r\n     @private\r\n     @param {String} uuid The uuid of the {@link Chat} that left\r\n     */\r\n    userDisconnect(uuid) {\r\n\r\n        // make sure this event is real, user may have already left\r\n        if (this.users[uuid]) {\r\n\r\n            /**\r\n             * Fired specifically when a {@link User} looses network connection\r\n             * to the {@link Chat} involuntarily.\r\n             *\r\n             * @event Chat#$\".\"offline\".\"disconnect\r\n             * @param {Object} data The {@link User} that disconnected\r\n             * @param {Object} data.user The {@link User} that disconnected\r\n             * @example\r\n             * chat.on('$.offline.disconnect', (data) => {\r\n                      *     console.log('User disconnected from the network:', data.user);\r\n                      * });\r\n             */\r\n\r\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     Set the state for {@link Me} within this {@link User}.\r\n     Broadcasts the ```$.state``` event on other clients\r\n\r\n     @private\r\n     @param {Object} state The new state {@link Me} will have within this {@link User}\r\n     */\r\n    setState(state) {\r\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\r\n            // handle status, response\r\n        });\r\n    }\r\n\r\n    /**\r\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\r\n     which will emit all old events unless ```config.event``` is supplied.\r\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\r\n     @param {Event} [config.event] The {@link Event} to search for.\r\n     @param {User} [config.sender] The {@link User} who sent the message.\r\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history.\r\n     @param {Number} [config.start=0] The timetoken to begin searching between.\r\n     @param {Number} [config.end=0] The timetoken to end searching between.\r\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\r\n     @return {Search}\r\n     @example\r\n    chat.search({\r\n        event: 'my-custom-event',\r\n        sender: ChatEngine.me,\r\n        limit: 20\r\n    }).on('my-custom-event', (event) => {\r\n        console.log('this is an old event!', event);\r\n    }).on('$.search.finish', () => {\r\n        console.log('we have all our results!')\r\n    });\r\n     */\r\n    search(config) {\r\n        return new Search(this.chatEngine, this, config);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    onConnectionReady() {\r\n\r\n        /**\r\n         * Broadcast that the {@link Chat} is connected to the network.\r\n         * @event Chat#$\".\"connected\r\n         * @example\r\n         * chat.on('$.connected', () => {\r\n         *     console.log('chat is ready to go!');\r\n         * });\r\n         */\r\n        this.trigger('$.connected');\r\n\r\n        this.chatEngine.me.sync.emit('$.session.chat.join', { subject: this.objectify() });\r\n\r\n        this.connected = true;\r\n\r\n        // add self to list of users\r\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\r\n\r\n        // trigger my own online event\r\n        this.trigger('$.online.join', {\r\n            user: this.chatEngine.me\r\n        });\r\n\r\n        // global channel updates are triggered manually, only get presence on custom chats\r\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\r\n\r\n            this.getUserUpdates();\r\n\r\n            // we may miss updates, so call this again 5 seconds later\r\n            setTimeout(() => {\r\n                this.getUserUpdates();\r\n            }, 5000);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    getUserUpdates() {\r\n\r\n        // get a list of users online now\r\n        // ask PubNub for information about connected users in this channel\r\n        this.chatEngine.pubnub.hereNow({\r\n            channels: [this.channel],\r\n            includeUUIDs: true,\r\n            includeState: true\r\n        }, this.onHereNow.bind(this));\r\n\r\n    }\r\n\r\n    /**\r\n     * Connect to PubNub servers to initialize the chat.\r\n     * @example\r\n     * // create a new chatroom, but don't connect to it automatically\r\n     * let chat = new Chat('some-chat', false)\r\n     *\r\n     * // connect to the chat when we feel like it\r\n     * chat.connect();\r\n     */\r\n    connect() {\r\n\r\n        async.waterfall([\r\n            (next) => {\r\n                if (!this.chatEngine.pubnub) {\r\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\r\n                } else {\r\n                    next();\r\n                }\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\r\n                    .then(() => {\r\n                        next();\r\n                    })\r\n                    .catch(next);\r\n\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\r\n                    .then(() => {\r\n                        next();\r\n                    })\r\n                    .catch(next);\r\n\r\n            },\r\n            (next) => {\r\n\r\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\r\n                    .then((response) => {\r\n\r\n                        if (response.data.found) {\r\n                            this.meta = response.data.chat.meta;\r\n                        } else {\r\n                            this.update(this.meta);\r\n                        }\r\n\r\n                        this.onConnectionReady();\r\n\r\n                    })\r\n                    .catch(next);\r\n\r\n            }\r\n        ], (error) => {\r\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Chat;\r\n"},{"id":60,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\search.js","name":"./src/components/search.js","index":52,"index2":83,"size":7010,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":14,"building":17,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":54,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\r\nconst eachSeries = require('async/eachSeries');\r\n/**\r\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\r\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\r\n@class Search\r\n@extends Emitter\r\n@extends RootEmitter\r\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\r\n@param {Chat} chat The {@link Chat} object to search.\r\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\r\n*/\r\nclass Search extends Emitter {\r\n\r\n    constructor(chatEngine, chat, config = {}) {\r\n\r\n        super();\r\n\r\n        this.chatEngine = chatEngine;\r\n\r\n        /**\r\n        Handy property to identify what this class is.\r\n        @type String\r\n        */\r\n        this.name = 'Search';\r\n\r\n        /**\r\n        The {@link Chat} used for searching.\r\n        @type Chat\r\n        */\r\n        this.chat = chat;\r\n\r\n        /**\r\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\r\n        @type {Object}\r\n        */\r\n        this.config = config;\r\n        this.config.event = config.event;\r\n        this.config.limit = config.limit || 20;\r\n        this.config.channel = this.chat.channel;\r\n        this.config.includeTimetoken = true;\r\n        this.config.stringifiedTimeToken = true;\r\n        this.config.count = this.config.count || 100;\r\n\r\n        this.config.pages = this.config.pages || 10;\r\n\r\n        this.needleCount = 0;\r\n\r\n        this.firstTT = 0;\r\n        this.lastTT = 0;\r\n\r\n        this.firstPage = true;\r\n\r\n        /**\r\n        * @private\r\n        */\r\n        this.sortHistory = (messages, desc) => {\r\n\r\n            messages.sort((a, b) => {\r\n                let e1 = desc ? b : a;\r\n                let e2 = desc ? a : b;\r\n                return parseInt(e1.timetoken, 10) - parseInt(e2.timetoken, 10);\r\n            });\r\n\r\n            return messages;\r\n\r\n        };\r\n\r\n        /**\r\n         * Call PubNub history in a loop.\r\n         * Unapologetically stolen from https://www.pubnub.com/docs/web-javascript/storage-and-history\r\n         * @private\r\n         */\r\n        this.page = (pageDone) => {\r\n\r\n            /**\r\n             * Requesting another page from PubNub History.\r\n             * @event Search#$\".\"page\".\"request\r\n             */\r\n            this._emit('$.search.page.request');\r\n\r\n            // only set start if this is the first call and the user hasn't set it themselves\r\n            this.config.start = this.config.reverse ? this.lastTT : this.firstTT;\r\n\r\n            this.firstPage = false;\r\n\r\n            this.chatEngine.pubnub.history(this.config, (status, response) => {\r\n\r\n                /**\r\n                 * PubNub History returned a response.\r\n                 * @event Search#$\".\"page\".\"response\r\n                 */\r\n                this._emit('$.search.page.response');\r\n\r\n                if (status.error) {\r\n\r\n                    /**\r\n                     * There was a problem fetching the history of this chat\r\n                     * @event Chat#$\".\"error\".\"history\r\n                     */\r\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\r\n\r\n                } else {\r\n\r\n                    // timetoken of the first message in response\r\n                    this.firstTT = response.startTimeToken;\r\n                    // timetoken of the last message in response\r\n                    this.lastTT = response.endTimeToken;\r\n\r\n                    response.messages = this.sortHistory(response.messages);\r\n\r\n                    pageDone(response);\r\n\r\n                }\r\n\r\n            });\r\n        };\r\n\r\n        let eventFilter = (event) => {\r\n            return {\r\n                middleware: {\r\n                    on: {\r\n                        '*': (payload, next) => {\r\n                            let matches = payload && payload.event && payload.event === event;\r\n                            next(!matches, payload);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        let senderFilter = (user) => {\r\n            return {\r\n                middleware: {\r\n                    on: {\r\n                        '*': (payload, next) => {\r\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\r\n                            next(!matches, payload);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        this.needleCount = 0;\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.triggerHistory = (message, cb) => {\r\n\r\n            if (this.needleCount < this.config.limit) {\r\n\r\n                this.trigger(message.entry.event, message.entry, (reject) => {\r\n\r\n                    if (!reject) {\r\n                        this.needleCount += 1;\r\n                    }\r\n                    cb();\r\n\r\n                });\r\n\r\n            } else {\r\n                cb();\r\n            }\r\n\r\n        };\r\n\r\n        this.maxPage = 10;\r\n        this.numPage = 0;\r\n\r\n        this.next = () => {\r\n\r\n            this.maxPage = this.maxPage + this.config.pages;\r\n\r\n            this.find();\r\n\r\n        };\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.find = () => {\r\n\r\n            this.page((response) => {\r\n\r\n                if (!this.config.reverse) {\r\n                    response.messages.reverse();\r\n                }\r\n\r\n                eachSeries(response.messages, this.triggerHistory, () => {\r\n\r\n                    if (this.numPage === this.maxPage) {\r\n                        this._emit('$.search.pause');\r\n                    } else if (\r\n                        response.messages &&\r\n                        response.messages.length === this.config.count &&\r\n                        this.needleCount < this.config.limit) {\r\n                        this.numPage += 1;\r\n                        this.find();\r\n                    } else {\r\n\r\n                        /**\r\n                         * Search has returned all results or reached the end of history.\r\n                         * @event Search#$\".\"search\".\"finish\r\n                         */\r\n                        this._emit('$.search.finish');\r\n                    }\r\n\r\n                });\r\n\r\n            });\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n        if (this.config.event) {\r\n            this.plugin(eventFilter(this.config.event));\r\n        }\r\n\r\n        if (this.config.sender) {\r\n            this.plugin(senderFilter(this.config.sender));\r\n        }\r\n\r\n        /**\r\n         * Search has started.\r\n         * @event Search#$\".\"search\".\"start\r\n         */\r\n        this._emit('$.search.start');\r\n        this.find();\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Search;\r\n"},{"id":88,"identifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\components\\me.js","name":"./src/components/me.js","index":87,"index2":86,"size":5075,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":23,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"C:\\Users\\alyyas\\Documents\\GitHub\\chat-engine\\src\\bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\r\n\r\n/**\r\n Represents the client connection as a special {@link User} with write permissions.\r\n Has the ability to update it's state on the network. An instance of\r\n {@link Me} is returned by the ```ChatEngine.connect()```\r\n method.\r\n\r\n @class Me\r\n @extends User\r\n @extends Emitter\r\n @extends RootEmitter\r\n @param {String} uuid The uuid of this user\r\n */\r\nclass Me extends User {\r\n\r\n    constructor(chatEngine, uuid, authData) {\r\n\r\n        // call the User constructor\r\n        super(chatEngine, uuid);\r\n\r\n        this.name = 'Me';\r\n\r\n        this.authData = authData;\r\n        this.chatEngine = chatEngine;\r\n\r\n        /**\r\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\r\n         * @type {Object}\r\n         */\r\n        this.session = {};\r\n\r\n        this.sync = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'me.', 'sync'].join('#'), false, true, {}, 'system');\r\n\r\n        this.sync.on('$.session.chat.join', (payload) => {\r\n            this.addChatToSession(payload.data.subject);\r\n        });\r\n\r\n        this.sync.on('$.session.chat.leave', (payload) => {\r\n            this.removeChatFromSession(payload.data.subject);\r\n        });\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * assign updates from network\r\n     * @private\r\n     */\r\n    assign(state) {\r\n        // we call \"update\" because calling \"super.assign\"\r\n        // will direct back to \"this.update\" which creates\r\n        // a loop of network updates\r\n        super.update(state);\r\n    }\r\n\r\n    /**\r\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\r\n     * will be notified of this change via ```$.state```.\r\n     * Retrieve state at any time with {@link User#state}.\r\n     * @param {Object} state The new state for {@link Me}\r\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\r\n     * Defaults to ```ChatEngine.global```.\r\n     * @fires Chat#event:$\".\"state\r\n     * @example\r\n     * // update state\r\n     * me.update({value: true});\r\n     */\r\n    update(state) {\r\n\r\n        // run the root update function\r\n        super.update(state);\r\n\r\n        // publish the update over the global channel\r\n        this.chatEngine.global.setState(state);\r\n\r\n    }\r\n\r\n    /**\r\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\r\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\r\n    @private\r\n    */\r\n    addChatToSession(chat) {\r\n\r\n        // create the chat group if it doesn't exist\r\n        this.session[chat.group] = this.session[chat.group] || {};\r\n\r\n        // check the chat exists within the global list but is not grouped\r\n        let existingChat = this.chatEngine.chats[chat.channel];\r\n\r\n        // if it exists\r\n        if (existingChat) {\r\n            // assign it to the group\r\n            this.session[chat.group][chat.channel] = existingChat;\r\n        } else {\r\n\r\n            // otherwise, try to recreate it with the server information\r\n            this.session[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\r\n\r\n            /**\r\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\r\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\r\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\r\n            @event Me#$\".\"session\".\"chat\".\"join\r\n            @example\r\n            *\r\n            * // Logged in as \"Ian\" in first window\r\n            * ChatEngine.me.on('$.session.chat.join', (data) => {\r\n            *     console.log('I joined a new chat in a second window!', data.chat);\r\n            * });\r\n            *\r\n            * // Logged in as \"Ian\" in second window\r\n            * new ChatEngine.Chat('another-chat');\r\n            */\r\n            // this.trigger('$.session.chat.join', {\r\n            //     chat: this.session[chat.group][chat.channel]\r\n            // });\r\n            //\r\n            this.trigger('$.session.chat.join', { chat: this.session[chat.group][chat.channel] });\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    Removes {@link Chat} within this.session\r\n    @private\r\n    */\r\n    removeChatFromSession(chat) {\r\n\r\n        if (this.session[chat.group] && this.session[chat.group][chat.channel]) {\r\n\r\n            chat = this.session[chat.group][chat.channel] || chat;\r\n\r\n            /**\r\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\r\n            * @event Me#$\".\"session\".\"chat\".\"leave\r\n            */\r\n\r\n            delete this.chatEngine.chats[chat.channel];\r\n            delete this.session[chat.group][chat.channel];\r\n\r\n            this.trigger('$.session.chat.leave', { chat });\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Me;\r\n"}],"filteredModules":77,"children":[]}
