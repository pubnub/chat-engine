{"errors":[],"warnings":[],"version":"3.8.1","hash":"4419f83696294957d9c0","publicPath":"","assetsByChunkName":{"main":"chat-engine.js"},"assets":[{"name":"chat-engine.js","size":462428,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"filteredAssets":0,"entrypoints":{"main":{"chunks":[0],"assets":["chat-engine.js"]}},"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":451958,"names":["main"],"files":["chat-engine.js"],"hash":"6b63566d3a3329bf1be7","parents":[],"modules":[{"id":3,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":37,"index2":31,"size":488,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":33},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":27,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/setimmediate/setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"},{"id":4,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":38,"index2":34,"size":495,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":32},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":74,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":80,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"},{"id":5,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":39,"index2":48,"size":7474,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":28,"building":17,"dependencies":4},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":60,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\nconst RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        this._dataset = {};\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data = {}) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data, this);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n            return this;\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n            return this;\n\n        };\n\n    }\n\n    // add an object as a subobject under a namespoace\n    addChild(childName, childOb) {\n        // assign the new child object as a property of parent under the\n        // given namespace\n        this[childName] = childOb;\n\n        // assign a data set for the namespace if it doesn't exist\n        if (!this._dataset[childName]) {\n            this._dataset[childName] = {};\n        }\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = this;\n\n        // bind get() and set() to the data set\n        childOb.get = this.get.bind(this._dataset[childName]);\n        childOb.set = this.set.bind(this._dataset[childName]);\n    }\n\n    get(key) {\n        return this[key];\n    }\n\n    set(key, value) {\n        if (this[key] && !value) {\n            delete this[key];\n        } else {\n            this[key] = value;\n        }\n    }\n\n    /**\n     Binds a plugin to this object\n     @param {Object} module The plugin module\n     @tutorial using\n     */\n    plugin(module) {\n\n        // add this plugin to a list of plugins for this object\n        this.plugins.push(module);\n\n        // see if there are plugins to attach to this class\n        if (module.extends && module.extends[this.name]) {\n            // attach the plugins to this class\n            // under their namespace\n            this.addChild(module.namespace, new module.extends[this.name]());\n\n            this[module.namespace].ChatEngine = this.chatEngine;\n\n            // if the plugin has a special construct function\n            // run it\n            if (this[module.namespace].construct) {\n                this[module.namespace].construct();\n            }\n\n        }\n\n        return this;\n\n    }\n\n    bindProtoPlugins() {\n\n        if (this.chatEngine.protoPlugins[this.name]) {\n\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\n                this.plugin(module);\n            });\n\n        }\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n    trigger(event, payload = {}, done = () => {}) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (reject, pluginResponse) => {\n\n                if (reject) {\n                    done(reject);\n                } else {\n                    // emit this event to any listener\n                    this._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // the user doesn't exist, create it\n                payload.sender = new this.chatEngine.User(payload.sender);\n\n                payload.sender._getState(() => {\n                    complete();\n                });\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                if (pluginItem.middleware[location][event]) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location][event]);\n                }\n\n                if (pluginItem.middleware[location]['*']) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\n                }\n\n            }\n\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    onConstructed() {\n\n        this.bindProtoPlugins();\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":14,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4109,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":9,"building":9},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        this.name = 'RootEmitter';\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.on(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.off(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.onAny(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.once(event, callback);\n\n            return this;\n\n        };\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":23,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":51,"index2":47,"size":2220,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":28,"building":10},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\n * @class Event\n * Represents an event that may be emitted or subscribed to.\n */\nclass Event {\n\n    constructor(chatEngine, chat, event) {\n\n        /**\n         Events are always a property of a {@link Chat}. Responsible for\n         listening to specific events and firing events when they occur.\n         @readonly\n         @type String\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = chat.channel;\n\n        this.chatEngine = chatEngine;\n\n        this.chat = chat;\n\n        this.event = event;\n\n        this.name = 'Event';\n\n        /**\n         Forwards events to the Chat that registered the event {@link Chat}\n\n         @private\n         @param {Object} data The event payload object\n         */\n\n        // call onMessage when PubNub receives an event\n        this.chatEngine.pubnub.addListener({\n            message: this.onMessage.bind(this)\n        });\n\n        return this;\n\n    }\n\n    onMessage(m) {\n\n        if (this.channel === m.channel && m.message.event === this.event) {\n            this.chat.trigger(m.message.event, m.message);\n        }\n\n    }\n\n    /**\n     Publishes the event over the PubNub network to the {@link Event} channel\n\n     @private\n     @param {Object} data The event payload object\n     */\n    publish(m) {\n\n        m.event = this.event;\n\n        this.chatEngine.pubnub.publish({\n            message: m,\n            channel: this.channel\n        }, (status) => {\n\n            if (status.statusCode === 200) {\n\n                /**\n                 * Message successfully published\n                 * @event Chat#$\".\"publish\".\"success\n                 * @param {Object} data The message object\n                 */\n                this.chat.trigger('$.publish.success', m);\n            } else {\n\n                /**\n                 * There was a problem publishing over the PubNub network.\n                 * @event Chat#$\".\"error\".\"publish\n                 */\n                this.chatEngine.throwError(this.chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), status);\n            }\n\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":88,"index2":85,"size":5615,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":10,"building":43,"dependencies":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":88,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        this.state = {};\n\n        this._stateFetched = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n        return this;\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(callback) {\n\n        if (!this._stateFetched) {\n\n            this.chatEngine.pubnub.getState({\n                uuid: this.uuid,\n                channels: [this.chatEngine.global.channel]\n            }, (status, response) => {\n\n                if (status.statusCode === 200) {\n\n                    let pnState = response.channels[this.chatEngine.global.channel];\n                    if (Object.keys(pnState).length) {\n\n                        this.assign(response.data);\n\n                        this._stateFetched = true;\n                        callback(this.state);\n\n                    } else {\n\n                        this.chatEngine.request('get', 'user_state', {\n                            user: this.uuid\n                        })\n                            .then((res) => {\n\n                                this.assign(res.data);\n\n                                this._stateFetched = true;\n                                callback(this.state);\n\n                            })\n                            .catch((err) => {\n                                // console.log('this is hte err', err);\n                                this.chatEngine.throwError(this, 'trigger', 'getState', err);\n                            });\n\n                    }\n\n                } else {\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\n                }\n\n            });\n\n        } else {\n            callback(this.state);\n        }\n\n    }\n\n}\n\nmodule.exports = User;\n"},{"id":30,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":88,"size":1721,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":29,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\nconst init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nmodule.exports = {\n    plugin: {}, // leave a spot for plugins to exist\n    create\n};\n"},{"id":31,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":87,"size":16148,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":30,"issuerName":"./src/index.js","profile":{"factory":4,"building":32},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\nconst pack = require('../package.json');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\nconst async = require('async');\n\n/**\n @class ChatEngine\n @extends RootEmitter\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\n */\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    ChatEngine.pnConfig.heartbeatInterval = ChatEngine.pnConfig.heartbeatInterval || 30;\n    ChatEngine.pnConfig.presenceTimeout = ChatEngine.pnConfig.presenceTimeout || 60;\n\n    ChatEngine.ceConfig.endpoint = ChatEngine.ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + ChatEngine.pnConfig.subscribeKey + '/chat-engine-server';\n    ChatEngine.ceConfig.globalChannel = ChatEngine.ceConfig.globalChannel || 'chat-engine-global';\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    if (ceConfig.debug) {\n        ChatEngine.onAny((event, payload) => {\n            console.info('debug:', event, payload);\n        });\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = (className, plugin) => {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\n\n        let body = {\n            uuid: pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authData: ChatEngine.me.authData,\n            authKey: pnConfig.authKey\n        };\n\n        let params = {\n            route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params });\n        }\n\n\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = (channel) => {\n\n        let info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\n\n        let channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @param {Object} [authData] Additional data to send to the authentication endpoint to help verify a valid session. ChatEngine SDK does not make use of this, but you might!\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        pnConfig.uuid = uuid;\n\n        pnConfig.authKey = authKey || pnConfig.uuid;\n\n        let restoreSession = () => {\n\n            let groups = ['custom', 'rooms', 'system'];\n\n            groups.forEach((group) => {\n\n                let channelGroup = [ceConfig.globalChannel, pnConfig.uuid, group].join('#');\n\n                ChatEngine.pubnub.channelGroups.listChannels({\n                    channelGroup\n                }, (status, response) => {\n\n                    if (status.error) {\n                        console.log('operation failed w/ error:', status);\n                        return;\n                    }\n\n                    response.channels.forEach((channel) => {\n\n                        ChatEngine.me.addChatToSession({\n                            channel,\n                            private: ChatEngine.parseChannel(channel).private,\n                            group\n                        });\n\n                    });\n\n                });\n\n            });\n\n        };\n\n        let complete = () => {\n\n            ChatEngine.pubnub = new PubNub(pnConfig);\n\n            // create a new chat to use as global chat\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\n            ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\n            ChatEngine.me.update(state);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            ChatEngine.global.on('$.connected', () => {\n\n                /**\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\n                 * @event ChatEngine#$\".\"ready\n                 * @example\n                 * ChatEngine.on('$.ready', (data) => {\n                 *     let me = data.me;\n                 * })\n                 */\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.global.getUserUpdates();\n\n                let chanGroups = [\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\n                ];\n\n                // listen to all PubNub events for this Chat\n                ChatEngine.pubnub.addListener({\n                    presence: (payload) => {\n\n                        if (ChatEngine.chats[payload.channel]) {\n                            ChatEngine.chats[payload.channel].onPresence(payload);\n                        }\n\n                    }\n                });\n\n                ChatEngine.pubnub.subscribe({\n                    channelGroups: chanGroups,\n                    withPresence: true\n                });\n\n                ChatEngine.ready = true;\n\n                restoreSession();\n\n            });\n\n            /**\n             Fires when PubNub network connection changes.\n\n             @private\n             @param {Object} statusEvent The response status\n             */\n            ChatEngine.pubnub.addListener({\n                status: (statusEvent) => {\n\n                    /**\n                     * SDK detected that network is online.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\n                     */\n\n                    /**\n                     * SDK detected that network is down.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                     */\n\n                    /**\n                     * A subscribe event experienced an exception when running.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                     */\n\n                    /**\n                     * SDK was able to reconnect to pubnub.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                     */\n\n                    /**\n                     * SDK subscribed with a new mix of channels.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                     */\n\n                    /**\n                     * JSON parsing crashed.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                     */\n\n                    /**\n                     * Server rejected the request.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                     */\n\n                    /**\n                     * If using decryption strategies and the decryption fails.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                     */\n\n                    /**\n                     * Request timed out.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                     */\n\n                    /**\n                     * PAM permission failure.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                     */\n\n                    // map the pubnub events into ChatEngine events\n                    let categories = {\n                        PNNetworkUpCategory: 'up.online',\n                        PNNetworkDownCategory: 'down.offline',\n                        PNNetworkIssuesCategory: 'down.issue',\n                        PNReconnectedCategory: 'up.reconnected',\n                        PNConnectedCategory: 'up.connected',\n                        PNAccessDeniedCategory: 'down.denied',\n                        PNMalformedResponseCategory: 'down.malformed',\n                        PNBadRequestCategory: 'down.badrequest',\n                        PNDecryptionErrorCategory: 'down.decryption',\n                        PNTimeoutCategory: 'down.timeout'\n                    };\n\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                    if (statusEvent.affectedChannels) {\n                        statusEvent.affectedChannels.forEach((channel) => {\n\n                            let chat = ChatEngine.chats[channel];\n\n                            if (chat) {\n                                // connected category tells us the chat is ready\n                                if (statusEvent.category === 'PNConnectedCategory') {\n                                    chat.onConnectionReady();\n                                }\n\n                                // trigger the network events\n                                chat.trigger(eventName, statusEvent);\n\n                            } else {\n                                ChatEngine._emit(eventName, statusEvent);\n                            }\n                        });\n                    } else {\n                        ChatEngine._emit(eventName, statusEvent);\n                    }\n                }\n            });\n        };\n\n        async.parallel([\n            (next) => {\n                ChatEngine.request('post', 'bootstrap').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_read').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_write').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'group').then(complete).catch(next);\n            }\n        ], (error) => {\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\n            }\n        });\n\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function (...args) {\n\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            let newChat = new Chat(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n\n        }\n\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function (...args) {\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            let newUser = new User(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n\n        }\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":52,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1345,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":75,"building":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.8.4\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^4.1.2\",\"pubnub\":\"^4.17.0\"}}"},{"id":54,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":84,"size":21806,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":9,"building":35,"dependencies":29},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst Search = require('../components/search');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Chat';\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        this.meta = meta || {};\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly granted access.\n        * @type Boolean\n        * @see  {@tutorial privacy}\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        this.chatEngine.chats[this.channel] = this;\n\n        if (autoConnect) {\n            this.connect();\n        }\n\n        return this;\n\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n\n     @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n    onHereNow(status, response) {\n\n        if (status.error) {\n\n            /**\n             * There was a problem fetching the presence of this chat\n             * @event Chat#$\".\"error\".\"presence\n             */\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), status);\n\n        } else {\n\n            // get the list of occupants in this channel\n            let occupants = response.channels[this.channel].occupants;\n\n            // format the userList for rltm.js standard\n            occupants.forEach((occupant) => {\n                this.userUpdate(occupant.uuid, occupant.state);\n            });\n\n        }\n\n    }\n\n    /**\n    * Turns a {@link Chat} into a JSON representation.\n    * @return {Object}\n    */\n    objectify() {\n\n        return {\n            channel: this.channel,\n            group: this.group,\n            private: this.isPrivate,\n            meta: this.meta\n        };\n\n    }\n\n    /**\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n     * @param {User} user The {@link User} to invite to this chatroom.\n     * @fires Me#event:$\".\"invite\n     * @example\n     * // one user running ChatEngine\n     * let secretChat = new ChatEngine.Chat('secret-channel');\n     * secretChat.invite(someoneElse);\n     *\n     * // someoneElse in another instance of ChatEngine\n     * me.direct.on('$.invite', (payload) => {\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n     * });\n     */\n    invite(user) {\n\n        this.chatEngine.request('post', 'invite', {\n            to: user.uuid,\n            chat: this.objectify()\n        })\n            .then(() => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n            });\n\n    }\n\n    /**\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n     @private\n     @param {Object} data The PubNub presence response for this event\n     */\n    onPresence(presenceEvent) {\n\n        // make sure channel matches this channel\n\n        // someone joins channel\n        if (presenceEvent.action === 'join') {\n\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n            /**\n             * Fired when a {@link User} has joined the room.\n             *\n             * @event Chat#$\".\"online\".\"join\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.join', (data) => {\n                          *     console.log('User has joined the room!', data.user);\n                          * });\n             */\n\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\n            // Avoid firing duplicate $.online events.\n            if (!this.users[user.uuid]) {\n                this.trigger('$.online.join', { user });\n            }\n\n        }\n\n        // someone leaves channel\n        if (presenceEvent.action === 'leave') {\n            this.userLeave(presenceEvent.uuid);\n        }\n\n        // someone timesout\n        if (presenceEvent.action === 'timeout') {\n            this.userDisconnect(presenceEvent.uuid);\n        }\n\n        // someone's state is updated\n        if (presenceEvent.action === 'state-change') {\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n        }\n\n\n    }\n\n    /**\n     * Update the {@link Chat} metadata on the server.\n     * @param  {object} data JSON object representing chat metadta.\n     */\n    update(data) {\n\n        let oldMeta = this.meta || {};\n        this.meta = Object.assign(oldMeta, data);\n\n        this.chatEngine.request('post', 'chat', {\n            chat: this.objectify()\n        }).then(() => {\n        }).catch((error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n      * });\n     */\n    emit(event, data) {\n        if (event === 'message' && typeof data !== 'object') {\n            throw new Error('the payload has to be an object');\n        }\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n            event,\n            chatengineSDK: this.chatEngine.package.version\n        };\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n\n            // ensure the event exists within the global space\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            this.events[event].publish(pluginResponse);\n\n        });\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n        this.chatEngine.users[uuid].assign(state);\n\n        // trigger the join event over this chatroom\n        if (!this.users[uuid]) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // store this user in the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n     * receiving events.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\n            .then(() => {\n\n                this.connected = false;\n\n                this.trigger('$.disconnected');\n\n                this.chatEngine.me.sync.emit('$.session.chat.leave', { subject: this.objectify() });\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', {\n                user: this.users[uuid]\n            });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        } else {\n\n            // that user isn't in the user list\n            // we never knew about this user or they already left\n\n            // console.log('user already left');\n        }\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n                      *     console.log('User disconnected from the network:', data.user);\n                      * });\n             */\n\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\n        }\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    /**\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n     which will emit all old events unless ```config.event``` is supplied.\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n     @param {Event} [config.event] The {@link Event} to search for.\n     @param {User} [config.sender] The {@link User} who sent the message.\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history.\n     @param {Number} [config.start=0] The timetoken to begin searching between.\n     @param {Number} [config.end=0] The timetoken to end searching between.\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\n     @return {Search}\n     @example\n    chat.search({\n        event: 'my-custom-event',\n        sender: ChatEngine.me,\n        limit: 20\n    }).on('my-custom-event', (event) => {\n        console.log('this is an old event!', event);\n    }).on('$.search.finish', () => {\n        console.log('we have all our results!')\n    });\n     */\n    search(config) {\n        return new Search(this.chatEngine, this, config);\n    }\n\n    /**\n     * @private\n     */\n    onConnectionReady() {\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n         *     console.log('chat is ready to go!');\n         * });\n         */\n        this.trigger('$.connected');\n\n        this.chatEngine.me.sync.emit('$.session.chat.join', { subject: this.objectify() });\n\n        this.connected = true;\n\n        // add self to list of users\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n        // trigger my own online event\n        this.trigger('$.online.join', {\n            user: this.chatEngine.me\n        });\n\n        // global channel updates are triggered manually, only get presence on custom chats\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n            this.getUserUpdates();\n\n            // we may miss updates, so call this again 5 seconds later\n            setTimeout(() => {\n                this.getUserUpdates();\n            }, 5000);\n\n        }\n\n    }\n\n    getUserUpdates() {\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, this.onHereNow.bind(this));\n\n    }\n\n    /**\n     * Connect to PubNub servers to initialize the chat.\n     * @example\n     * // create a new chatroom, but don't connect to it automatically\n     * let chat = new Chat('some-chat', false)\n     *\n     * // connect to the chat when we feel like it\n     * chat.connect();\n     */\n    connect() {\n\n        async.waterfall([\n            (next) => {\n                if (!this.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\n                    .then((response) => {\n\n                        if (response.data.found) {\n                            this.meta = response.data.chat.meta;\n                        } else {\n                            this.update(this.meta);\n                        }\n\n                        this.onConnectionReady();\n\n                    })\n                    .catch(next);\n\n            }\n        ], (error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":60,"identifier":"/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":52,"index2":83,"size":6914,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":29,"building":25,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\nconst eachSeries = require('async/eachSeries');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\nclass Search extends Emitter {\n\n    constructor(chatEngine, chat, config = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        this.chat = chat;\n\n        // slice() operation clones the array and returns the reference to the new array.\n        this.plugins = this.chat.plugins.slice();\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        this.config = config;\n        this.config.event = config.event;\n        this.config.limit = config.limit || 20;\n        this.config.channel = this.chat.channel;\n        this.config.includeTimetoken = true;\n        this.config.stringifiedTimeToken = true;\n        this.config.count = this.config.count || 100;\n\n        this.config.pages = this.config.pages || 10;\n\n        this.needleCount = 0;\n\n        this.firstTT = 0;\n        this.lastTT = 0;\n\n        this.firstPage = true;\n\n        /**\n        * @private\n        */\n        this.sortHistory = (messages, desc) => {\n\n            messages.sort((a, b) => {\n                let e1 = desc ? b : a;\n                let e2 = desc ? a : b;\n                return parseInt(e1.timetoken, 10) - parseInt(e2.timetoken, 10);\n            });\n\n            return messages;\n\n        };\n\n        /**\n         * Call PubNub history in a loop.\n         * Unapologetically stolen from https://www.pubnub.com/docs/web-javascript/storage-and-history\n         * @private\n         */\n        this.page = (pageDone) => {\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            this._emit('$.search.page.request');\n\n            // only set start if this is the first call and the user hasn't set it themselves\n            this.config.start = this.config.reverse ? this.lastTT : this.firstTT;\n\n            this.firstPage = false;\n\n            this.chatEngine.pubnub.history(this.config, (status, response) => {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n\n                } else {\n\n                    // timetoken of the first message in response\n                    this.firstTT = response.startTimeToken;\n                    // timetoken of the last message in response\n                    this.lastTT = response.endTimeToken;\n\n                    response.messages = this.sortHistory(response.messages);\n\n                    pageDone(response);\n\n                }\n\n            });\n        };\n\n        let eventFilter = (event) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n                            let matches = payload && payload.event && payload.event === event;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        let senderFilter = (user) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        this.needleCount = 0;\n\n        /**\n         * @private\n         */\n        this.triggerHistory = (message, cb) => {\n\n            if (this.needleCount < this.config.limit) {\n\n                this.trigger(message.entry.event, message.entry, (reject) => {\n\n                    if (!reject) {\n                        this.needleCount += 1;\n                    }\n                    cb();\n\n                });\n\n            } else {\n                cb();\n            }\n\n        };\n\n        this.maxPage = 10;\n        this.numPage = 0;\n\n        this.next = () => {\n\n            this.maxPage = this.maxPage + this.config.pages;\n\n            this.find();\n\n        };\n\n        /**\n         * @private\n         */\n        this.find = () => {\n\n            this.page((response) => {\n\n                if (!this.config.reverse) {\n                    response.messages.reverse();\n                }\n\n                eachSeries(response.messages, this.triggerHistory, () => {\n\n                    if (this.numPage === this.maxPage) {\n                        this._emit('$.search.pause');\n                    } else if (\n                        response.messages &&\n                        response.messages.length === this.config.count &&\n                        this.needleCount < this.config.limit) {\n                        this.numPage += 1;\n                        this.find();\n                    } else {\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        this._emit('$.search.finish');\n                    }\n\n                });\n\n            });\n\n            return this;\n\n        };\n\n        if (this.config.event) {\n            this.plugin(eventFilter(this.config.event));\n        }\n\n        if (this.config.sender) {\n            this.plugin(senderFilter(this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        this._emit('$.search.start');\n        this.find();\n\n    }\n\n}\n\nmodule.exports = Search;\n"},{"id":88,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":87,"index2":86,"size":4922,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":10,"building":48,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\n\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid, authData) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.name = 'Me';\n\n        this.authData = authData;\n        this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        this.session = {};\n\n        this.sync = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'me.', 'sync'].join('#'), false, true, {}, 'system');\n\n        this.sync.on('$.session.chat.join', (payload) => {\n            this.addChatToSession(payload.data.subject);\n        });\n\n        this.sync.on('$.session.chat.leave', (payload) => {\n            this.removeChatFromSession(payload.data.subject);\n        });\n\n        return this;\n\n    }\n\n    /**\n     * assign updates from network\n     * @private\n     */\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state) {\n\n        // run the root update function\n        super.update(state);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    addChatToSession(chat) {\n\n        // create the chat group if it doesn't exist\n        this.session[chat.group] = this.session[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = this.chatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n            // assign it to the group\n            this.session[chat.group][chat.channel] = existingChat;\n        } else {\n\n            // otherwise, try to recreate it with the server information\n            this.session[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n            /**\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n            @event Me#$\".\"session\".\"chat\".\"join\n            @example\n            *\n            * // Logged in as \"Ian\" in first window\n            * ChatEngine.me.on('$.session.chat.join', (data) => {\n            *     console.log('I joined a new chat in a second window!', data.chat);\n            * });\n            *\n            * // Logged in as \"Ian\" in second window\n            * new ChatEngine.Chat('another-chat');\n            */\n            // this.trigger('$.session.chat.join', {\n            //     chat: this.session[chat.group][chat.channel]\n            // });\n            //\n            this.trigger('$.session.chat.join', { chat: this.session[chat.group][chat.channel] });\n\n        }\n\n    }\n\n    /**\n    Removes {@link Chat} within this.session\n    @private\n    */\n    removeChatFromSession(chat) {\n\n        if (this.session[chat.group] && this.session[chat.group][chat.channel]) {\n\n            chat = this.session[chat.group][chat.channel] || chat;\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n            * @event Me#$\".\"session\".\"chat\".\"leave\n            */\n\n            delete this.chatEngine.chats[chat.channel];\n            delete this.session[chat.group][chat.channel];\n\n            this.trigger('$.session.chat.leave', { chat });\n\n        }\n\n    }\n\n}\n\nmodule.exports = Me;\n"}],"filteredModules":77,"origins":[{"moduleId":30,"module":"/Users/ian/Development/chat-engine/src/index.js","moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":3,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":37,"index2":31,"size":488,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":33},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":27,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/setimmediate/setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"},{"id":4,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":38,"index2":34,"size":495,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":32},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":74,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":80,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"},{"id":5,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":39,"index2":48,"size":7474,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":28,"building":17,"dependencies":4},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":60,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\nconst RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        this._dataset = {};\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data = {}) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data, this);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n            return this;\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n            return this;\n\n        };\n\n    }\n\n    // add an object as a subobject under a namespoace\n    addChild(childName, childOb) {\n        // assign the new child object as a property of parent under the\n        // given namespace\n        this[childName] = childOb;\n\n        // assign a data set for the namespace if it doesn't exist\n        if (!this._dataset[childName]) {\n            this._dataset[childName] = {};\n        }\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = this;\n\n        // bind get() and set() to the data set\n        childOb.get = this.get.bind(this._dataset[childName]);\n        childOb.set = this.set.bind(this._dataset[childName]);\n    }\n\n    get(key) {\n        return this[key];\n    }\n\n    set(key, value) {\n        if (this[key] && !value) {\n            delete this[key];\n        } else {\n            this[key] = value;\n        }\n    }\n\n    /**\n     Binds a plugin to this object\n     @param {Object} module The plugin module\n     @tutorial using\n     */\n    plugin(module) {\n\n        // add this plugin to a list of plugins for this object\n        this.plugins.push(module);\n\n        // see if there are plugins to attach to this class\n        if (module.extends && module.extends[this.name]) {\n            // attach the plugins to this class\n            // under their namespace\n            this.addChild(module.namespace, new module.extends[this.name]());\n\n            this[module.namespace].ChatEngine = this.chatEngine;\n\n            // if the plugin has a special construct function\n            // run it\n            if (this[module.namespace].construct) {\n                this[module.namespace].construct();\n            }\n\n        }\n\n        return this;\n\n    }\n\n    bindProtoPlugins() {\n\n        if (this.chatEngine.protoPlugins[this.name]) {\n\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\n                this.plugin(module);\n            });\n\n        }\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n    trigger(event, payload = {}, done = () => {}) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (reject, pluginResponse) => {\n\n                if (reject) {\n                    done(reject);\n                } else {\n                    // emit this event to any listener\n                    this._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // the user doesn't exist, create it\n                payload.sender = new this.chatEngine.User(payload.sender);\n\n                payload.sender._getState(() => {\n                    complete();\n                });\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                if (pluginItem.middleware[location][event]) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location][event]);\n                }\n\n                if (pluginItem.middleware[location]['*']) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\n                }\n\n            }\n\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    onConstructed() {\n\n        this.bindProtoPlugins();\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":14,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4109,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":9,"building":9},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        this.name = 'RootEmitter';\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.on(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.off(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.onAny(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.once(event, callback);\n\n            return this;\n\n        };\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":23,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":51,"index2":47,"size":2220,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":28,"building":10},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\n * @class Event\n * Represents an event that may be emitted or subscribed to.\n */\nclass Event {\n\n    constructor(chatEngine, chat, event) {\n\n        /**\n         Events are always a property of a {@link Chat}. Responsible for\n         listening to specific events and firing events when they occur.\n         @readonly\n         @type String\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = chat.channel;\n\n        this.chatEngine = chatEngine;\n\n        this.chat = chat;\n\n        this.event = event;\n\n        this.name = 'Event';\n\n        /**\n         Forwards events to the Chat that registered the event {@link Chat}\n\n         @private\n         @param {Object} data The event payload object\n         */\n\n        // call onMessage when PubNub receives an event\n        this.chatEngine.pubnub.addListener({\n            message: this.onMessage.bind(this)\n        });\n\n        return this;\n\n    }\n\n    onMessage(m) {\n\n        if (this.channel === m.channel && m.message.event === this.event) {\n            this.chat.trigger(m.message.event, m.message);\n        }\n\n    }\n\n    /**\n     Publishes the event over the PubNub network to the {@link Event} channel\n\n     @private\n     @param {Object} data The event payload object\n     */\n    publish(m) {\n\n        m.event = this.event;\n\n        this.chatEngine.pubnub.publish({\n            message: m,\n            channel: this.channel\n        }, (status) => {\n\n            if (status.statusCode === 200) {\n\n                /**\n                 * Message successfully published\n                 * @event Chat#$\".\"publish\".\"success\n                 * @param {Object} data The message object\n                 */\n                this.chat.trigger('$.publish.success', m);\n            } else {\n\n                /**\n                 * There was a problem publishing over the PubNub network.\n                 * @event Chat#$\".\"error\".\"publish\n                 */\n                this.chatEngine.throwError(this.chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), status);\n            }\n\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":88,"index2":85,"size":5615,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":10,"building":43,"dependencies":19},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":88,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        this.state = {};\n\n        this._stateFetched = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n        return this;\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(callback) {\n\n        if (!this._stateFetched) {\n\n            this.chatEngine.pubnub.getState({\n                uuid: this.uuid,\n                channels: [this.chatEngine.global.channel]\n            }, (status, response) => {\n\n                if (status.statusCode === 200) {\n\n                    let pnState = response.channels[this.chatEngine.global.channel];\n                    if (Object.keys(pnState).length) {\n\n                        this.assign(response.data);\n\n                        this._stateFetched = true;\n                        callback(this.state);\n\n                    } else {\n\n                        this.chatEngine.request('get', 'user_state', {\n                            user: this.uuid\n                        })\n                            .then((res) => {\n\n                                this.assign(res.data);\n\n                                this._stateFetched = true;\n                                callback(this.state);\n\n                            })\n                            .catch((err) => {\n                                // console.log('this is hte err', err);\n                                this.chatEngine.throwError(this, 'trigger', 'getState', err);\n                            });\n\n                    }\n\n                } else {\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\n                }\n\n            });\n\n        } else {\n            callback(this.state);\n        }\n\n    }\n\n}\n\nmodule.exports = User;\n"},{"id":30,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":88,"size":1721,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":29,"building":19},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\nconst init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nmodule.exports = {\n    plugin: {}, // leave a spot for plugins to exist\n    create\n};\n"},{"id":31,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":87,"size":16148,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":30,"issuerName":"./src/index.js","profile":{"factory":4,"building":32},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\nconst pack = require('../package.json');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\nconst async = require('async');\n\n/**\n @class ChatEngine\n @extends RootEmitter\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\n */\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    ChatEngine.pnConfig.heartbeatInterval = ChatEngine.pnConfig.heartbeatInterval || 30;\n    ChatEngine.pnConfig.presenceTimeout = ChatEngine.pnConfig.presenceTimeout || 60;\n\n    ChatEngine.ceConfig.endpoint = ChatEngine.ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + ChatEngine.pnConfig.subscribeKey + '/chat-engine-server';\n    ChatEngine.ceConfig.globalChannel = ChatEngine.ceConfig.globalChannel || 'chat-engine-global';\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    if (ceConfig.debug) {\n        ChatEngine.onAny((event, payload) => {\n            console.info('debug:', event, payload);\n        });\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = (className, plugin) => {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\n\n        let body = {\n            uuid: pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authData: ChatEngine.me.authData,\n            authKey: pnConfig.authKey\n        };\n\n        let params = {\n            route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params });\n        }\n\n\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = (channel) => {\n\n        let info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\n\n        let channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @param {Object} [authData] Additional data to send to the authentication endpoint to help verify a valid session. ChatEngine SDK does not make use of this, but you might!\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        pnConfig.uuid = uuid;\n\n        pnConfig.authKey = authKey || pnConfig.uuid;\n\n        let restoreSession = () => {\n\n            let groups = ['custom', 'rooms', 'system'];\n\n            groups.forEach((group) => {\n\n                let channelGroup = [ceConfig.globalChannel, pnConfig.uuid, group].join('#');\n\n                ChatEngine.pubnub.channelGroups.listChannels({\n                    channelGroup\n                }, (status, response) => {\n\n                    if (status.error) {\n                        console.log('operation failed w/ error:', status);\n                        return;\n                    }\n\n                    response.channels.forEach((channel) => {\n\n                        ChatEngine.me.addChatToSession({\n                            channel,\n                            private: ChatEngine.parseChannel(channel).private,\n                            group\n                        });\n\n                    });\n\n                });\n\n            });\n\n        };\n\n        let complete = () => {\n\n            ChatEngine.pubnub = new PubNub(pnConfig);\n\n            // create a new chat to use as global chat\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\n            ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\n            ChatEngine.me.update(state);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            ChatEngine.global.on('$.connected', () => {\n\n                /**\n                 *  Fired when ChatEngine is connected to the internet and ready to go!\n                 * @event ChatEngine#$\".\"ready\n                 * @example\n                 * ChatEngine.on('$.ready', (data) => {\n                 *     let me = data.me;\n                 * })\n                 */\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.global.getUserUpdates();\n\n                let chanGroups = [\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\n                    ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\n                ];\n\n                // listen to all PubNub events for this Chat\n                ChatEngine.pubnub.addListener({\n                    presence: (payload) => {\n\n                        if (ChatEngine.chats[payload.channel]) {\n                            ChatEngine.chats[payload.channel].onPresence(payload);\n                        }\n\n                    }\n                });\n\n                ChatEngine.pubnub.subscribe({\n                    channelGroups: chanGroups,\n                    withPresence: true\n                });\n\n                ChatEngine.ready = true;\n\n                restoreSession();\n\n            });\n\n            /**\n             Fires when PubNub network connection changes.\n\n             @private\n             @param {Object} statusEvent The response status\n             */\n            ChatEngine.pubnub.addListener({\n                status: (statusEvent) => {\n\n                    /**\n                     * SDK detected that network is online.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\n                     */\n\n                    /**\n                     * SDK detected that network is down.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                     */\n\n                    /**\n                     * A subscribe event experienced an exception when running.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                     */\n\n                    /**\n                     * SDK was able to reconnect to pubnub.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                     */\n\n                    /**\n                     * SDK subscribed with a new mix of channels.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                     */\n\n                    /**\n                     * JSON parsing crashed.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                     */\n\n                    /**\n                     * Server rejected the request.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                     */\n\n                    /**\n                     * If using decryption strategies and the decryption fails.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                     */\n\n                    /**\n                     * Request timed out.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                     */\n\n                    /**\n                     * PAM permission failure.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                     */\n\n                    // map the pubnub events into ChatEngine events\n                    let categories = {\n                        PNNetworkUpCategory: 'up.online',\n                        PNNetworkDownCategory: 'down.offline',\n                        PNNetworkIssuesCategory: 'down.issue',\n                        PNReconnectedCategory: 'up.reconnected',\n                        PNConnectedCategory: 'up.connected',\n                        PNAccessDeniedCategory: 'down.denied',\n                        PNMalformedResponseCategory: 'down.malformed',\n                        PNBadRequestCategory: 'down.badrequest',\n                        PNDecryptionErrorCategory: 'down.decryption',\n                        PNTimeoutCategory: 'down.timeout'\n                    };\n\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                    if (statusEvent.affectedChannels) {\n                        statusEvent.affectedChannels.forEach((channel) => {\n\n                            let chat = ChatEngine.chats[channel];\n\n                            if (chat) {\n                                // connected category tells us the chat is ready\n                                if (statusEvent.category === 'PNConnectedCategory') {\n                                    chat.onConnectionReady();\n                                }\n\n                                // trigger the network events\n                                chat.trigger(eventName, statusEvent);\n\n                            } else {\n                                ChatEngine._emit(eventName, statusEvent);\n                            }\n                        });\n                    } else {\n                        ChatEngine._emit(eventName, statusEvent);\n                    }\n                }\n            });\n        };\n\n        async.parallel([\n            (next) => {\n                ChatEngine.request('post', 'bootstrap').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_read').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_write').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'group').then(complete).catch(next);\n            }\n        ], (error) => {\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\n            }\n        });\n\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function (...args) {\n\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            let newChat = new Chat(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n\n        }\n\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function (...args) {\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            let newUser = new User(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n\n        }\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":52,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1345,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":75,"building":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.8.4\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^4.1.2\",\"pubnub\":\"^4.17.0\"}}"},{"id":54,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":84,"size":21806,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":9,"building":35,"dependencies":29},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst Search = require('../components/search');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Chat';\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        this.meta = meta || {};\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly granted access.\n        * @type Boolean\n        * @see  {@tutorial privacy}\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        this.chatEngine.chats[this.channel] = this;\n\n        if (autoConnect) {\n            this.connect();\n        }\n\n        return this;\n\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n\n     @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n    onHereNow(status, response) {\n\n        if (status.error) {\n\n            /**\n             * There was a problem fetching the presence of this chat\n             * @event Chat#$\".\"error\".\"presence\n             */\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), status);\n\n        } else {\n\n            // get the list of occupants in this channel\n            let occupants = response.channels[this.channel].occupants;\n\n            // format the userList for rltm.js standard\n            occupants.forEach((occupant) => {\n                this.userUpdate(occupant.uuid, occupant.state);\n            });\n\n        }\n\n    }\n\n    /**\n    * Turns a {@link Chat} into a JSON representation.\n    * @return {Object}\n    */\n    objectify() {\n\n        return {\n            channel: this.channel,\n            group: this.group,\n            private: this.isPrivate,\n            meta: this.meta\n        };\n\n    }\n\n    /**\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n     * @param {User} user The {@link User} to invite to this chatroom.\n     * @fires Me#event:$\".\"invite\n     * @example\n     * // one user running ChatEngine\n     * let secretChat = new ChatEngine.Chat('secret-channel');\n     * secretChat.invite(someoneElse);\n     *\n     * // someoneElse in another instance of ChatEngine\n     * me.direct.on('$.invite', (payload) => {\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n     * });\n     */\n    invite(user) {\n\n        this.chatEngine.request('post', 'invite', {\n            to: user.uuid,\n            chat: this.objectify()\n        })\n            .then(() => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n            });\n\n    }\n\n    /**\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n     @private\n     @param {Object} data The PubNub presence response for this event\n     */\n    onPresence(presenceEvent) {\n\n        // make sure channel matches this channel\n\n        // someone joins channel\n        if (presenceEvent.action === 'join') {\n\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n            /**\n             * Fired when a {@link User} has joined the room.\n             *\n             * @event Chat#$\".\"online\".\"join\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.join', (data) => {\n                          *     console.log('User has joined the room!', data.user);\n                          * });\n             */\n\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\n            // Avoid firing duplicate $.online events.\n            if (!this.users[user.uuid]) {\n                this.trigger('$.online.join', { user });\n            }\n\n        }\n\n        // someone leaves channel\n        if (presenceEvent.action === 'leave') {\n            this.userLeave(presenceEvent.uuid);\n        }\n\n        // someone timesout\n        if (presenceEvent.action === 'timeout') {\n            this.userDisconnect(presenceEvent.uuid);\n        }\n\n        // someone's state is updated\n        if (presenceEvent.action === 'state-change') {\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n        }\n\n\n    }\n\n    /**\n     * Update the {@link Chat} metadata on the server.\n     * @param  {object} data JSON object representing chat metadta.\n     */\n    update(data) {\n\n        let oldMeta = this.meta || {};\n        this.meta = Object.assign(oldMeta, data);\n\n        this.chatEngine.request('post', 'chat', {\n            chat: this.objectify()\n        }).then(() => {\n        }).catch((error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n      * });\n     */\n    emit(event, data) {\n        if (event === 'message' && typeof data !== 'object') {\n            throw new Error('the payload has to be an object');\n        }\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n            event,\n            chatengineSDK: this.chatEngine.package.version\n        };\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n\n            // ensure the event exists within the global space\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            this.events[event].publish(pluginResponse);\n\n        });\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n        this.chatEngine.users[uuid].assign(state);\n\n        // trigger the join event over this chatroom\n        if (!this.users[uuid]) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // store this user in the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n     * receiving events.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\n            .then(() => {\n\n                this.connected = false;\n\n                this.trigger('$.disconnected');\n\n                this.chatEngine.me.sync.emit('$.session.chat.leave', { subject: this.objectify() });\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', {\n                user: this.users[uuid]\n            });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        } else {\n\n            // that user isn't in the user list\n            // we never knew about this user or they already left\n\n            // console.log('user already left');\n        }\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n                      *     console.log('User disconnected from the network:', data.user);\n                      * });\n             */\n\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\n        }\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    /**\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n     which will emit all old events unless ```config.event``` is supplied.\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n     @param {Event} [config.event] The {@link Event} to search for.\n     @param {User} [config.sender] The {@link User} who sent the message.\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history.\n     @param {Number} [config.start=0] The timetoken to begin searching between.\n     @param {Number} [config.end=0] The timetoken to end searching between.\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\n     @return {Search}\n     @example\n    chat.search({\n        event: 'my-custom-event',\n        sender: ChatEngine.me,\n        limit: 20\n    }).on('my-custom-event', (event) => {\n        console.log('this is an old event!', event);\n    }).on('$.search.finish', () => {\n        console.log('we have all our results!')\n    });\n     */\n    search(config) {\n        return new Search(this.chatEngine, this, config);\n    }\n\n    /**\n     * @private\n     */\n    onConnectionReady() {\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n         *     console.log('chat is ready to go!');\n         * });\n         */\n        this.trigger('$.connected');\n\n        this.chatEngine.me.sync.emit('$.session.chat.join', { subject: this.objectify() });\n\n        this.connected = true;\n\n        // add self to list of users\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n        // trigger my own online event\n        this.trigger('$.online.join', {\n            user: this.chatEngine.me\n        });\n\n        // global channel updates are triggered manually, only get presence on custom chats\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n            this.getUserUpdates();\n\n            // we may miss updates, so call this again 5 seconds later\n            setTimeout(() => {\n                this.getUserUpdates();\n            }, 5000);\n\n        }\n\n    }\n\n    getUserUpdates() {\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, this.onHereNow.bind(this));\n\n    }\n\n    /**\n     * Connect to PubNub servers to initialize the chat.\n     * @example\n     * // create a new chatroom, but don't connect to it automatically\n     * let chat = new Chat('some-chat', false)\n     *\n     * // connect to the chat when we feel like it\n     * chat.connect();\n     */\n    connect() {\n\n        async.waterfall([\n            (next) => {\n                if (!this.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\n                    .then((response) => {\n\n                        if (response.data.found) {\n                            this.meta = response.data.chat.meta;\n                        } else {\n                            this.update(this.meta);\n                        }\n\n                        this.onConnectionReady();\n\n                    })\n                    .catch(next);\n\n            }\n        ], (error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":60,"identifier":"/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":52,"index2":83,"size":6914,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":54,"issuerName":"./src/components/chat.js","profile":{"factory":29,"building":25,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\nconst eachSeries = require('async/eachSeries');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\nclass Search extends Emitter {\n\n    constructor(chatEngine, chat, config = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        this.chat = chat;\n\n        // slice() operation clones the array and returns the reference to the new array.\n        this.plugins = this.chat.plugins.slice();\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        this.config = config;\n        this.config.event = config.event;\n        this.config.limit = config.limit || 20;\n        this.config.channel = this.chat.channel;\n        this.config.includeTimetoken = true;\n        this.config.stringifiedTimeToken = true;\n        this.config.count = this.config.count || 100;\n\n        this.config.pages = this.config.pages || 10;\n\n        this.needleCount = 0;\n\n        this.firstTT = 0;\n        this.lastTT = 0;\n\n        this.firstPage = true;\n\n        /**\n        * @private\n        */\n        this.sortHistory = (messages, desc) => {\n\n            messages.sort((a, b) => {\n                let e1 = desc ? b : a;\n                let e2 = desc ? a : b;\n                return parseInt(e1.timetoken, 10) - parseInt(e2.timetoken, 10);\n            });\n\n            return messages;\n\n        };\n\n        /**\n         * Call PubNub history in a loop.\n         * Unapologetically stolen from https://www.pubnub.com/docs/web-javascript/storage-and-history\n         * @private\n         */\n        this.page = (pageDone) => {\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            this._emit('$.search.page.request');\n\n            // only set start if this is the first call and the user hasn't set it themselves\n            this.config.start = this.config.reverse ? this.lastTT : this.firstTT;\n\n            this.firstPage = false;\n\n            this.chatEngine.pubnub.history(this.config, (status, response) => {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n\n                } else {\n\n                    // timetoken of the first message in response\n                    this.firstTT = response.startTimeToken;\n                    // timetoken of the last message in response\n                    this.lastTT = response.endTimeToken;\n\n                    response.messages = this.sortHistory(response.messages);\n\n                    pageDone(response);\n\n                }\n\n            });\n        };\n\n        let eventFilter = (event) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n                            let matches = payload && payload.event && payload.event === event;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        let senderFilter = (user) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        this.needleCount = 0;\n\n        /**\n         * @private\n         */\n        this.triggerHistory = (message, cb) => {\n\n            if (this.needleCount < this.config.limit) {\n\n                this.trigger(message.entry.event, message.entry, (reject) => {\n\n                    if (!reject) {\n                        this.needleCount += 1;\n                    }\n                    cb();\n\n                });\n\n            } else {\n                cb();\n            }\n\n        };\n\n        this.maxPage = 10;\n        this.numPage = 0;\n\n        this.next = () => {\n\n            this.maxPage = this.maxPage + this.config.pages;\n\n            this.find();\n\n        };\n\n        /**\n         * @private\n         */\n        this.find = () => {\n\n            this.page((response) => {\n\n                if (!this.config.reverse) {\n                    response.messages.reverse();\n                }\n\n                eachSeries(response.messages, this.triggerHistory, () => {\n\n                    if (this.numPage === this.maxPage) {\n                        this._emit('$.search.pause');\n                    } else if (\n                        response.messages &&\n                        response.messages.length === this.config.count &&\n                        this.needleCount < this.config.limit) {\n                        this.numPage += 1;\n                        this.find();\n                    } else {\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        this._emit('$.search.finish');\n                    }\n\n                });\n\n            });\n\n            return this;\n\n        };\n\n        if (this.config.event) {\n            this.plugin(eventFilter(this.config.event));\n        }\n\n        if (this.config.sender) {\n            this.plugin(senderFilter(this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        this._emit('$.search.start');\n        this.find();\n\n    }\n\n}\n\nmodule.exports = Search;\n"},{"id":88,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":87,"index2":86,"size":4922,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":31,"issuerName":"./src/bootstrap.js","profile":{"factory":10,"building":48,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":31,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\n\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid, authData) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.name = 'Me';\n\n        this.authData = authData;\n        this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        this.session = {};\n\n        this.sync = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'me.', 'sync'].join('#'), false, true, {}, 'system');\n\n        this.sync.on('$.session.chat.join', (payload) => {\n            this.addChatToSession(payload.data.subject);\n        });\n\n        this.sync.on('$.session.chat.leave', (payload) => {\n            this.removeChatFromSession(payload.data.subject);\n        });\n\n        return this;\n\n    }\n\n    /**\n     * assign updates from network\n     * @private\n     */\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state) {\n\n        // run the root update function\n        super.update(state);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    addChatToSession(chat) {\n\n        // create the chat group if it doesn't exist\n        this.session[chat.group] = this.session[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = this.chatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n            // assign it to the group\n            this.session[chat.group][chat.channel] = existingChat;\n        } else {\n\n            // otherwise, try to recreate it with the server information\n            this.session[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n            /**\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n            @event Me#$\".\"session\".\"chat\".\"join\n            @example\n            *\n            * // Logged in as \"Ian\" in first window\n            * ChatEngine.me.on('$.session.chat.join', (data) => {\n            *     console.log('I joined a new chat in a second window!', data.chat);\n            * });\n            *\n            * // Logged in as \"Ian\" in second window\n            * new ChatEngine.Chat('another-chat');\n            */\n            // this.trigger('$.session.chat.join', {\n            //     chat: this.session[chat.group][chat.channel]\n            // });\n            //\n            this.trigger('$.session.chat.join', { chat: this.session[chat.group][chat.channel] });\n\n        }\n\n    }\n\n    /**\n    Removes {@link Chat} within this.session\n    @private\n    */\n    removeChatFromSession(chat) {\n\n        if (this.session[chat.group] && this.session[chat.group][chat.channel]) {\n\n            chat = this.session[chat.group][chat.channel] || chat;\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n            * @event Me#$\".\"session\".\"chat\".\"leave\n            */\n\n            delete this.chatEngine.chats[chat.channel];\n            delete this.session[chat.group][chat.channel];\n\n            this.trigger('$.session.chat.leave', { chat });\n\n        }\n\n    }\n\n}\n\nmodule.exports = Me;\n"}],"filteredModules":77,"children":[]}