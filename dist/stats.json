{"errors":[],"warnings":[],"version":"3.11.0","hash":"deb11ab4c0aff057b502","publicPath":"","assetsByChunkName":{"main":"chat-engine.js"},"assets":[{"name":"chat-engine.js","size":477579,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"filteredAssets":0,"entrypoints":{"main":{"chunks":[0],"assets":["chat-engine.js"]}},"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":466470,"names":["main"],"files":["chat-engine.js"],"hash":"711f4f313515821e1236","parents":[],"modules":[{"id":2,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":35,"index2":31,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":42},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":22,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/timers-browserify/main.js","module":"./node_modules/timers-browserify/main.js","moduleName":"./node_modules/timers-browserify/main.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/setimmediate/setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":3,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":39,"index2":65,"size":7474,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":26,"building":21,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":28,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":73,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/session.js","module":"./src/components/session.js","moduleName":"./src/components/session.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\nconst RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        this._dataset = {};\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data = {}) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data, this);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n            return this;\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n            return this;\n\n        };\n\n    }\n\n    // add an object as a subobject under a namespoace\n    addChild(childName, childOb) {\n        // assign the new child object as a property of parent under the\n        // given namespace\n        this[childName] = childOb;\n\n        // assign a data set for the namespace if it doesn't exist\n        if (!this._dataset[childName]) {\n            this._dataset[childName] = {};\n        }\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = this;\n\n        // bind get() and set() to the data set\n        childOb.get = this.get.bind(this._dataset[childName]);\n        childOb.set = this.set.bind(this._dataset[childName]);\n    }\n\n    get(key) {\n        return this[key];\n    }\n\n    set(key, value) {\n        if (this[key] && !value) {\n            delete this[key];\n        } else {\n            this[key] = value;\n        }\n    }\n\n    /**\n     Binds a plugin to this object\n     @param {Object} module The plugin module\n     @tutorial using\n     */\n    plugin(module) {\n\n        // add this plugin to a list of plugins for this object\n        this.plugins.push(module);\n\n        // see if there are plugins to attach to this class\n        if (module.extends && module.extends[this.name]) {\n            // attach the plugins to this class\n            // under their namespace\n            this.addChild(module.namespace, new module.extends[this.name]());\n\n            this[module.namespace].ChatEngine = this.chatEngine;\n\n            // if the plugin has a special construct function\n            // run it\n            if (this[module.namespace].construct) {\n                this[module.namespace].construct();\n            }\n\n        }\n\n        return this;\n\n    }\n\n    bindProtoPlugins() {\n\n        if (this.chatEngine.protoPlugins[this.name]) {\n\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\n                this.plugin(module);\n            });\n\n        }\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n    trigger(event, payload = {}, done = () => {}) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (reject, pluginResponse) => {\n\n                if (reject) {\n                    done(reject);\n                } else {\n                    // emit this event to any listener\n                    this._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // the user doesn't exist, create it\n                payload.sender = new this.chatEngine.User(payload.sender);\n\n                payload.sender._getState(() => {\n                    complete();\n                });\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                if (pluginItem.middleware[location][event]) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location][event]);\n                }\n\n                if (pluginItem.middleware[location]['*']) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\n                }\n\n            }\n\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    onConstructed() {\n\n        this.bindProtoPlugins();\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":5,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4109,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":13},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":25,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/event.js","module":"./src/components/event.js","moduleName":"./src/components/event.js","type":"cjs require","userRequest":"../modules/root_emitter","loc":"1:16-50"},{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        this.name = 'RootEmitter';\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.on(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.off(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.onAny(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.once(event, callback);\n\n            return this;\n\n        };\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":6,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":36,"index2":32,"size":517,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":43},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":84,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":90,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n"},{"id":25,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":68,"index2":64,"size":2376,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":26,"building":24,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/root_emitter');\n\n/**\n * @class Event\n * Represents an {@link Chat} event.\n * @fires $\".\"emitted\n * @extends Emitter\n * @extends RootEmitter\n */\nclass Event extends Emitter {\n\n    constructor(chatEngine, chat, event) {\n\n        super();\n\n        /**\n         * @private\n         */\n        this.chatEngine = chatEngine;\n\n        /**\n         * The {@link Chat#channel} that this event is registered to.\n         * @type String\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         * @readonly\n         */\n        this.channel = chat.channel;\n\n        /**\n         * Events are always a property of a {@link Chat}. Responsible for\n         * listening to specific events and firing events when they occur.\n         * @readonly\n         * @type {Chat}\n         */\n        this.chat = chat;\n\n        /**\n         * The string representation of the event. This is supplied as the first parameter to {@link Chat#on}\n         * @type {String}\n         */\n        this.event = event;\n\n        /**\n         * A name that identifies this class\n         * @type {String}\n         */\n        this.name = 'Event';\n\n        return this;\n\n    }\n\n    /**\n     Publishes the event over the PubNub network to the {@link Event} channel\n\n     @private\n     @param {Object} data The event payload object\n     */\n    publish(m) {\n\n        m.event = this.event;\n\n        this.chatEngine.pubnub.publish({\n            message: m,\n            channel: this.channel\n        }, (status, response) => {\n\n            if (status.statusCode === 200) {\n\n                if (response) {\n                    m.timetoken = response.timetoken;\n                }\n\n                /**\n                 * Message successfully published\n                 * @event Event#$\".\"emitted\"\n                 * @param {Object} data The message payload\n                 */\n                this._emit('$.emitted', m);\n\n            } else {\n\n                /**\n                 * There was a problem publishing over the PubNub network.\n                 * @event Chat#$\".\"error\".\"publish\n                 */\n                this.chatEngine.throwError(this, '_emit', 'emitter', new Error('There was a problem publishing over the PubNub network.'), status);\n            }\n\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n\n"},{"id":28,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":98,"index2":95,"size":5575,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":58,"dependencies":12},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":98,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        this.state = {};\n\n        this._stateFetched = false;\n\n        this._stateInProgress = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n        return this;\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(callback) {\n\n        if (!this._stateFetched && !this._stateInProgress) {\n\n            this._stateInProgress = true;\n\n            this.chatEngine.pubnub.getState({\n                uuid: this.uuid,\n                channels: [this.chatEngine.global.channel]\n            }, (status, response) => {\n\n                if (status.statusCode === 200) {\n\n                    let pnState = response.channels[this.chatEngine.global.channel];\n                    if (Object.keys(pnState).length) {\n\n                        this.assign(response.data);\n                        this._stateFetched = true;\n                        callback(this.state);\n\n                    } else {\n\n                        this.chatEngine.request('get', 'user_state', {\n                            user: this.uuid\n                        }).then((res) => {\n\n                            this.assign(res.data);\n                            this._stateFetched = true;\n                            callback(this.state);\n\n                        }).catch((err) => {\n                            this.chatEngine.throwError(this, 'trigger', 'getState', err);\n                        });\n\n                    }\n\n                } else {\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting user state from the PubNub network.'));\n                }\n\n            });\n\n        } else {\n            callback(this.state);\n        }\n\n    }\n\n\n}\n\nmodule.exports = User;\n"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":99,"size":2371,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":16,"building":22},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"const init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.enableSync] {Boolean} Synchronizes chats between instances with the same {@link Me#uuid}. See {@link Me#sync}.\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    if (typeof ceConfig.enableSync === 'undefined') {\n        ceConfig.enableSync = false;\n    }\n\n    ceConfig.endpoint = ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + pnConfig.subscribeKey + '/chat-engine-server';\n\n    pnConfig.heartbeatInterval = pnConfig.heartbeatInterval || 30;\n    pnConfig.presenceTimeout = pnConfig.presenceTimeout || 60;\n\n    pnConfig.keepAlive = true;\n    pnConfig.keepAliveSettings = {\n        keepAlive: true,\n        timeout: 5 * 1000 * 60\n    };\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nconst ChatEngineCore = {\n    plugin: {},\n    create: create\n};\n\nmodule.exports = ChatEngineCore;\n\nmodule.exports.ChatEngineCore = ChatEngineCore;\n"},{"id":30,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":98,"size":18690,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":29,"issuerName":"./src/index.js","profile":{"factory":3,"building":42},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"1:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\nconst pack = require('../package.json');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\nconst async = require('async');\n\n/**\n@class ChatEngine\n@extends RootEmitter\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n*/\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    let countObject = {};\n\n    if (ceConfig.debug) {\n\n        ChatEngine.onAny((event, payload) => {\n\n            console.info('debug:', event, payload);\n\n            countObject['event: ' + event] = countObject[event] || 0;\n            countObject['event: ' + event] += 1;\n\n        });\n\n    }\n\n    if (ceConfig.profiling) {\n\n        setInterval(() => {\n\n            countObject.chats = Object.keys(ChatEngine.chats).length;\n            countObject.users = Object.keys(ChatEngine.users).length;\n\n            console.table(countObject);\n\n        }, 3000);\n\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = (className, plugin) => {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\n\n        let body = {\n            uuid: ChatEngine.pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authKey: ChatEngine.pnConfig.authKey\n        };\n\n        let params = {\n            route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params });\n        }\n\n\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = (channel) => {\n\n        let info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\n\n        let channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n\n    };\n\n    /**\n     * Initial communication with the server. Server grants permissions to\n     * talk in chats, etc.\n     * @private\n     */\n    ChatEngine.handshake = (complete) => {\n\n        async.series([\n            (next) => {\n                ChatEngine.request('post', 'bootstrap').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_read').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_write').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'group').then(complete).catch(next);\n            }\n        ], (error) => {\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').' + error && error.response && error.response.data), { error });\n            }\n        });\n\n    };\n\n    /**\n     * @private\n     * Listen to PubNub events and forward them into ChatEngine system.\n     */\n    ChatEngine.listenToPubNub = () => {\n\n        /**\n         Fires when PubNub network connection changes.\n\n         @private\n         @param {Object} statusEvent The response status\n         */\n        ChatEngine.pubnub.addListener({\n            message: (m) => {\n\n                // assign the message timetoken as a property of the payload\n                m.message.timetoken = m.timetoken;\n\n                if (ChatEngine.chats[m.channel]) {\n                    ChatEngine.chats[m.channel].trigger(m.message.event, m.message);\n                }\n\n            },\n            presence: (payload) => {\n\n                if (ChatEngine.chats[payload.channel]) {\n                    ChatEngine.chats[payload.channel].onPresence(payload);\n                }\n\n            },\n            status: (statusEvent) => {\n\n                /**\n                 * SDK detected that network is online.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"online\n                 */\n\n                /**\n                 * SDK detected that network is down.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                 */\n\n                /**\n                 * A subscribe event experienced an exception when running.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                 */\n\n                /**\n                 * SDK was able to reconnect to pubnub.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                 */\n\n                /**\n                 * SDK subscribed with a new mix of channels.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                 */\n\n                /**\n                 * JSON parsing crashed.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                 */\n\n                /**\n                 * Server rejected the request.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                 */\n\n                /**\n                 * If using decryption strategies and the decryption fails.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                 */\n\n                /**\n                 * Request timed out.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                 */\n\n                /**\n                 * PAM permission failure.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                 */\n\n                // map the pubnub events into ChatEngine events\n                let categories = {\n                    PNNetworkUpCategory: 'up.online',\n                    PNNetworkDownCategory: 'down.offline',\n                    PNNetworkIssuesCategory: 'down.issue',\n                    PNReconnectedCategory: 'up.reconnected',\n                    PNConnectedCategory: 'up.connected',\n                    PNAccessDeniedCategory: 'down.denied',\n                    PNMalformedResponseCategory: 'down.malformed',\n                    PNBadRequestCategory: 'down.badrequest',\n                    PNDecryptionErrorCategory: 'down.decryption',\n                    PNTimeoutCategory: 'down.timeout'\n                };\n\n                let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                if (statusEvent.affectedChannels) {\n                    statusEvent.affectedChannels.forEach((channel) => {\n\n                        let chat = ChatEngine.chats[channel];\n\n                        if (chat) {\n                            // connected category tells us the chat is ready\n                            if (statusEvent.category === 'PNConnectedCategory') {\n                                chat.connectionReady();\n                            }\n\n                            // trigger the network events\n                            chat.trigger(eventName, statusEvent);\n\n                        } else {\n                            ChatEngine._emit(eventName, statusEvent);\n                        }\n                    });\n                } else {\n                    ChatEngine._emit(eventName, statusEvent);\n                }\n            }\n        });\n\n    };\n\n    /**\n     * @private\n     * Subscribe to PubNub and begin receiving events.\n     */\n    ChatEngine.subscribeToPubNub = () => {\n\n        let chanGroups = [\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\n        ];\n\n        ChatEngine.pubnub.subscribe({\n            channelGroups: chanGroups,\n            withPresence: true\n        });\n\n    };\n\n    /**\n     * Initialize ChatEngine modules on first time boot.\n     * @private\n     */\n    ChatEngine.firstConnect = (state) => {\n\n        ChatEngine.pubnub = new PubNub(ChatEngine.pnConfig);\n\n        // create a new chat to use as global chat\n        // we don't do auth on this one because it's assumed to be done with the /auth request below\n        ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n        ChatEngine.global.once('$.connected', () => {\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, ChatEngine.pnConfig.uuid);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            if (ChatEngine.ceConfig.enableSync) {\n                ChatEngine.me.session.subscribe();\n                ChatEngine.me.session.restore();\n            }\n\n            ChatEngine.me.update(state);\n\n            /**\n             *  Fired when ChatEngine is connected to the internet and ready to go!\n             * @event ChatEngine#$\".\"ready\n             * @example\n             * ChatEngine.on('$.ready', (data) => {\n             *     let me = data.me;\n             * })\n             */\n\n            ChatEngine._emit('$.ready', {\n                me: ChatEngine.me\n            });\n\n            ChatEngine.ready = true;\n\n            ChatEngine.listenToPubNub();\n            ChatEngine.subscribeToPubNub();\n\n            ChatEngine.global.getUserUpdates();\n\n        });\n\n    };\n\n    /**\n     * Disconnect from all {@link Chat}s and mark them as asleep.\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // every individual chat will be disconnected\n     * chat.on('$.disconnected', () => {\n     *     done();\n     * });\n     *\n     * // Changing User:\n     * ChatEngine.disconnect()\n     * ChatEngine = new ChatEngine({}, {});\n     * ChatEngine.connect()\n     */\n    ChatEngine.disconnect = () => {\n\n        // Unsubscribe from all PubNub chats\n        ChatEngine.pubnub.unsubscribeAll();\n\n        // for every chat in ChatEngine.chats, signal disconnected\n        Object.keys(ChatEngine.chats).forEach((key) => {\n            ChatEngine.chats[key].sleep();\n        });\n\n    };\n\n    /**\n     * Performs authentication with server and restores connection\n     * to all sleeping chats.\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // reconnect sometime later\n     * ChatEngine.reconnect();\n     *\n     */\n    ChatEngine.reconnect = () => {\n\n        // do the whole auth flow with the new authKey\n        ChatEngine.handshake(() => {\n\n            // for every chat in ChatEngine.chats, call .connect()\n            Object.keys(ChatEngine.chats).forEach((key) => {\n                ChatEngine.chats[key].wake();\n            });\n\n            ChatEngine.subscribeToPubNub();\n\n        });\n\n    };\n\n    /**\n    @private\n    */\n    ChatEngine.setAuth = (authKey = PubNub.generateUUID()) => {\n\n        ChatEngine.pnConfig.authKey = authKey;\n        ChatEngine.pubnub.setAuthKey(authKey);\n\n    };\n\n    /**\n     * Disconnects, changes authentication token, performs handshake with server\n     * and reconnects with new auth key. Used for extending logged in sessions\n     * for active users.\n     * @example\n     * // early\n     * ChatEngine.connect(...);\n     *\n     * ChatEngine.once('$.connected', () => {\n     *     // first connection established\n     * });\n     *\n     * // some time passes, session token expires\n     * ChatEngine.reauthorize(authKey);\n     *\n     * // we are connected again\n     * ChatEngine.once('$.connected', () => {\n     *     // we are connected again\n     * });\n     */\n    ChatEngine.reauthorize = (authKey = PubNub.generateUUID()) => {\n\n        ChatEngine.global.once('$.disconnected', () => {\n\n            ChatEngine.setAuth(authKey);\n            ChatEngine.reconnect();\n\n        });\n\n        ChatEngine.disconnect();\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = PubNub.generateUUID()) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        ChatEngine.pnConfig.uuid = uuid;\n        ChatEngine.pnConfig.authKey = authKey;\n\n        ChatEngine.handshake(() => {\n            ChatEngine.firstConnect(state);\n        });\n\n    };\n\n    ChatEngine.destroy = () => {\n\n        Object.keys(ChatEngine.chats).forEach((chat) => {\n            ChatEngine.chats[chat].emitter.removeAllListeners();\n        });\n\n        Object.keys(ChatEngine.users).forEach((user) => {\n            ChatEngine.users[user].emitter.removeAllListeners();\n        });\n\n        ChatEngine.emitter.removeAllListeners();\n\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function (...args) {\n\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            let newChat = new Chat(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n\n        }\n\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function (...args) {\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            let newUser = new User(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n\n        }\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":51,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1364,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":87,"building":4},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.9.5\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"decache\":\"^4.3.0\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^2.2.1\",\"pubnub\":\"^4.20.1\"}}"},{"id":53,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":94,"size":24298,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":44,"dependencies":27},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst Search = require('../components/search');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link Me.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Chat';\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        this.meta = meta || {};\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        /**\n         * Keep a record if we've every successfully connected to this chat before.\n         * @type {Boolean}\n         */\n        this.hasConnected = false;\n\n        /**\n         * If user manually disconnects via {@link ChatEngine#disconnect}, the\n         * chat is put to \"sleep\". If a connection is reestablished\n         * via {@link ChatEngine#reconnect}, sleeping chats reconnect automatically.\n         * @type {Boolean}\n         */\n        this.asleep = false;\n\n        this.chatEngine.chats[this.channel] = this;\n\n        if (autoConnect) {\n            this.connect();\n        }\n\n        return this;\n\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n\n     @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n    onHereNow(status, response) {\n\n        if (status.error) {\n\n            /**\n             * There was a problem fetching the presence of this chat\n             * @event Chat#$\".\"error\".\"presence\n             */\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'));\n\n        } else {\n\n            // get the list of occupants in this channel\n            let occupants = response.channels[this.channel].occupants;\n\n            // format the userList for rltm.js standard\n            occupants.forEach((occupant) => {\n                this.userUpdate(occupant.uuid, occupant.state);\n            });\n\n        }\n\n    }\n\n    /**\n    * Turns a {@link Chat} into a JSON representation.\n    * @return {Object}\n    */\n    objectify() {\n\n        return {\n            channel: this.channel,\n            group: this.group,\n            private: this.isPrivate,\n            meta: this.meta\n        };\n\n    }\n\n    /**\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n     * @param {User} user The {@link User} to invite to this chatroom.\n     * @fires Me#event:$\".\"invite\n     * @example\n     * // one user running ChatEngine\n     * let secretChat = new ChatEngine.Chat('secret-channel');\n     * secretChat.invite(someoneElse);\n     *\n     * // someoneElse in another instance of ChatEngine\n     * me.direct.on('$.invite', (payload) => {\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n     * });\n     */\n    invite(user) {\n\n        this.chatEngine.request('post', 'invite', {\n            to: user.uuid,\n            chat: this.objectify()\n        })\n            .then(() => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'search', new Error('Something went wrong while making a request to authentication server.'), { error });\n            });\n\n    }\n\n    /**\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n     @private\n     @param {Object} data The PubNub presence response for this event\n     */\n    onPresence(presenceEvent) {\n\n        // make sure channel matches this channel\n\n        // someone joins channel\n        if (presenceEvent.action === 'join') {\n\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n            /**\n             * Fired when a {@link User} has joined the room.\n             *\n             * @event Chat#$\".\"online\".\"join\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.join', (data) => {\n             *     console.log('User has joined the room!', data.user);\n             * });\n             */\n\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\n            // Avoid firing duplicate $.online events.\n            if (!this.users[user.uuid]) {\n                this.trigger('$.online.join', { user });\n            }\n\n        }\n\n        // someone leaves channel\n        if (presenceEvent.action === 'leave') {\n            this.userLeave(presenceEvent.uuid);\n        }\n\n        // someone timesout\n        if (presenceEvent.action === 'timeout') {\n            this.userDisconnect(presenceEvent.uuid);\n        }\n\n        // someone's state is updated\n        if (presenceEvent.action === 'state-change') {\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n        }\n\n    }\n\n    /**\n     * Update the {@link Chat} metadata on the server.\n     * @param  {object} data JSON object representing chat metadta.\n     */\n    update(data) {\n\n        let oldMeta = this.meta || {};\n        this.meta = Object.assign(oldMeta, data);\n\n        this.chatEngine.request('post', 'chat', {\n            chat: this.objectify()\n        }).then(() => {\n        }).catch((error) => {\n            this.chatEngine.throwError(this, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error });\n        });\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n      * });\n     */\n    emit(event, data) {\n\n        if (event === 'message' && typeof data !== 'object') {\n            throw new Error('the payload has to be an object');\n        }\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n            event,\n            chatengineSDK: this.chatEngine.package.version\n        };\n\n        let tracer = new Event(this.chatEngine, this, event);\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n            tracer.publish(pluginResponse);\n\n        });\n\n        return tracer;\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n        this.chatEngine.users[uuid].assign(state);\n\n        // check if the user already exists within the chatroom\n        // so we know if we need to notify or not\n        let userAlreadyHere = this.users[uuid];\n\n        // assign the user to the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // trigger the join event over this chatroom\n        if (!userAlreadyHere) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Called by {@link ChatEngine#disconnect}. Fires disconnection notifications\n     * and stores \"sleep\" state in memory. Sleep means the Chat was previously connected.\n     * @private\n     */\n    sleep() {\n\n        if (this.connected) {\n            this.onDisconnected();\n            this.asleep = true;\n        }\n    }\n\n    /**\n     * Called by {@link ChatEngine#reconnect}. Wakes the Chat up from sleep state.\n     * Re-authenticates with the server, and fires connection events once established.\n     * @private\n     */\n    wake() {\n\n        if (this.asleep) {\n            this.handshake(() => {\n                this.onConnected();\n            });\n        }\n\n    }\n\n    /**\n     * Fired upon successful connection to the network.\n     * @private\n     */\n    onConnected() {\n        this.connected = true;\n        this.trigger('$.connected');\n    }\n\n    /**\n     * Fires upon disconnection from the network through any means.\n     * @private\n     */\n    onDisconnected() {\n        this.connected = false;\n        this.trigger('$.disconnected');\n    }\n    /**\n     * Fires upon manually invoked leaving.\n     * @private\n     */\n    onLeave() {\n        this.trigger('$.left');\n        this.onDisconnected();\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n     * receiving events.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        // tell the server we left\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\n            .then(() => {\n\n                // trigger the disconnect events and update state\n                this.onLeave();\n\n                // tell the chat we've left\n                this.emit('$.system.leave', { subject: this.objectify() });\n\n                // tell session we've left\n                if (this.chatEngine.me.session) {\n                    this.chatEngine.me.session.leave(this);\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        let user = this.users[uuid];\n        delete this.users[uuid];\n\n        // make sure this event is real, user may have already left\n        if (user) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', { user });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        }\n\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        let user = this.users[uuid];\n        delete this.users[uuid];\n\n        // make sure this event is real, user may have already left\n        if (user) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n             *     console.log('User disconnected from the network:', data.user);\n             * });\n             */\n            this.trigger('$.offline.disconnect', { user });\n\n        }\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    /**\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n     which will emit all old events unless ```config.event``` is supplied.\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n     @param {Event} [config.event] The {@link Event} to search for.\n     @param {User} [config.sender] The {@link User} who sent the message.\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history. Limit will be ignored in case if both 'start' and 'end' timetokens has been passed in search configuration.\n     @param {Number} [config.start=0] The timetoken to begin searching between.\n     @param {Number} [config.end=0] The timetoken to end searching between.\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\n     @return {Search}\n     @example\n    chat.search({\n        event: 'my-custom-event',\n        sender: ChatEngine.me,\n        limit: 20\n    }).on('my-custom-event', (event) => {\n        console.log('this is an old event!', event);\n    }).on('$.search.finish', () => {\n        console.log('we have all our results!')\n    });\n     */\n    search(config) {\n\n        if (this.hasConnected) {\n            return new Search(this.chatEngine, this, config);\n        } else {\n            this.chatEngine.throwError(this, 'trigger', 'search', new Error('You must wait for the $.connected event before calling Chat#search'));\n        }\n\n    }\n\n    /**\n     * Fired when the chat first connects to network.\n     * @private\n     */\n    connectionReady() {\n\n        this.connected = true;\n        this.hasConnected = true;\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n         *     console.log('chat is ready to go!');\n         * });\n         */\n        this.onConnected();\n\n        if (this.chatEngine.me.session) {\n            this.chatEngine.me.session.join(this);\n        }\n\n        // add self to list of users\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n        // trigger my own online event\n        this.trigger('$.online.join', {\n            user: this.chatEngine.me\n        });\n\n        // global channel updates are triggered manually, only get presence on custom chats\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n            this.getUserUpdates();\n\n            // we may miss updates, so call this again 5 seconds later\n            setTimeout(() => {\n                this.getUserUpdates();\n            }, 5000);\n\n        }\n\n        this.on('$.system.leave', (payload) => {\n            this.userLeave(payload.sender.uuid);\n        });\n\n    }\n\n    /**\n     * Ask PubNub for information about {@link User}s in this {@link Chat}.\n     */\n    getUserUpdates() {\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, (s, r) => {\n            this.onHereNow(s, r);\n        });\n\n    }\n\n    /**\n     * Establish authentication with the server, then subscribe with PubNub.\n     * @return {[type]} [description]\n     */\n    connect() {\n\n        // establish good will with the server\n        this.handshake((response) => {\n\n            // asign metadata locally\n            if (response.data.found) {\n                this.meta = response.data.chat.meta;\n            } else {\n                this.update(this.meta);\n            }\n\n            // now that we've got connection, do everything else via connectionReady\n            this.connectionReady();\n\n        });\n\n    }\n\n    /**\n     * Connect to PubNub servers to initialize the chat.\n     * @example\n     * // create a new chatroom, but don't connect to it automatically\n     * let chat = new Chat('some-chat', false)\n     *\n     * // connect to the chat when we feel like it\n     * chat.connect();\n     */\n    handshake(callback) {\n\n        async.waterfall([\n            (next) => {\n                if (!this.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\n                    .then(callback)\n                    .catch(next);\n\n            }\n        ], (error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":73,"identifier":"/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":69,"index2":93,"size":7260,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":27,"building":39,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\nconst eachSeries = require('async/eachSeries');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\nclass Search extends Emitter {\n\n    constructor(chatEngine, chat, config = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        this.chat = chat;\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        this.config = config;\n        this.config.event = config.event;\n        this.config.limit = config.limit || 20;\n        this.config.channel = this.chat.channel;\n        this.config.includeTimetoken = true;\n        this.config.stringifiedTimeToken = true;\n        this.config.count = this.config.count || 100;\n        this.config.pages = this.config.pages || 10;\n\n        /** @private */\n        this.maxPage = this.config.pages;\n        /** @private */\n        this.numPage = 0;\n\n        /** @private */\n        this.referenceDate = this.config.end || 0;\n\n        /**\n         * Flag which represent whether there is potentially more data available in {@link Chat} history. This flag can\n         * be used for conditional call of {@link Chat#search}.\n         * @type {boolean}\n         */\n        this.hasMore = true;\n        /** @private */\n        this.messagesBetweenTimetokens = this.config.start > '0' && this.config.end > '0';\n        /** @private */\n        this.needleCount = 0;\n\n        /**\n         * Call PubNub history in a loop.\n         * @private\n         */\n        this.page = (pageDone) => {\n            let searchConfiguration = Object.assign({}, this.config, { start: this.referenceDate });\n            delete searchConfiguration.reverse;\n            delete searchConfiguration.end;\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            this._emit('$.search.page.request');\n\n            this.chatEngine.pubnub.history(searchConfiguration, (status, response) => {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n                } else {\n                    const startDate = response.startTimeToken;\n                    this.referenceDate = response.startTimeToken;\n                    this.hasMore = response.messages.length === this.config.count && startDate !== '0';\n\n                    response.messages.sort((left, right) => (left.timetoken < right.timetoken ? -1 : 1));\n\n                    if (this.config.start && startDate < this.config.start) {\n                        this.hasMore = false;\n                        response.messages = response.messages.filter(event => event.timetoken >= this.config.start);\n                    }\n\n                    pageDone(response);\n                }\n\n            });\n        };\n\n        let eventFilter = (event) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n\n                            let matches = payload && payload.event && payload.event === event;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        let senderFilter = (user) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        /**\n         * @private\n         */\n        this.triggerHistory = (message, cb) => {\n\n            if (this.needleCount < this.config.limit || this.messagesBetweenTimetokens) {\n\n                message.entry.timetoken = message.timetoken;\n\n                this.trigger(message.entry.event, message.entry, (reject) => {\n\n                    if (!reject) {\n                        this.needleCount += 1;\n                    }\n                    cb();\n\n                });\n\n            } else {\n                cb();\n            }\n\n        };\n\n        this.next = () => {\n            if (this.hasMore) {\n                this.maxPage = this.maxPage + this.config.pages;\n\n                this.find();\n            } else {\n                this._emit('$.search.finish');\n            }\n        };\n\n        /**\n         * @private\n         */\n        this.find = () => {\n            this.page((response) => {\n                response.messages.reverse();\n\n                eachSeries(response.messages, this.triggerHistory, () => {\n                    if (this.hasMore && this.numPage === this.maxPage) {\n                        this._emit('$.search.pause');\n                    } else if (this.hasMore && (this.needleCount < this.config.limit || this.messagesBetweenTimetokens)) {\n\n                        this.numPage += 1;\n                        this.find();\n                    } else {\n                        if (this.needleCount >= this.config.limit && !this.messagesBetweenTimetokens) {\n                            this.hasMore = false;\n                        }\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        this._emit('$.search.finish');\n                    }\n                });\n            });\n\n            return this;\n        };\n\n        if (this.config.event) {\n            this.plugin(eventFilter(this.config.event));\n        }\n\n        if (this.config.sender) {\n            this.plugin(senderFilter(this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        this._emit('$.search.start');\n        this.find();\n    }\n}\n\nmodule.exports = Search;\n"},{"id":98,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":97,"index2":97,"size":1790,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":49,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\nconst Session = require('./session');\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.chatEngine = chatEngine;\n\n        this.session = false;\n\n        this.name = 'Me';\n\n        if (this.chatEngine.ceConfig.enableSync) {\n            this.session = new Session(chatEngine);\n        }\n\n        return this;\n\n    }\n\n    /**\n     * assign updates from network\n     * @private\n     */\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state) {\n\n        // run the root update function\n        super.update(state);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n}\n\nmodule.exports = Me;\n"},{"id":99,"identifier":"/Users/ian/Development/chat-engine/src/components/session.js","name":"./src/components/session.js","index":99,"index2":96,"size":6133,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/me.js","issuerId":98,"issuerName":"./src/components/me.js","profile":{"factory":22,"building":29,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":98,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./session","loc":"2:16-36"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\n\nclass Session extends Emitter {\n\n    constructor(chatEngine) {\n\n        super(chatEngine);\n\n        this.name = 'Session';\n\n        this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        this.chats = {};\n\n        /**\n         * The {@link Chat} that syncs session between instances. Only connects\n         * if \"enableSync\" has been set to true in ceConfig.\n         * @type {this}\n         */\n        this.sync = null;\n\n    }\n\n    /**\n     * Forwards sync events from other instances into callback functions\n     * @private\n     */\n    subscribe() {\n\n        this.sync = new this.chatEngine.Chat([this.chatEngine.global.channel, 'user', this.chatEngine.me.uuid, 'me.', 'sync'].join('#'), false, this.chatEngine.ceConfig.enableSync, {}, 'system');\n\n        // subscribe to the events on our sync chat and forward them\n        this.sync.on('$.session.notify.chat.join', (payload) => {\n            this.onJoin(payload.data.subject);\n        });\n\n        this.sync.on('$.session.notify.chat.leave', (payload) => {\n            this.onleave(payload.data.subject);\n        });\n\n    }\n\n    /**\n     * Uses PubNub channel groups to restore a session for this uuid\n     * @private\n     */\n    restore() {\n\n        // these are custom groups that separate custom chats from system chats\n        // for better fitlering\n        let groups = ['custom', 'system'];\n\n        // loop through the groups\n        groups.forEach((group) => {\n\n            // generate the channel group string for PubNub using the current uuid\n            let channelGroup = [this.chatEngine.ceConfig.globalChannel, this.chatEngine.me.uuid, group].join('#');\n\n            // ask pubnub for a list of channels for this group\n            this.chatEngine.pubnub.channelGroups.listChannels({\n                channelGroup\n            }, (status, response) => {\n\n                if (status.error) {\n                    this.chatEngine.throwError(this.chatEngine, '_emit', 'sync', new Error('There was a problem restoring your session from PubNub servers.'), { status });\n                } else {\n\n                    // loop through the returned channels\n                    response.channels.forEach((channel) => {\n\n                        // call the same callback as if we were notified about them\n                        this.onJoin({\n                            channel,\n                            private: this.chatEngine.parseChannel(channel).private,\n                            group\n                        });\n\n                        /**\n                        Fired when session has been restored at boot. Fired once per\n                        session group.\n                        @event Me#$\".\"session\".\"group\".\"restored\n                        */\n                        this.trigger('$.group.restored', { group });\n\n                    });\n\n                }\n\n            });\n\n        });\n\n    }\n\n    /**\n     * Callback fired when another instance has joined a chat\n     * @private\n     */\n    join(chat) {\n\n        // don't rebroadcast chats in session we've already heard about\n        if (!this.chats[chat.group] || !this.chats[chat.group][chat.channel]) {\n            this.sync.emit('$.session.notify.chat.join', { subject: chat.objectify() });\n        }\n\n    }\n\n    /**\n     * Callback fired when another instance has left a chat\n     * @private\n     */\n    leave(chat) {\n        this.sync.emit('$.session.notify.chat.leave', { subject: chat.objectify() });\n    }\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    onJoin(chat) {\n\n        // create the chat group if it doesn't exist\n        this.chats[chat.group] = this.chats[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = this.chatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n\n            // assign it to the group\n            this.chats[chat.group][chat.channel] = existingChat;\n        } else {\n\n            // otherwise, try to recreate it with the server information\n            this.chats[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n            /**\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n            @event Me#$\".\"session\".\"chat\".\"join\n            @example\n            *\n            * // Logged in as \"Ian\" in first window\n            * ChatEngine.me.session.on('$.chat.join', (data) => {\n            *     console.log('I joined a new chat in a second window!', data.chat);\n            * });\n            *\n            * // Logged in as \"Ian\" in second window\n            * new ChatEngine.Chat('another-chat');\n            */\n            this.trigger('$.chat.join', { chat: this.chats[chat.group][chat.channel] });\n\n        }\n\n    }\n\n    /**\n    Removes {@link Chat} within this.chats\n    @private\n    */\n    onleave(chat) {\n\n        if (this.chats[chat.group] && this.chats[chat.group][chat.channel]) {\n\n            chat = this.chats[chat.group][chat.channel] || chat;\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n            * @event Me#$\".\"session\".\"chat\".\"leave\n            */\n\n            delete this.chatEngine.chats[chat.channel];\n            delete this.chats[chat.group][chat.channel];\n\n        }\n\n        this.trigger('$.chat.leave', { chat });\n\n    }\n\n}\n\nmodule.exports = Session;\n"}],"filteredModules":87,"origins":[{"moduleId":29,"module":"/Users/ian/Development/chat-engine/src/index.js","moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":2,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":35,"index2":31,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":42},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"global","loc":"1:0-44"},{"moduleId":22,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":54,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/timers-browserify/main.js","module":"./node_modules/timers-browserify/main.js","moduleName":"./node_modules/timers-browserify/main.js","type":"cjs require","userRequest":"global","loc":"1:0-41"},{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/setimmediate/setImmediate.js","module":"./node_modules/setimmediate/setImmediate.js","moduleName":"./node_modules/setimmediate/setImmediate.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":3,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":39,"index2":65,"size":7474,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":26,"building":21,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":28,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"2:16-45"},{"moduleId":73,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/search.js","module":"./src/components/search.js","moduleName":"./src/components/search.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"},{"moduleId":99,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/session.js","module":"./src/components/session.js","moduleName":"./src/components/session.js","type":"cjs require","userRequest":"../modules/emitter","loc":"1:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const waterfall = require('async/waterfall');\nconst RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and duplicates\n events on the root emitter.\n @class Emitter\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Emitter';\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Stores in memory keys and values\n         @private\n         */\n        this._dataset = {};\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data = {}) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data, this);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n            return this;\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n         *     console.log('event was fired').\n         * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n         *     console.log('event.a or event.b was fired').;\n         * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n            return this;\n\n        };\n\n    }\n\n    // add an object as a subobject under a namespoace\n    addChild(childName, childOb) {\n        // assign the new child object as a property of parent under the\n        // given namespace\n        this[childName] = childOb;\n\n        // assign a data set for the namespace if it doesn't exist\n        if (!this._dataset[childName]) {\n            this._dataset[childName] = {};\n        }\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = this;\n\n        // bind get() and set() to the data set\n        childOb.get = this.get.bind(this._dataset[childName]);\n        childOb.set = this.set.bind(this._dataset[childName]);\n    }\n\n    get(key) {\n        return this[key];\n    }\n\n    set(key, value) {\n        if (this[key] && !value) {\n            delete this[key];\n        } else {\n            this[key] = value;\n        }\n    }\n\n    /**\n     Binds a plugin to this object\n     @param {Object} module The plugin module\n     @tutorial using\n     */\n    plugin(module) {\n\n        // add this plugin to a list of plugins for this object\n        this.plugins.push(module);\n\n        // see if there are plugins to attach to this class\n        if (module.extends && module.extends[this.name]) {\n            // attach the plugins to this class\n            // under their namespace\n            this.addChild(module.namespace, new module.extends[this.name]());\n\n            this[module.namespace].ChatEngine = this.chatEngine;\n\n            // if the plugin has a special construct function\n            // run it\n            if (this[module.namespace].construct) {\n                this[module.namespace].construct();\n            }\n\n        }\n\n        return this;\n\n    }\n\n    bindProtoPlugins() {\n\n        if (this.chatEngine.protoPlugins[this.name]) {\n\n            this.chatEngine.protoPlugins[this.name].forEach((module) => {\n                this.plugin(module);\n            });\n\n        }\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n    trigger(event, payload = {}, done = () => {}) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (reject, pluginResponse) => {\n\n                if (reject) {\n                    done(reject);\n                } else {\n                    // emit this event to any listener\n                    this._emit(event, pluginResponse);\n                    done(null, event, pluginResponse);\n                }\n\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // the user doesn't exist, create it\n                payload.sender = new this.chatEngine.User(payload.sender);\n\n                payload.sender._getState(() => {\n                    complete();\n                });\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location]) {\n\n                if (pluginItem.middleware[location][event]) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location][event]);\n                }\n\n                if (pluginItem.middleware[location]['*']) {\n                    // add the function to the queue\n                    pluginQueue.push(pluginItem.middleware[location]['*']);\n                }\n\n            }\n\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    onConstructed() {\n\n        this.bindProtoPlugins();\n        this.trigger(['$', 'created', this.name.toLowerCase()].join('.'));\n\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":5,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":31,"index2":30,"size":4109,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":12,"building":13},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"2:20-45"},{"moduleId":25,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/event.js","module":"./src/components/event.js","moduleName":"./src/components/event.js","type":"cjs require","userRequest":"../modules/root_emitter","loc":"1:16-50"},{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"5:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n* @class RootEmitter\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        this.name = 'RootEmitter';\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.on(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.off(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.onAny(event, callback);\n\n            return this;\n\n        };\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = (event, callback) => {\n\n            // emit the event from the object that created it\n            this.emitter.once(event, callback);\n\n            return this;\n\n        };\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":6,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/module.js","name":"(webpack)/buildin/module.js","index":36,"index2":32,"size":517,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","issuerId":15,"issuerName":"./node_modules/async/dist/async.js","profile":{"factory":130,"building":43},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":15,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/async/dist/async.js","module":"./node_modules/async/dist/async.js","moduleName":"./node_modules/async/dist/async.js","type":"cjs require","userRequest":"module","loc":"1:0-44"},{"moduleId":84,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/isBuffer.js","module":"./node_modules/lodash/isBuffer.js","moduleName":"./node_modules/lodash/isBuffer.js","type":"cjs require","userRequest":"module","loc":"1:0-41"},{"moduleId":90,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_nodeUtil.js","module":"./node_modules/lodash/_nodeUtil.js","moduleName":"./node_modules/lodash/_nodeUtil.js","type":"cjs require","userRequest":"module","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n"},{"id":25,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":68,"index2":64,"size":2376,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":26,"building":24,"dependencies":2},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"},{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"3:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/root_emitter');\n\n/**\n * @class Event\n * Represents an {@link Chat} event.\n * @fires $\".\"emitted\n * @extends Emitter\n * @extends RootEmitter\n */\nclass Event extends Emitter {\n\n    constructor(chatEngine, chat, event) {\n\n        super();\n\n        /**\n         * @private\n         */\n        this.chatEngine = chatEngine;\n\n        /**\n         * The {@link Chat#channel} that this event is registered to.\n         * @type String\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         * @readonly\n         */\n        this.channel = chat.channel;\n\n        /**\n         * Events are always a property of a {@link Chat}. Responsible for\n         * listening to specific events and firing events when they occur.\n         * @readonly\n         * @type {Chat}\n         */\n        this.chat = chat;\n\n        /**\n         * The string representation of the event. This is supplied as the first parameter to {@link Chat#on}\n         * @type {String}\n         */\n        this.event = event;\n\n        /**\n         * A name that identifies this class\n         * @type {String}\n         */\n        this.name = 'Event';\n\n        return this;\n\n    }\n\n    /**\n     Publishes the event over the PubNub network to the {@link Event} channel\n\n     @private\n     @param {Object} data The event payload object\n     */\n    publish(m) {\n\n        m.event = this.event;\n\n        this.chatEngine.pubnub.publish({\n            message: m,\n            channel: this.channel\n        }, (status, response) => {\n\n            if (status.statusCode === 200) {\n\n                if (response) {\n                    m.timetoken = response.timetoken;\n                }\n\n                /**\n                 * Message successfully published\n                 * @event Event#$\".\"emitted\"\n                 * @param {Object} data The message payload\n                 */\n                this._emit('$.emitted', m);\n\n            } else {\n\n                /**\n                 * There was a problem publishing over the PubNub network.\n                 * @event Chat#$\".\"error\".\"publish\n                 */\n                this.chatEngine.throwError(this, '_emit', 'emitter', new Error('There was a problem publishing over the PubNub network.'), status);\n            }\n\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n\n"},{"id":28,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":98,"index2":95,"size":5575,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":58,"dependencies":12},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"8:13-41"},{"moduleId":98,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const Emitter = require('../modules/emitter');\n\n/**\nThis is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\nIf a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n@class User\n@extends Emitter\n@extends RootEmitter\n@param {User#uuid} uuid A unique identifier for this user.\n@param {User#state} state The {@link User}'s state object synchronized between all clients of the chat.\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'User';\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state;\n         */\n        this.state = {};\n\n        this._stateFetched = false;\n\n        this._stateInProgress = false;\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n        *     console.log(payload.sender.uuid, 'sent your a direct message');\n        * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new this.chatEngine.Chat([chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', {}, 'system');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n        return this;\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(callback) {\n\n        if (!this._stateFetched && !this._stateInProgress) {\n\n            this._stateInProgress = true;\n\n            this.chatEngine.pubnub.getState({\n                uuid: this.uuid,\n                channels: [this.chatEngine.global.channel]\n            }, (status, response) => {\n\n                if (status.statusCode === 200) {\n\n                    let pnState = response.channels[this.chatEngine.global.channel];\n                    if (Object.keys(pnState).length) {\n\n                        this.assign(response.data);\n                        this._stateFetched = true;\n                        callback(this.state);\n\n                    } else {\n\n                        this.chatEngine.request('get', 'user_state', {\n                            user: this.uuid\n                        }).then((res) => {\n\n                            this.assign(res.data);\n                            this._stateFetched = true;\n                            callback(this.state);\n\n                        }).catch((err) => {\n                            this.chatEngine.throwError(this, 'trigger', 'getState', err);\n                        });\n\n                    }\n\n                } else {\n                    this.chatEngine.throwError(this, 'trigger', 'getState', new Error('There was a problem getting user state from the PubNub network.'));\n                }\n\n            });\n\n        } else {\n            callback(this.state);\n        }\n\n    }\n\n\n}\n\nmodule.exports = User;\n"},{"id":29,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":99,"size":2371,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":16,"building":22},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"const init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of ChatEngine specific configuration options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.enableSync] {Boolean} Synchronizes chats between instances with the same {@link Me#uuid}. See {@link Me#sync}.\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint='https://pubsub.pubnub.com/v1/blocks/sub-key/YOUR_SUB_KEY/chat-engine-server'] {String} The root URL of the server used to manage permissions for private channels. Set by default to match the PubNub functions deployed to your account. See {@tutorial privacy} for more.\n@param [ceConfig.debug] {Boolean} Logs all ChatEngine events to the console.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'YOUR_PUB_KEY',\n    subscribeKey: 'YOUR_SUB_KEY'\n});\n*/\n\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    if (typeof ceConfig.enableSync === 'undefined') {\n        ceConfig.enableSync = false;\n    }\n\n    ceConfig.endpoint = ceConfig.endpoint || 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + pnConfig.subscribeKey + '/chat-engine-server';\n\n    pnConfig.heartbeatInterval = pnConfig.heartbeatInterval || 30;\n    pnConfig.presenceTimeout = pnConfig.presenceTimeout || 60;\n\n    pnConfig.keepAlive = true;\n    pnConfig.keepAliveSettings = {\n        keepAlive: true,\n        timeout: 5 * 1000 * 60\n    };\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nconst ChatEngineCore = {\n    plugin: {},\n    create: create\n};\n\nmodule.exports = ChatEngineCore;\n\nmodule.exports.ChatEngineCore = ChatEngineCore;\n"},{"id":30,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":98,"size":18690,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":29,"issuerName":"./src/index.js","profile":{"factory":3,"building":42},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":29,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"1:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\nconst pack = require('../package.json');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\nconst async = require('async');\n\n/**\n@class ChatEngine\n@extends RootEmitter\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n*/\nmodule.exports = (ceConfig = {}, pnConfig = {}) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine.\n     * @type {Object}\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine.\n     * @memberof ChatEngine\n     * @type {Object}\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}.\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event.\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n     * The package.json for ChatEngine. Used mainly for detecting package version.\n     * @type {Object}\n     */\n    ChatEngine.package = pack;\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            console.error(payload);\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    let countObject = {};\n\n    if (ceConfig.debug) {\n\n        ChatEngine.onAny((event, payload) => {\n\n            console.info('debug:', event, payload);\n\n            countObject['event: ' + event] = countObject[event] || 0;\n            countObject['event: ' + event] += 1;\n\n        });\n\n    }\n\n    if (ceConfig.profiling) {\n\n        setInterval(() => {\n\n            countObject.chats = Object.keys(ChatEngine.chats).length;\n            countObject.users = Object.keys(ChatEngine.users).length;\n\n            console.table(countObject);\n\n        }, 3000);\n\n    }\n\n    ChatEngine.protoPlugins = {};\n\n    /**\n     * Bind a plugin to all future instances of a Class.\n     * @method ChatEngine#proto\n     * @param  {String} className The string representation of a class to bind to\n     * @param  {Class} plugin The plugin function.\n     */\n    ChatEngine.proto = (className, plugin) => {\n        ChatEngine.protoPlugins[className] = ChatEngine.protoPlugins[className] || [];\n        ChatEngine.protoPlugins[className].push(plugin);\n    };\n\n    /**\n     * @private\n     */\n    ChatEngine.request = (method, route, inputBody = {}, inputParams = {}) => {\n\n        let body = {\n            uuid: ChatEngine.pnConfig.uuid,\n            global: ceConfig.globalChannel,\n            authKey: ChatEngine.pnConfig.authKey\n        };\n\n        let params = {\n            route\n        };\n\n        body = Object.assign(body, inputBody);\n        params = Object.assign(params, inputParams);\n\n        if (method === 'get' || method === 'delete') {\n            params = Object.assign(params, body);\n            return axios[method](ceConfig.endpoint, { params });\n        } else {\n            return axios[method](ceConfig.endpoint, body, { params });\n        }\n\n\n    };\n\n    /**\n     * Parse a channel name into chat object parts\n     * @private\n     */\n    ChatEngine.parseChannel = (channel) => {\n\n        let info = channel.split('#');\n\n        return {\n            global: info[0],\n            type: info[1],\n            private: info[2] === 'private.'\n        };\n\n    };\n\n    /**\n     * Get the internal channel name of supplied string\n     * @private\n     */\n    ChatEngine.augmentChannel = (original = new Date().getTime(), isPrivate = true) => {\n\n        let channel = original.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (isPrivate) {\n            chanPrivString = 'private.';\n        }\n\n        if (channel.indexOf(ChatEngine.ceConfig.globalChannel) === -1) {\n            channel = [ChatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        return channel;\n\n    };\n\n    /**\n     * Initial communication with the server. Server grants permissions to\n     * talk in chats, etc.\n     * @private\n     */\n    ChatEngine.handshake = (complete) => {\n\n        async.series([\n            (next) => {\n                ChatEngine.request('post', 'bootstrap').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_read').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'user_write').then(() => {\n                    next(null);\n                }).catch(next);\n            },\n            (next) => {\n                ChatEngine.request('post', 'group').then(complete).catch(next);\n            }\n        ], (error) => {\n            if (error) {\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').' + error && error.response && error.response.data), { error });\n            }\n        });\n\n    };\n\n    /**\n     * @private\n     * Listen to PubNub events and forward them into ChatEngine system.\n     */\n    ChatEngine.listenToPubNub = () => {\n\n        /**\n         Fires when PubNub network connection changes.\n\n         @private\n         @param {Object} statusEvent The response status\n         */\n        ChatEngine.pubnub.addListener({\n            message: (m) => {\n\n                // assign the message timetoken as a property of the payload\n                m.message.timetoken = m.timetoken;\n\n                if (ChatEngine.chats[m.channel]) {\n                    ChatEngine.chats[m.channel].trigger(m.message.event, m.message);\n                }\n\n            },\n            presence: (payload) => {\n\n                if (ChatEngine.chats[payload.channel]) {\n                    ChatEngine.chats[payload.channel].onPresence(payload);\n                }\n\n            },\n            status: (statusEvent) => {\n\n                /**\n                 * SDK detected that network is online.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"online\n                 */\n\n                /**\n                 * SDK detected that network is down.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                 */\n\n                /**\n                 * A subscribe event experienced an exception when running.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                 */\n\n                /**\n                 * SDK was able to reconnect to pubnub.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                 */\n\n                /**\n                 * SDK subscribed with a new mix of channels.\n                 * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                 */\n\n                /**\n                 * JSON parsing crashed.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                 */\n\n                /**\n                 * Server rejected the request.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                 */\n\n                /**\n                 * If using decryption strategies and the decryption fails.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                 */\n\n                /**\n                 * Request timed out.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                 */\n\n                /**\n                 * PAM permission failure.\n                 * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                 */\n\n                // map the pubnub events into ChatEngine events\n                let categories = {\n                    PNNetworkUpCategory: 'up.online',\n                    PNNetworkDownCategory: 'down.offline',\n                    PNNetworkIssuesCategory: 'down.issue',\n                    PNReconnectedCategory: 'up.reconnected',\n                    PNConnectedCategory: 'up.connected',\n                    PNAccessDeniedCategory: 'down.denied',\n                    PNMalformedResponseCategory: 'down.malformed',\n                    PNBadRequestCategory: 'down.badrequest',\n                    PNDecryptionErrorCategory: 'down.decryption',\n                    PNTimeoutCategory: 'down.timeout'\n                };\n\n                let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                if (statusEvent.affectedChannels) {\n                    statusEvent.affectedChannels.forEach((channel) => {\n\n                        let chat = ChatEngine.chats[channel];\n\n                        if (chat) {\n                            // connected category tells us the chat is ready\n                            if (statusEvent.category === 'PNConnectedCategory') {\n                                chat.connectionReady();\n                            }\n\n                            // trigger the network events\n                            chat.trigger(eventName, statusEvent);\n\n                        } else {\n                            ChatEngine._emit(eventName, statusEvent);\n                        }\n                    });\n                } else {\n                    ChatEngine._emit(eventName, statusEvent);\n                }\n            }\n        });\n\n    };\n\n    /**\n     * @private\n     * Subscribe to PubNub and begin receiving events.\n     */\n    ChatEngine.subscribeToPubNub = () => {\n\n        let chanGroups = [\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#rooms',\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#system',\n            ceConfig.globalChannel + '#' + ChatEngine.me.uuid + '#custom'\n        ];\n\n        ChatEngine.pubnub.subscribe({\n            channelGroups: chanGroups,\n            withPresence: true\n        });\n\n    };\n\n    /**\n     * Initialize ChatEngine modules on first time boot.\n     * @private\n     */\n    ChatEngine.firstConnect = (state) => {\n\n        ChatEngine.pubnub = new PubNub(ChatEngine.pnConfig);\n\n        // create a new chat to use as global chat\n        // we don't do auth on this one because it's assumed to be done with the /auth request below\n        ChatEngine.global = new ChatEngine.Chat(ceConfig.globalChannel, false, true, {}, 'system');\n\n        ChatEngine.global.once('$.connected', () => {\n\n            // build the current user\n            ChatEngine.me = new Me(ChatEngine, ChatEngine.pnConfig.uuid);\n\n            /**\n            * Fired when a {@link Me} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"me\n            * @example\n            * ChatEngine.on('$.created.me', (data, me) => {\n            *     console.log('Me was created', me);\n            * });\n            */\n            ChatEngine.me.onConstructed();\n\n            if (ChatEngine.ceConfig.enableSync) {\n                ChatEngine.me.session.subscribe();\n                ChatEngine.me.session.restore();\n            }\n\n            ChatEngine.me.update(state);\n\n            /**\n             *  Fired when ChatEngine is connected to the internet and ready to go!\n             * @event ChatEngine#$\".\"ready\n             * @example\n             * ChatEngine.on('$.ready', (data) => {\n             *     let me = data.me;\n             * })\n             */\n\n            ChatEngine._emit('$.ready', {\n                me: ChatEngine.me\n            });\n\n            ChatEngine.ready = true;\n\n            ChatEngine.listenToPubNub();\n            ChatEngine.subscribeToPubNub();\n\n            ChatEngine.global.getUserUpdates();\n\n        });\n\n    };\n\n    /**\n     * Disconnect from all {@link Chat}s and mark them as asleep.\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // every individual chat will be disconnected\n     * chat.on('$.disconnected', () => {\n     *     done();\n     * });\n     *\n     * // Changing User:\n     * ChatEngine.disconnect()\n     * ChatEngine = new ChatEngine({}, {});\n     * ChatEngine.connect()\n     */\n    ChatEngine.disconnect = () => {\n\n        // Unsubscribe from all PubNub chats\n        ChatEngine.pubnub.unsubscribeAll();\n\n        // for every chat in ChatEngine.chats, signal disconnected\n        Object.keys(ChatEngine.chats).forEach((key) => {\n            ChatEngine.chats[key].sleep();\n        });\n\n    };\n\n    /**\n     * Performs authentication with server and restores connection\n     * to all sleeping chats.\n     * @example\n     *\n     * // create a new chat\n     * let chat = new ChatEngine.Chat(new Date().getTime());\n     *\n     * // disconnect from ChatEngine\n     * ChatEngine.disconnect();\n     *\n     * // reconnect sometime later\n     * ChatEngine.reconnect();\n     *\n     */\n    ChatEngine.reconnect = () => {\n\n        // do the whole auth flow with the new authKey\n        ChatEngine.handshake(() => {\n\n            // for every chat in ChatEngine.chats, call .connect()\n            Object.keys(ChatEngine.chats).forEach((key) => {\n                ChatEngine.chats[key].wake();\n            });\n\n            ChatEngine.subscribeToPubNub();\n\n        });\n\n    };\n\n    /**\n    @private\n    */\n    ChatEngine.setAuth = (authKey = PubNub.generateUUID()) => {\n\n        ChatEngine.pnConfig.authKey = authKey;\n        ChatEngine.pubnub.setAuthKey(authKey);\n\n    };\n\n    /**\n     * Disconnects, changes authentication token, performs handshake with server\n     * and reconnects with new auth key. Used for extending logged in sessions\n     * for active users.\n     * @example\n     * // early\n     * ChatEngine.connect(...);\n     *\n     * ChatEngine.once('$.connected', () => {\n     *     // first connection established\n     * });\n     *\n     * // some time passes, session token expires\n     * ChatEngine.reauthorize(authKey);\n     *\n     * // we are connected again\n     * ChatEngine.once('$.connected', () => {\n     *     // we are connected again\n     * });\n     */\n    ChatEngine.reauthorize = (authKey = PubNub.generateUUID()) => {\n\n        ChatEngine.global.once('$.disconnected', () => {\n\n            ChatEngine.setAuth(authKey);\n            ChatEngine.reconnect();\n\n        });\n\n        ChatEngine.disconnect();\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc. Must be alphanumeric.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * @param {String} [authKey] A authentication secret. Will be sent to authentication backend for validation. This is usually an access token. See {@tutorial auth} for more.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = PubNub.generateUUID()) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n        ChatEngine.pnConfig.uuid = uuid;\n        ChatEngine.pnConfig.authKey = authKey;\n\n        ChatEngine.handshake(() => {\n            ChatEngine.firstConnect(state);\n        });\n\n    };\n\n    ChatEngine.destroy = () => {\n\n        Object.keys(ChatEngine.chats).forEach((chat) => {\n            ChatEngine.chats[chat].emitter.removeAllListeners();\n        });\n\n        Object.keys(ChatEngine.users).forEach((user) => {\n            ChatEngine.users[user].emitter.removeAllListeners();\n        });\n\n        ChatEngine.emitter.removeAllListeners();\n\n    };\n\n    /**\n     * The {@link Chat} class. Creates a new Chat when initialized, or returns an existing instance if chat has already been created.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = function (...args) {\n\n        let internalChannel = ChatEngine.augmentChannel(args[0], args[1]);\n\n        if (ChatEngine.chats[internalChannel]) {\n            return ChatEngine.chats[internalChannel];\n        } else {\n\n            let newChat = new Chat(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link Chat} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"chat\n            * @example\n            * ChatEngine.on('$.created.chat', (data, chat) => {\n            *     console.log('Chat was created', chat);\n            * });\n            */\n            newChat.onConstructed();\n\n            return newChat;\n\n        }\n\n    };\n\n    /**\n     * The {@link User} class. Creates a new User when initialized, or returns an existing instance if chat has already been created.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = function (...args) {\n\n        if (ChatEngine.me.uuid === args[0]) {\n            return ChatEngine.me;\n        } else if (ChatEngine.users[args[0]]) {\n            return ChatEngine.users[args[0]];\n        } else {\n\n            let newUser = new User(ChatEngine, ...args);\n\n            /**\n            * Fired when a {@link User} has been created within ChatEngine.\n            * @event ChatEngine#$\".\"created\".\"user\n            * @example\n            * ChatEngine.on('$.created.user', (data, user) => {\n            *     console.log('Chat was created', user);\n            * });\n            */\n            newUser.onConstructed();\n\n            return newUser;\n\n        }\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":51,"identifier":"/Users/ian/Development/chat-engine/node_modules/json-loader/index.js!/Users/ian/Development/chat-engine/package.json","name":"./package.json","index":30,"index2":28,"size":1364,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":87,"building":4},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"../package.json","loc":"3:13-39"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"module.exports = {\"author\":\"PubNub\",\"name\":\"chat-engine\",\"version\":\"0.9.5\",\"description\":\"ChatEngine\",\"main\":\"src/index.js\",\"scripts\":{\"deploy\":\"gulp; npm publish;\",\"docs\":\"jsdoc src/index.js -c jsdoc.json\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/pubnub/chat-engine.git\"},\"keywords\":[\"pubnub\",\"chat\",\"sdk\",\"realtime\"],\"bugs\":{\"url\":\"https://github.com/pubnub/chat-engine/issues\"},\"homepage\":\"https://github.com/pubnub/chat-engine#readme\",\"devDependencies\":{\"body-parser\":\"^1.17.2\",\"chai\":\"^3.5.0\",\"chat-engine-typing-indicator\":\"0.0.x\",\"decache\":\"^4.3.0\",\"docdash\":\"^0.4.0\",\"es6-promise\":\"^4.1.1\",\"eslint\":\"^4.7.1\",\"eslint-config-airbnb\":\"^15.1.0\",\"eslint-plugin-import\":\"^2.7.0\",\"express\":\"^4.15.3\",\"gulp\":\"^3.9.1\",\"gulp-clean\":\"^0.3.2\",\"gulp-eslint\":\"^4.0.0\",\"gulp-istanbul\":\"^1.1.2\",\"gulp-jsdoc3\":\"^1.0.1\",\"gulp-mocha\":\"^3.0.1\",\"gulp-rename\":\"^1.2.2\",\"gulp-surge\":\"^0.1.0\",\"gulp-uglify\":\"^2.0.0\",\"gulp-uglify-es\":\"^0.1.3\",\"http-server\":\"^0.10.0\",\"isparta\":\"^4.0.0\",\"jsdoc\":\"^3.5.5\",\"mocha\":\"^3.1.2\",\"proxyquire\":\"^1.8.0\",\"pubnub-functions-mock\":\"^0.0.13\",\"request\":\"^2.82.0\",\"run-sequence\":\"^2.2.0\",\"sinon\":\"^4.0.0\",\"stats-webpack-plugin\":\"^0.6.1\",\"surge\":\"^0.19.0\",\"uglifyjs-webpack-plugin\":\"^1.0.1\",\"webpack\":\"^3.6.0\",\"webpack-stream\":\"^4.0.0\"},\"dependencies\":{\"async\":\"^2.1.2\",\"axios\":\"^0.16.2\",\"eventemitter2\":\"^2.2.1\",\"pubnub\":\"^4.20.1\"}}"},{"id":53,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":33,"index2":94,"size":24298,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":44,"dependencies":27},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"6:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const async = require('async');\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst Search = require('../components/search');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. Must be alphanumeric. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [isPrivate=true] Attempt to authenticate ourselves before connecting to this {@link Chat}.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {Object} [meta={}] Chat metadata that will be persisted on the server and populated on creation.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link Me.session} object.\n @class Chat\n @extends Emitter\n @extends RootEmitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\".\"*\n @fires Chat#$\".\"offline\".\"*\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), isPrivate = false, autoConnect = true, meta = {}, group = 'custom') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        this.name = 'Chat';\n\n        /**\n        * Classify the chat within some group, Valid options are 'system', 'fixed', or 'custom'.\n        * @type Boolean\n        * @readonly\n        * @private\n        */\n        this.group = group;\n\n        /**\n        * Excludes all users from reading or writing to the {@link chat} unless they have been explicitly invited via {@link Chat#invite};\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = isPrivate;\n\n        /**\n         * Chat metadata persisted on the server. Useful for storing things like the name and description. Call {@link Chat#update} to update the remote information.\n         * @type Object\n         * @readonly\n         */\n        this.meta = meta || {};\n\n        /**\n         * A string identifier for the Chat room. Any chat with an identical channel will be able to communicate with one another.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = this.chatEngine.augmentChannel(channel, this.isPrivate);\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        /**\n         * Keep a record if we've every successfully connected to this chat before.\n         * @type {Boolean}\n         */\n        this.hasConnected = false;\n\n        /**\n         * If user manually disconnects via {@link ChatEngine#disconnect}, the\n         * chat is put to \"sleep\". If a connection is reestablished\n         * via {@link ChatEngine#reconnect}, sleeping chats reconnect automatically.\n         * @type {Boolean}\n         */\n        this.asleep = false;\n\n        this.chatEngine.chats[this.channel] = this;\n\n        if (autoConnect) {\n            this.connect();\n        }\n\n        return this;\n\n    }\n\n    /**\n     Updates list of {@link User}s in this {@link Chat}\n     based on who is online now.\n\n     @private\n     @param {Object} status The response status\n     @param {Object} response The response payload object\n     */\n    onHereNow(status, response) {\n\n        if (status.error) {\n\n            /**\n             * There was a problem fetching the presence of this chat\n             * @event Chat#$\".\"error\".\"presence\n             */\n            this.chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'));\n\n        } else {\n\n            // get the list of occupants in this channel\n            let occupants = response.channels[this.channel].occupants;\n\n            // format the userList for rltm.js standard\n            occupants.forEach((occupant) => {\n                this.userUpdate(occupant.uuid, occupant.state);\n            });\n\n        }\n\n    }\n\n    /**\n    * Turns a {@link Chat} into a JSON representation.\n    * @return {Object}\n    */\n    objectify() {\n\n        return {\n            channel: this.channel,\n            group: this.group,\n            private: this.isPrivate,\n            meta: this.meta\n        };\n\n    }\n\n    /**\n     * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n     * @param {User} user The {@link User} to invite to this chatroom.\n     * @fires Me#event:$\".\"invite\n     * @example\n     * // one user running ChatEngine\n     * let secretChat = new ChatEngine.Chat('secret-channel');\n     * secretChat.invite(someoneElse);\n     *\n     * // someoneElse in another instance of ChatEngine\n     * me.direct.on('$.invite', (payload) => {\n     *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n     * });\n     */\n    invite(user) {\n\n        this.chatEngine.request('post', 'invite', {\n            to: user.uuid,\n            chat: this.objectify()\n        })\n            .then(() => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                     *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                     * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'search', new Error('Something went wrong while making a request to authentication server.'), { error });\n            });\n\n    }\n\n    /**\n     Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n     @private\n     @param {Object} data The PubNub presence response for this event\n     */\n    onPresence(presenceEvent) {\n\n        // make sure channel matches this channel\n\n        // someone joins channel\n        if (presenceEvent.action === 'join') {\n\n            let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n            /**\n             * Fired when a {@link User} has joined the room.\n             *\n             * @event Chat#$\".\"online\".\"join\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.join', (data) => {\n             *     console.log('User has joined the room!', data.user);\n             * });\n             */\n\n            // It's possible for PubNub to send us both a join and have the user appear in here_now\n            // Avoid firing duplicate $.online events.\n            if (!this.users[user.uuid]) {\n                this.trigger('$.online.join', { user });\n            }\n\n        }\n\n        // someone leaves channel\n        if (presenceEvent.action === 'leave') {\n            this.userLeave(presenceEvent.uuid);\n        }\n\n        // someone timesout\n        if (presenceEvent.action === 'timeout') {\n            this.userDisconnect(presenceEvent.uuid);\n        }\n\n        // someone's state is updated\n        if (presenceEvent.action === 'state-change') {\n            this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n        }\n\n    }\n\n    /**\n     * Update the {@link Chat} metadata on the server.\n     * @param  {object} data JSON object representing chat metadta.\n     */\n    update(data) {\n\n        let oldMeta = this.meta || {};\n        this.meta = Object.assign(oldMeta, data);\n\n        this.chatEngine.request('post', 'chat', {\n            chat: this.objectify()\n        }).then(() => {\n        }).catch((error) => {\n            this.chatEngine.throwError(this, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error });\n        });\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n      *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n      * });\n     */\n    emit(event, data) {\n\n        if (event === 'message' && typeof data !== 'object') {\n            throw new Error('the payload has to be an object');\n        }\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n            event,\n            chatengineSDK: this.chatEngine.package.version\n        };\n\n        let tracer = new Event(this.chatEngine, this, event);\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n            tracer.publish(pluginResponse);\n\n        });\n\n        return tracer;\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n        this.chatEngine.users[uuid].assign(state);\n\n        // check if the user already exists within the chatroom\n        // so we know if we need to notify or not\n        let userAlreadyHere = this.users[uuid];\n\n        // assign the user to the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // trigger the join event over this chatroom\n        if (!userAlreadyHere) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new this.chatEngine.User(uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Called by {@link ChatEngine#disconnect}. Fires disconnection notifications\n     * and stores \"sleep\" state in memory. Sleep means the Chat was previously connected.\n     * @private\n     */\n    sleep() {\n\n        if (this.connected) {\n            this.onDisconnected();\n            this.asleep = true;\n        }\n    }\n\n    /**\n     * Called by {@link ChatEngine#reconnect}. Wakes the Chat up from sleep state.\n     * Re-authenticates with the server, and fires connection events once established.\n     * @private\n     */\n    wake() {\n\n        if (this.asleep) {\n            this.handshake(() => {\n                this.onConnected();\n            });\n        }\n\n    }\n\n    /**\n     * Fired upon successful connection to the network.\n     * @private\n     */\n    onConnected() {\n        this.connected = true;\n        this.trigger('$.connected');\n    }\n\n    /**\n     * Fires upon disconnection from the network through any means.\n     * @private\n     */\n    onDisconnected() {\n        this.connected = false;\n        this.trigger('$.disconnected');\n    }\n    /**\n     * Fires upon manually invoked leaving.\n     * @private\n     */\n    onLeave() {\n        this.trigger('$.left');\n        this.onDisconnected();\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}. Disconnects from the {@link Chat} and will stop\n     * receiving events.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        // tell the server we left\n        this.chatEngine.request('post', 'leave', { chat: this.objectify() })\n            .then(() => {\n\n                // trigger the disconnect events and update state\n                this.onLeave();\n\n                // tell the chat we've left\n                this.emit('$.system.leave', { subject: this.objectify() });\n\n                // tell session we've left\n                if (this.chatEngine.me.session) {\n                    this.chatEngine.me.session.leave(this);\n                }\n\n            })\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'chat', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        let user = this.users[uuid];\n        delete this.users[uuid];\n\n        // make sure this event is real, user may have already left\n        if (user) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', { user });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        }\n\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        let user = this.users[uuid];\n        delete this.users[uuid];\n\n        // make sure this event is real, user may have already left\n        if (user) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n             *     console.log('User disconnected from the network:', data.user);\n             * });\n             */\n            this.trigger('$.offline.disconnect', { user });\n\n        }\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    /**\n     Search through previously emitted events. Parameters act as AND operators. Returns an instance of the emitter based {@link History}. Will\n     which will emit all old events unless ```config.event``` is supplied.\n     @param {Object} [config] Our configuration for the PubNub history request. See the [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history) docs for more information on these parameters.\n     @param {Event} [config.event] The {@link Event} to search for.\n     @param {User} [config.sender] The {@link User} who sent the message.\n     @param {Number} [config.limit=20] The maximum number of results to return that match search criteria. Search will continue operating until it returns this number of results or it reached the end of history. Limit will be ignored in case if both 'start' and 'end' timetokens has been passed in search configuration.\n     @param {Number} [config.start=0] The timetoken to begin searching between.\n     @param {Number} [config.end=0] The timetoken to end searching between.\n     @param {Boolean} [config.reverse=false] Search oldest messages first.\n     @return {Search}\n     @example\n    chat.search({\n        event: 'my-custom-event',\n        sender: ChatEngine.me,\n        limit: 20\n    }).on('my-custom-event', (event) => {\n        console.log('this is an old event!', event);\n    }).on('$.search.finish', () => {\n        console.log('we have all our results!')\n    });\n     */\n    search(config) {\n\n        if (this.hasConnected) {\n            return new Search(this.chatEngine, this, config);\n        } else {\n            this.chatEngine.throwError(this, 'trigger', 'search', new Error('You must wait for the $.connected event before calling Chat#search'));\n        }\n\n    }\n\n    /**\n     * Fired when the chat first connects to network.\n     * @private\n     */\n    connectionReady() {\n\n        this.connected = true;\n        this.hasConnected = true;\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n         *     console.log('chat is ready to go!');\n         * });\n         */\n        this.onConnected();\n\n        if (this.chatEngine.me.session) {\n            this.chatEngine.me.session.join(this);\n        }\n\n        // add self to list of users\n        this.users[this.chatEngine.me.uuid] = this.chatEngine.me;\n\n        // trigger my own online event\n        this.trigger('$.online.join', {\n            user: this.chatEngine.me\n        });\n\n        // global channel updates are triggered manually, only get presence on custom chats\n        if (this.channel !== this.chatEngine.global.channel && this.group === 'custom') {\n\n            this.getUserUpdates();\n\n            // we may miss updates, so call this again 5 seconds later\n            setTimeout(() => {\n                this.getUserUpdates();\n            }, 5000);\n\n        }\n\n        this.on('$.system.leave', (payload) => {\n            this.userLeave(payload.sender.uuid);\n        });\n\n    }\n\n    /**\n     * Ask PubNub for information about {@link User}s in this {@link Chat}.\n     */\n    getUserUpdates() {\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, (s, r) => {\n            this.onHereNow(s, r);\n        });\n\n    }\n\n    /**\n     * Establish authentication with the server, then subscribe with PubNub.\n     * @return {[type]} [description]\n     */\n    connect() {\n\n        // establish good will with the server\n        this.handshake((response) => {\n\n            // asign metadata locally\n            if (response.data.found) {\n                this.meta = response.data.chat.meta;\n            } else {\n                this.update(this.meta);\n            }\n\n            // now that we've got connection, do everything else via connectionReady\n            this.connectionReady();\n\n        });\n\n    }\n\n    /**\n     * Connect to PubNub servers to initialize the chat.\n     * @example\n     * // create a new chatroom, but don't connect to it automatically\n     * let chat = new Chat('some-chat', false)\n     *\n     * // connect to the chat when we feel like it\n     * chat.connect();\n     */\n    handshake(callback) {\n\n        async.waterfall([\n            (next) => {\n                if (!this.chatEngine.pubnub) {\n                    next('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.');\n                } else {\n                    next();\n                }\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'grant', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('post', 'join', { chat: this.objectify() })\n                    .then(() => {\n                        next();\n                    })\n                    .catch(next);\n\n            },\n            (next) => {\n\n                this.chatEngine.request('get', 'chat', {}, { channel: this.channel })\n                    .then(callback)\n                    .catch(next);\n\n            }\n        ], (error) => {\n            this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":73,"identifier":"/Users/ian/Development/chat-engine/src/components/search.js","name":"./src/components/search.js","index":69,"index2":93,"size":7260,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":53,"issuerName":"./src/components/chat.js","profile":{"factory":27,"building":39,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":53,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/search","loc":"4:15-46"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\nconst eachSeries = require('async/eachSeries');\n/**\nReturned by {@link Chat#search}. This is our Search class which allows one to search the backlog of messages.\nPowered by [PubNub History](https://www.pubnub.com/docs/web-javascript/storage-and-history).\n@class Search\n@extends Emitter\n@extends RootEmitter\n@param {ChatEngine} chatEngine This instance of the {@link ChatEngine} object.\n@param {Chat} chat The {@link Chat} object to search.\n@param {Object} config The configuration object. See {@link Chat#search} for a list of parameters.\n*/\nclass Search extends Emitter {\n\n    constructor(chatEngine, chat, config = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n        Handy property to identify what this class is.\n        @type String\n        */\n        this.name = 'Search';\n\n        /**\n        The {@link Chat} used for searching.\n        @type Chat\n        */\n        this.chat = chat;\n\n        /**\n        An object containing configuration parameters supplied by {@link Chat#search}. See {@link Chat#search} for possible parameters.\n        @type {Object}\n        */\n        this.config = config;\n        this.config.event = config.event;\n        this.config.limit = config.limit || 20;\n        this.config.channel = this.chat.channel;\n        this.config.includeTimetoken = true;\n        this.config.stringifiedTimeToken = true;\n        this.config.count = this.config.count || 100;\n        this.config.pages = this.config.pages || 10;\n\n        /** @private */\n        this.maxPage = this.config.pages;\n        /** @private */\n        this.numPage = 0;\n\n        /** @private */\n        this.referenceDate = this.config.end || 0;\n\n        /**\n         * Flag which represent whether there is potentially more data available in {@link Chat} history. This flag can\n         * be used for conditional call of {@link Chat#search}.\n         * @type {boolean}\n         */\n        this.hasMore = true;\n        /** @private */\n        this.messagesBetweenTimetokens = this.config.start > '0' && this.config.end > '0';\n        /** @private */\n        this.needleCount = 0;\n\n        /**\n         * Call PubNub history in a loop.\n         * @private\n         */\n        this.page = (pageDone) => {\n            let searchConfiguration = Object.assign({}, this.config, { start: this.referenceDate });\n            delete searchConfiguration.reverse;\n            delete searchConfiguration.end;\n\n            /**\n             * Requesting another page from PubNub History.\n             * @event Search#$\".\"page\".\"request\n             */\n            this._emit('$.search.page.request');\n\n            this.chatEngine.pubnub.history(searchConfiguration, (status, response) => {\n\n                /**\n                 * PubNub History returned a response.\n                 * @event Search#$\".\"page\".\"response\n                 */\n                this._emit('$.search.page.response');\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    this.chatEngine.throwError(this, 'trigger', 'search', new Error('There was a problem searching history. Make sure your request parameters are valid and history is enabled for this PubNub key.'), status);\n                } else {\n                    const startDate = response.startTimeToken;\n                    this.referenceDate = response.startTimeToken;\n                    this.hasMore = response.messages.length === this.config.count && startDate !== '0';\n\n                    response.messages.sort((left, right) => (left.timetoken < right.timetoken ? -1 : 1));\n\n                    if (this.config.start && startDate < this.config.start) {\n                        this.hasMore = false;\n                        response.messages = response.messages.filter(event => event.timetoken >= this.config.start);\n                    }\n\n                    pageDone(response);\n                }\n\n            });\n        };\n\n        let eventFilter = (event) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n\n                            let matches = payload && payload.event && payload.event === event;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        let senderFilter = (user) => {\n            return {\n                middleware: {\n                    on: {\n                        '*': (payload, next) => {\n\n                            let matches = payload && payload.sender && payload.sender.uuid === user.uuid;\n                            next(!matches, payload);\n                        }\n                    }\n                }\n            };\n        };\n\n        /**\n         * @private\n         */\n        this.triggerHistory = (message, cb) => {\n\n            if (this.needleCount < this.config.limit || this.messagesBetweenTimetokens) {\n\n                message.entry.timetoken = message.timetoken;\n\n                this.trigger(message.entry.event, message.entry, (reject) => {\n\n                    if (!reject) {\n                        this.needleCount += 1;\n                    }\n                    cb();\n\n                });\n\n            } else {\n                cb();\n            }\n\n        };\n\n        this.next = () => {\n            if (this.hasMore) {\n                this.maxPage = this.maxPage + this.config.pages;\n\n                this.find();\n            } else {\n                this._emit('$.search.finish');\n            }\n        };\n\n        /**\n         * @private\n         */\n        this.find = () => {\n            this.page((response) => {\n                response.messages.reverse();\n\n                eachSeries(response.messages, this.triggerHistory, () => {\n                    if (this.hasMore && this.numPage === this.maxPage) {\n                        this._emit('$.search.pause');\n                    } else if (this.hasMore && (this.needleCount < this.config.limit || this.messagesBetweenTimetokens)) {\n\n                        this.numPage += 1;\n                        this.find();\n                    } else {\n                        if (this.needleCount >= this.config.limit && !this.messagesBetweenTimetokens) {\n                            this.hasMore = false;\n                        }\n\n                        /**\n                         * Search has returned all results or reached the end of history.\n                         * @event Search#$\".\"search\".\"finish\n                         */\n                        this._emit('$.search.finish');\n                    }\n                });\n            });\n\n            return this;\n        };\n\n        if (this.config.event) {\n            this.plugin(eventFilter(this.config.event));\n        }\n\n        if (this.config.sender) {\n            this.plugin(senderFilter(this.config.sender));\n        }\n\n        /**\n         * Search has started.\n         * @event Search#$\".\"search\".\"start\n         */\n        this._emit('$.search.start');\n        this.find();\n    }\n}\n\nmodule.exports = Search;\n"},{"id":98,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":97,"index2":97,"size":1790,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":30,"issuerName":"./src/bootstrap.js","profile":{"factory":13,"building":49,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":30,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"7:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\nconst Session = require('./session');\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @extends User\n @extends Emitter\n @extends RootEmitter\n @param {String} uuid The uuid of this user\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.chatEngine = chatEngine;\n\n        this.session = false;\n\n        this.name = 'Me';\n\n        if (this.chatEngine.ceConfig.enableSync) {\n            this.session = new Session(chatEngine);\n        }\n\n        return this;\n\n    }\n\n    /**\n     * assign updates from network\n     * @private\n     */\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state) {\n\n        // run the root update function\n        super.update(state);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n}\n\nmodule.exports = Me;\n"},{"id":99,"identifier":"/Users/ian/Development/chat-engine/src/components/session.js","name":"./src/components/session.js","index":99,"index2":96,"size":6133,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/me.js","issuerId":98,"issuerName":"./src/components/me.js","profile":{"factory":22,"building":29,"dependencies":0},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":98,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./session","loc":"2:16-36"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const Emitter = require('../modules/emitter');\n\nclass Session extends Emitter {\n\n    constructor(chatEngine) {\n\n        super(chatEngine);\n\n        this.name = 'Session';\n\n        this.chatEngine = chatEngine;\n\n        /**\n         * Stores a map of {@link Chat} objects that this {@link Me} has joined across all clients.\n         * @type {Object}\n         */\n        this.chats = {};\n\n        /**\n         * The {@link Chat} that syncs session between instances. Only connects\n         * if \"enableSync\" has been set to true in ceConfig.\n         * @type {this}\n         */\n        this.sync = null;\n\n    }\n\n    /**\n     * Forwards sync events from other instances into callback functions\n     * @private\n     */\n    subscribe() {\n\n        this.sync = new this.chatEngine.Chat([this.chatEngine.global.channel, 'user', this.chatEngine.me.uuid, 'me.', 'sync'].join('#'), false, this.chatEngine.ceConfig.enableSync, {}, 'system');\n\n        // subscribe to the events on our sync chat and forward them\n        this.sync.on('$.session.notify.chat.join', (payload) => {\n            this.onJoin(payload.data.subject);\n        });\n\n        this.sync.on('$.session.notify.chat.leave', (payload) => {\n            this.onleave(payload.data.subject);\n        });\n\n    }\n\n    /**\n     * Uses PubNub channel groups to restore a session for this uuid\n     * @private\n     */\n    restore() {\n\n        // these are custom groups that separate custom chats from system chats\n        // for better fitlering\n        let groups = ['custom', 'system'];\n\n        // loop through the groups\n        groups.forEach((group) => {\n\n            // generate the channel group string for PubNub using the current uuid\n            let channelGroup = [this.chatEngine.ceConfig.globalChannel, this.chatEngine.me.uuid, group].join('#');\n\n            // ask pubnub for a list of channels for this group\n            this.chatEngine.pubnub.channelGroups.listChannels({\n                channelGroup\n            }, (status, response) => {\n\n                if (status.error) {\n                    this.chatEngine.throwError(this.chatEngine, '_emit', 'sync', new Error('There was a problem restoring your session from PubNub servers.'), { status });\n                } else {\n\n                    // loop through the returned channels\n                    response.channels.forEach((channel) => {\n\n                        // call the same callback as if we were notified about them\n                        this.onJoin({\n                            channel,\n                            private: this.chatEngine.parseChannel(channel).private,\n                            group\n                        });\n\n                        /**\n                        Fired when session has been restored at boot. Fired once per\n                        session group.\n                        @event Me#$\".\"session\".\"group\".\"restored\n                        */\n                        this.trigger('$.group.restored', { group });\n\n                    });\n\n                }\n\n            });\n\n        });\n\n    }\n\n    /**\n     * Callback fired when another instance has joined a chat\n     * @private\n     */\n    join(chat) {\n\n        // don't rebroadcast chats in session we've already heard about\n        if (!this.chats[chat.group] || !this.chats[chat.group][chat.channel]) {\n            this.sync.emit('$.session.notify.chat.join', { subject: chat.objectify() });\n        }\n\n    }\n\n    /**\n     * Callback fired when another instance has left a chat\n     * @private\n     */\n    leave(chat) {\n        this.sync.emit('$.session.notify.chat.leave', { subject: chat.objectify() });\n    }\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    onJoin(chat) {\n\n        // create the chat group if it doesn't exist\n        this.chats[chat.group] = this.chats[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = this.chatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n\n            // assign it to the group\n            this.chats[chat.group][chat.channel] = existingChat;\n        } else {\n\n            // otherwise, try to recreate it with the server information\n            this.chats[chat.group][chat.channel] = new this.chatEngine.Chat(chat.channel, chat.private, false, chat.meta, chat.group);\n\n            /**\n            Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            ChatEngine stores sessions on the server side identified by {@link User#uuid}.\n            @event Me#$\".\"session\".\"chat\".\"join\n            @example\n            *\n            * // Logged in as \"Ian\" in first window\n            * ChatEngine.me.session.on('$.chat.join', (data) => {\n            *     console.log('I joined a new chat in a second window!', data.chat);\n            * });\n            *\n            * // Logged in as \"Ian\" in second window\n            * new ChatEngine.Chat('another-chat');\n            */\n            this.trigger('$.chat.join', { chat: this.chats[chat.group][chat.channel] });\n\n        }\n\n    }\n\n    /**\n    Removes {@link Chat} within this.chats\n    @private\n    */\n    onleave(chat) {\n\n        if (this.chats[chat.group] && this.chats[chat.group][chat.channel]) {\n\n            chat = this.chats[chat.group][chat.channel] || chat;\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} with an identical {@link Me} leaves a {@link Chat} via {@link Chat#leave}.\n            * @event Me#$\".\"session\".\"chat\".\"leave\n            */\n\n            delete this.chatEngine.chats[chat.channel];\n            delete this.chats[chat.group][chat.channel];\n\n        }\n\n        this.trigger('$.chat.leave', { chat });\n\n    }\n\n}\n\nmodule.exports = Session;\n"}],"filteredModules":87,"children":[]}