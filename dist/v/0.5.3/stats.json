{"errors":[],"warnings":[],"version":"3.6.0","hash":"0331a8c6c9e0d4d53298","publicPath":"","assetsByChunkName":{"main":"chat-engine.js"},"assets":[{"name":"chat-engine.js","size":228810,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"filteredAssets":0,"entrypoints":{"main":{"chunks":[0],"assets":["chat-engine.js"]}},"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":220844,"names":["main"],"files":["chat-engine.js"],"hash":"69303bcd517568f47b39","parents":[],"modules":[{"id":3,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":64,"index2":61,"size":5455,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":17,"dependencies":29},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/user","loc":"7:13-42"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"7:13-41"},{"moduleId":65,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const axios = require('axios');\n\nconst Emitter = require('../modules/emitter');\n\n/**\n This is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\n If a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n @class\n @extends Emitter\n @param uuid\n @param state\n @param chat\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state();\n         */\n        this.state = {};\n\n        /**\n         * An object containing the Chats this {@link User} is currently in. The key of each item in the object is the {@link Chat.channel} and the value is the {@link Chat} object. Note that for privacy, this map will only contain {@link Chat}s that the client ({@link Me}) is also connected to.\n         *\n         * @readonly\n         * @type Object\n         * @example\n         *{\n                *    \"globalChannel\": {\n                *        channel: \"globalChannel\",\n                *        users: {\n                *            //...\n                *        },\n                *    },\n                *    // ...\n                * }\n         */\n        this.chats = {};\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        const Chat = require('../components/chat');\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new Chat(chatEngine, [chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', 'feed');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n                *     console.log(payload.sender.uuid, 'sent your a direct message');\n                * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new Chat(chatEngine, [chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', 'direct');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n     adds a chat to this user\n\n     @private\n     */\n    addChat(chat, state) {\n\n        // store the chat in this user object\n        this.chats[chat.channel] = chat;\n\n        // updates the user's state in that chatroom\n        this.assign(state, chat);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(chat, callback) {\n        const url = 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + this.chatEngine.pnConfig.subscribeKey + '/state?globalChannel=' + this.chatEngine.ceConfig.globalChannel + '&uuid=' + this.uuid;\n        axios.get(url)\n            .then((response) => {\n                this.assign(response.data);\n                callback();\n            })\n            .catch(() => {\n                this.chatEngine.throwError(chat, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\n            });\n\n    }\n\n}\n\nmodule.exports = User;\n"},{"id":10,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":30,"index2":29,"size":3516,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":5,"building":11},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":16,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"1:20-45"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"4:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = this.emitter.off.bind(this.emitter);\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = this.emitter.onAny.bind(this.emitter);\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = this.emitter.once.bind(this.emitter);\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":11,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":32,"index2":62,"size":25897,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":6,"building":42,"dependencies":6},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../components/chat","loc":"75:21-50"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"5:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\nconst waterfall = require('async/waterfall');\nconst axios = require('axios');\n\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst User = require('../components/user');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [needGrant=true] This Chat has restricted permissions and we need to authenticate ourselves in order to connect.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n @extends Emitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\n @fires Chat#$\".\"offline\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), needGrant = true, autoConnect = true, group = 'default') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        /**\n         * A string identifier for the Chat room.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = channel.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (needGrant) {\n            chanPrivString = 'private.';\n        }\n\n        if (this.channel.indexOf(chatEngine.ceConfig.globalChannel) === -1) {\n            this.channel = [chatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        /**\n        * Does this chat require new {@link User}s to be granted explicit access to this room?\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = needGrant;\n\n        /**\n        * This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n        * @type String\n        * @readonly\n        */\n        this.group = group;\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         A map of {@link Event} bound to this {@link Chat}\n\n         @private\n         @type Object\n         @readonly\n         */\n        this.events = {};\n\n        /**\n         Updates list of {@link User}s in this {@link Chat}\n         based on who is online now.\n\n         @private\n         @param {Object} status The response status\n         @param {Object} response The response payload object\n         */\n        this.onHereNow = (status, response) => {\n\n            if (status.error) {\n\n                /**\n                 * There was a problem fetching the presence of this chat\n                 * @event Chat#$\".\"error\".\"presence\n                 */\n                chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), {\n                    error: status.errorData,\n                    errorText: status.errorData.response.text\n                });\n\n            } else {\n\n                // get the list of occupants in this channel\n                let occupants = response.channels[this.channel].occupants;\n\n                // format the userList for rltm.js standard\n                occupants.forEach((occupant) => {\n                    this.userUpdate(occupant.uuid, occupant.state);\n                });\n\n            }\n\n        };\n\n        /**\n         * Get messages that have been published to the network before this client was connected.\n         * Events are published with the ```$history``` prefix. So for example, if you had the event ```message```,\n         * you would call ```Chat.history('message')``` and subscribe to history events via ```chat.on('$history.message', (data) => {})```.\n         *\n         * @param {String} event The name of the event we're getting history for\n         * @param {Object} [config] The PubNub history config for this call\n         * @tutorial history\n         */\n        this.history = (event, config = {}) => {\n\n            // create the event if it does not exist\n            this.events[event] = this.events[event] || new Event(chatEngine, this, event);\n\n            // set the PubNub configured channel to this channel\n            config.channel = this.events[event].channel;\n\n            // run the PubNub history method for this event\n            chatEngine.pubnub.history(config, (status, response) => {\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    chatEngine.throwError(this, 'trigger', 'history', new Error('There was a problem fetching the history. Make sure history is enabled for this PubNub key.'), {\n                        errorText: status.errorData.response.text,\n                        error: status.error,\n                    });\n\n                } else {\n\n                    response.messages.forEach((message) => {\n\n                        if (message.entry.event === event) {\n\n                            /**\n                             * Fired by the {@link Chat#history} call. Emits old events again. Events are prepended with\n                             * ```$.history.``` to distinguish it from the original live events.\n                             * @event Chat#$\".\"history\".\"*\n                             * @tutorial history\n                             */\n                            this.trigger(['$', 'history', event].join('.'), message.entry);\n\n                        }\n\n                    });\n\n                }\n            });\n\n        };\n\n        /**\n        * Turns a {@link Chat} into a JSON representation.\n        * @return {Object}\n        */\n        this.objectify = () => {\n\n            return {\n                channel: this.channel,\n                group: this.group,\n                private: this.isPrivate\n            };\n\n        };\n\n        /**\n         * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n         * @param {User} user The {@link User} to invite to this chatroom.\n         * @fires Me#event:$\".\"invite\n         * @example\n         * // one user running ChatEngine\n         * let secretChat = new ChatEngine.Chat('secret-channel');\n         * secretChat.invite(someoneElse);\n         *\n         * // someoneElse in another instance of ChatEngine\n         * me.direct.on('$.invite', (payload) => {\n                *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n                * });\n         */\n        this.invite = (user) => {\n\n            let complete = () => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                                  *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                                  * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            };\n\n            axios.post(chatEngine.ceConfig.endpoint + '/chat/invite', {\n                authKey: chatEngine.pnConfig.authKey,\n                uuid: user.uuid,\n                myUUID: chatEngine.me.uuid,\n                authData: chatEngine.me.authData,\n                chat: this.objectify()\n            })\n                .then(() => {\n                    complete();\n                })\n                .catch((error) => {\n                    chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                });\n\n        };\n\n        /**\n         Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n         @private\n         @param {Object} data The PubNub presence response for this event\n         */\n        this.onPresence = (presenceEvent) => {\n\n            // make sure channel matches this channel\n            if (this.channel === presenceEvent.channel) {\n\n                // someone joins channel\n                if (presenceEvent.action === 'join') {\n\n                    let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n                    /**\n                     * Fired when a {@link User} has joined the room.\n                     *\n                     * @event Chat#$\".\"online\".\"join\n                     * @param {Object} data The payload returned by the event\n                     * @param {User} data.user The {@link User} that came online\n                     * @example\n                     * chat.on('$.join', (data) => {\n                                  *     console.log('User has joined the room!', data.user);\n                                  * });\n                     */\n                    this.trigger('$.online.join', { user });\n\n                }\n\n                // someone leaves channel\n                if (presenceEvent.action === 'leave') {\n                    this.userLeave(presenceEvent.uuid);\n                }\n\n                // someone timesout\n                if (presenceEvent.action === 'timeout') {\n                    this.userDisconnect(presenceEvent.uuid);\n                }\n\n                // someone's state is updated\n                if (presenceEvent.action === 'state-change') {\n                    this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n                }\n\n            }\n\n        };\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        /**\n         * @private\n         */\n        this.onPrep = () => {\n\n            if (!this.connected) {\n\n                if (!chatEngine.pubnub) {\n                    chatEngine.throwError(this, 'trigger', 'setup', new Error('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.'));\n                }\n\n                // listen to all PubNub events for this Chat\n                chatEngine.pubnub.addListener({\n                    message: this.onMessage,\n                    presence: this.onPresence\n                });\n\n                // subscribe to the PubNub channel for this Chat\n                chatEngine.pubnub.subscribe({\n                    channels: [this.channel],\n                    withPresence: true\n                });\n\n            }\n\n        };\n\n        /**\n         * @private\n         */\n        this.grant = () => {\n\n            let createChat = () => {\n\n                axios.post(chatEngine.ceConfig.endpoint + '/chats', {\n                    globalChannel: chatEngine.ceConfig.globalChannel,\n                    authKey: chatEngine.pnConfig.authKey,\n                    uuid: chatEngine.pnConfig.uuid,\n                    authData: chatEngine.me.authData,\n                    chat: this.objectify()\n                })\n                    .then(() => {\n                        this.onPrep();\n                    })\n                    .catch((error) => {\n                        chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                    });\n            };\n\n            axios.post(chatEngine.ceConfig.endpoint + '/chat/grant', {\n                globalChannel: chatEngine.ceConfig.globalChannel,\n                authKey: chatEngine.pnConfig.authKey,\n                uuid: chatEngine.pnConfig.uuid,\n                authData: chatEngine.me.authData,\n                chat: this.objectify()\n            })\n                .then(() => {\n                    createChat();\n                })\n                .catch((error) => {\n                    chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                });\n\n        };\n\n        /**\n         * Connect to PubNub servers to initialize the chat.\n         * @example\n         * // create a new chatroom, but don't connect to it automatically\n         * let chat = new Chat('some-chat', false)\n         *\n         * // connect to the chat when we feel like it\n         * chat.connect();\n         */\n        this.connect = () => {\n            this.grant();\n        };\n\n        if (autoConnect) {\n            this.grant();\n        }\n\n        chatEngine.chats[this.channel] = this;\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n          *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n          * });\n     */\n    emit(event, data) {\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n        };\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n\n            // ensure the event exists within the global space\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            this.events[event].publish(pluginResponse);\n\n        });\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n\n    trigger(event, payload) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (err, pluginResponse) => {\n                // emit this event to any listener\n                this._emit(event, pluginResponse);\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // this use already exists in memory\n                if (this.chatEngine.users[payload.sender]) {\n                    payload.sender = this.chatEngine.users[payload.sender];\n                    complete();\n                } else {\n\n                    // the user doesn't exist, create it\n                    payload.sender = new User(this.chatEngine, payload.sender);\n\n                    // try to get stored state from server\n                    payload.sender._getState(this, () => {\n                        console.log('state not set', payload.sender.state);\n                        complete();\n                    });\n\n                }\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new User(this.chatEngine, uuid);\n\n        this.chatEngine.users[uuid].addChat(this, state);\n\n        // trigger the join event over this chatroom\n        if (!this.users[uuid]) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // store this user in the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new User(this.chatEngine, uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        // delete the chat in the remote list\n        axios.delete(this.chatEngine.ceConfig.endpoint + '/chats', {\n            data: {\n                globalChannel: this.chatEngine.ceConfig.globalChannel,\n                authKey: this.chatEngine.pnConfig.authKey,\n                uuid: this.chatEngine.pnConfig.uuid,\n                authData: this.chatEngine.me.authData,\n                chat: this.objectify()\n            } })\n            .then(() => {})\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', {\n                user: this.users[uuid]\n            });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        } else {\n\n            // that user isn't in the user list\n            // we never knew about this user or they already left\n\n            // console.log('user already left');\n        }\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n                      *     console.log('User disconnected from the network:', data.user);\n                      * });\n             */\n\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\n        }\n\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location] && pluginItem.middleware[location][event]) {\n                // add the function to the queue\n                pluginQueue.push(pluginItem.middleware[location][event]);\n            }\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    onConnectionReady() {\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n                *     console.log('chat is ready to go!');\n                * });\n         */\n        this.connected = true;\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, (status, response) => {\n            // trigger that SDK is ready before emitting online events\n            this.trigger('$.connected');\n            this.onHereNow(status, response);\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":16,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":62,"index2":60,"size":2932,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/user.js","issuerId":3,"issuerName":"./src/components/user.js","profile":{"factory":30,"building":6,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"3:16-45"},{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"5:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and forwards\n events to the root emitter.\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n                *     console.log('event was fired').\n                * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n                *     console.log('event.a or event.b was fired').;\n                * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n        };\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Binds a plugin to this object\n         @param {Object} module The plugin module\n         */\n        this.plugin = (module) => {\n\n            // add this plugin to a list of plugins for this object\n            this.plugins.push(module);\n\n            // returns the name of this class\n            let className = this.constructor.name;\n\n            // see if there are plugins to attach to this class\n            if (module.extends && module.extends[className]) {\n\n                // attach the plugins to this class\n                // under their namespace\n                this.chatEngine.addChild(this, module.namespace, new module.extends[className]());\n\n                this[module.namespace].ChatEngine = this.chatEngine;\n\n                // if the plugin has a special construct function\n                // run it\n                if (this[module.namespace].construct) {\n                    this[module.namespace].construct();\n                }\n\n            }\n        };\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":17,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":63,"index2":59,"size":2061,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":11,"issuerName":"./src/components/chat.js","profile":{"factory":7,"building":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"6:14-44"},{"moduleId":16,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"2:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\n Represents an event that may be emitted or subscribed to.\n */\nclass Event {\n\n    constructor(chatEngine, chat, event) {\n\n        /**\n         Events are always a property of a {@link Chat}. Responsible for\n         listening to specific events and firing events when they occur.\n         @readonly\n         @type String\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = chat.channel;\n\n        /**\n         Publishes the event over the PubNub network to the {@link Event} channel\n\n         @private\n         @param {Object} data The event payload object\n         */\n        this.publish = (m) => {\n\n            m.event = event;\n\n            chatEngine.pubnub.publish({\n                message: m,\n                channel: this.channel\n            }, (status) => {\n\n                if (status.statusCode === 200) {\n                    chat.trigger('$.publish.success');\n                } else {\n                    /**\n                     * There was a problem publishing over the PubNub network.\n                     * @event Chat#$\".\"error\".\"publish\n                     */\n                    chatEngine.throwError(chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), {\n                        errorText: status.errorData.response.text,\n                        error: status.errorData,\n                    });\n                }\n\n            });\n\n        };\n\n        /**\n         Forwards events to the Chat that registered the event {@link Chat}\n\n         @private\n         @param {Object} data The event payload object\n         */\n        this.onMessage = (m) => {\n\n            if (this.channel === m.channel && m.message.event === event) {\n                chat.trigger(m.message.event, m.message);\n            }\n\n        };\n\n        // call onMessage when PubNub receives an event\n        chatEngine.pubnub.addListener({\n            message: this.onMessage\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n"},{"id":18,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":65,"size":1516,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":18,"building":17},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\nconst init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of chat engine specific config options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint] {String} The root URL used to manage permissions for private channels.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'demo',\n    subscribeKey: 'demo'\n}, {\n    endpoint: 'http://localhost/auth',\n    globalChannel: 'chat-engine-global-channel'\n});\n*/\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nmodule.exports = {\n    plugin: {}, // leave a spot for plugins to exist\n    create\n};\n"},{"id":19,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":64,"size":12800,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":18,"issuerName":"./src/index.js","profile":{"factory":3,"building":27},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":18,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\n\n/**\n Provides the base Widget class...\n\n @class ChatEngine\n @extends RootEmitter\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\n */\nmodule.exports = (ceConfig, pnConfig) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine\n     * @memberof ChatEngine\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n    * A map of {@link Chat}s that this instance of ChatEngine is representing.\n    * @type {Object}\n    */\n    ChatEngine.session = {};\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    ChatEngine.addChatToSession = (chat) => {\n\n        // create the chat if it doesn't exist\n        ChatEngine.session[chat.group] = ChatEngine.session[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = ChatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n            // assign it to the group\n            ChatEngine.session[chat.group][chat.channel] = existingChat;\n        } else {\n            // otherwise, try to recreate it with the server information\n            ChatEngine.session[chat.group][chat.channel] = new Chat(ChatEngine, chat.channel, chat.private, false, chat.group);\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            * Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            * @event ChatEngine#$\".\"session\".\"chat\".\"join\n            */\n            ChatEngine._emit('$.session.chat.join', {\n                chat: ChatEngine.session[chat.group][chat.channel]\n            });\n        }\n\n    };\n\n\n    /**\n    Removes {@link Chat} within ChatEngine.session\n    @private\n    */\n    ChatEngine.removeChatFromSession = (chat) => {\n\n        let targetChat = ChatEngine.session[chat.group][chat.channel] || chat;\n\n        /**\n        * Fired when another identical instance of {@link ChatEngine} and {@link Me} leaves a {@link Chat}.\n        * @event ChatEngine#$\".\"session\".\"chat\".\"leave\n        */\n        ChatEngine._emit('$.session.chat.leave', {\n            chat: targetChat\n        });\n\n        // don't delete from chatengine.chats, because we can still get events from this chat\n        delete ChatEngine.chats[chat.channel];\n        delete ChatEngine.session[chat.group][chat.channel];\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * * @param {Strung} authKey A authentication secret. Will be sent to authentication backend for validation. This is usually an access token or password. This is different from UUID as a user can have a single UUID but multiple auth keys.\n     * @param {Object} [authData] Additional data to send to the authentication endpoint. Not used by ChatEngine SDK.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n\n        pnConfig.uuid = uuid;\n\n        let complete = (chatData) => {\n\n            ChatEngine.pubnub = new PubNub(pnConfig);\n\n            // create a new chat to use as global chat\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\n            ChatEngine.global = new Chat(ChatEngine, ceConfig.globalChannel, false, true, 'global');\n\n            // create a new user that represents this client\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\n\n            // create a new instance of Me using input parameters\n            ChatEngine.global.createUser(pnConfig.uuid, state);\n\n            ChatEngine.me.update(state);\n\n\n            /**\n             *  Fired when ChatEngine is connected to the internet and ready to go!\n             * @event ChatEngine#$\".\"ready\n             */\n            ChatEngine.global.on('$.connected', () => {\n\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.ready = true;\n\n                chatData.forEach((chatItem) => {\n                    ChatEngine.addChatToSession(chatItem);\n                });\n            });\n\n            // chats.session =\n\n            /**\n             Fires when PubNub network connection changes\n\n             @private\n             @param {Object} statusEvent The response status\n             */\n            ChatEngine.pubnub.addListener({\n                status: (statusEvent) => {\n\n                    /**\n                     * SDK detected that network is online.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\n                     */\n\n                    /**\n                     * SDK detected that network is down.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                     */\n\n                    /**\n                     * A subscribe event experienced an exception when running.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                     */\n\n                    /**\n                     * SDK was able to reconnect to pubnub.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                     */\n\n                    /**\n                     * SDK subscribed with a new mix of channels.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                     */\n\n                    /**\n                     * JSON parsing crashed.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                     */\n\n                    /**\n                     * Server rejected the request.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                     */\n\n                    /**\n                     * If using decryption strategies and the decryption fails.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                     */\n\n                    /**\n                     * Request timed out.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                     */\n\n                    /**\n                     * PAM permission failure.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                     */\n\n                    // map the pubnub events into chat engine events\n                    let categories = {\n                        PNNetworkUpCategory: 'up.online',\n                        PNNetworkDownCategory: 'down.offline',\n                        PNNetworkIssuesCategory: 'down.issue',\n                        PNReconnectedCategory: 'up.reconnected',\n                        PNConnectedCategory: 'up.connected',\n                        PNAccessDeniedCategory: 'down.denied',\n                        PNMalformedResponseCategory: 'down.malformed',\n                        PNBadRequestCategory: 'down.badrequest',\n                        PNDecryptionErrorCategory: 'down.decryption',\n                        PNTimeoutCategory: 'down.timeout'\n                    };\n\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                    if (statusEvent.affectedChannels) {\n                        statusEvent.affectedChannels.forEach((channel) => {\n                            let chat = ChatEngine.chats[channel];\n\n                            if (chat) {\n                                // connected category tells us the chat is ready\n                                if (statusEvent.category === 'PNConnectedCategory') {\n                                    chat.onConnectionReady();\n                                }\n\n                                // trigger the network events\n                                chat.trigger(eventName, statusEvent);\n                            } else {\n                                ChatEngine._emit(eventName, statusEvent);\n                            }\n                        });\n                    } else {\n                        ChatEngine._emit(eventName, statusEvent);\n                    }\n                }\n            });\n        };\n\n        let getChats = () => {\n\n            axios.get(ceConfig.endpoint + '/chats?uuid=' + pnConfig.uuid)\n                .then((response) => { complete(response.data); })\n                .catch((error) => {\n\n                    /**\n                     * There was a problem logging in\n                     * @event ChatEngine#$\".\"error\".\"session\n                     */\n                    ChatEngine.throwError(ChatEngine, '_emit', 'session', new Error('There was a problem getting session from the server (' + ceConfig.endpoint + ').'), {\n                        error\n                    });\n\n                });\n        };\n\n        pnConfig.authKey = authKey;\n\n        axios.post(ceConfig.endpoint + '/grant', {\n            uuid: pnConfig.uuid,\n            channel: ceConfig.globalChannel,\n            authData: ChatEngine.me.authData,\n            authKey: pnConfig.authKey\n        })\n            .then((response) => { getChats(response.data); })\n            .catch((error) => {\n\n                /**\n                 * There was a problem logging in\n                 * @event ChatEngine#$\".\"error\".\"auth\n                 */\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\n            });\n\n    };\n\n    /**\n     * The {@link Chat} class.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = class extends Chat {\n        constructor(...args) {\n            super(ChatEngine, ...args);\n        }\n    };\n\n    /**\n     * The {@link User} class.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = class extends User {\n        constructor(...args) {\n\n            if (ChatEngine.me.uuid === args[0]) {\n                return ChatEngine.me;\n            } else {\n                super(ChatEngine, ...args);\n            }\n\n        }\n    };\n\n    // add an object as a subobject under a namespoace\n    ChatEngine.addChild = (ob, childName, childOb) => {\n\n        // assign the new child object as a property of parent under the\n        // given namespace\n        ob[childName] = childOb;\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = ob;\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":56,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":52,"index2":37,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","issuerId":55,"issuerName":"./node_modules/lodash/_freeGlobal.js","profile":{"factory":7,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":14,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":65,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":65,"index2":63,"size":1836,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":12,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"6:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\n\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @param {String} uuid The uuid of this user\n @extends User\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid, authData) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.authData = authData;\n        this.chatEngine = chatEngine;\n\n        this.direct.on('$.server.chat.created', (payload) => {\n            chatEngine.addChatToSession(payload.chat);\n        });\n\n\n        this.direct.on('$.server.chat.deleted', (payload) => {\n            chatEngine.removeChatFromSession(payload.chat);\n        });\n\n    }\n\n    // assign updates from network\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state, chat = this.chatEngine.global) {\n\n        // run the root update function\n        super.update(state, chat);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n}\n\nmodule.exports = Me;\n"}],"filteredModules":57,"origins":[{"moduleId":18,"module":"/Users/ian/Development/chat-engine/src/index.js","moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":3,"identifier":"/Users/ian/Development/chat-engine/src/components/user.js","name":"./src/components/user.js","index":64,"index2":61,"size":5455,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":17,"dependencies":29},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/user","loc":"7:13-42"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/user","loc":"7:13-41"},{"moduleId":65,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/me.js","module":"./src/components/me.js","moduleName":"./src/components/me.js","type":"cjs require","userRequest":"./user","loc":"1:13-30"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const axios = require('axios');\n\nconst Emitter = require('../modules/emitter');\n\n/**\n This is our User class which represents a connected client. User's are automatically created and managed by {@link Chat}s, but you can also instantiate them yourself.\n If a User has been created but has never been authenticated, you will recieve 403s when connecting to their feed or direct Chats.\n @class\n @extends Emitter\n @param uuid\n @param state\n @param chat\n */\nclass User extends Emitter {\n\n    constructor(chatEngine, uuid, state = {}) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n         The User's unique identifier, usually a device uuid. This helps ChatEngine identify the user between events. This is public id exposed to the network.\n         Check out [the wikipedia page on UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n         @readonly\n         @type String\n         */\n        this.uuid = uuid;\n\n        /**\n         * Gets the user state. See {@link Me#update} for how to assign state values.\n         * @return {Object} Returns a generic JSON object containing state information.\n         * @example\n         *\n         * // State\n         * let state = user.state();\n         */\n        this.state = {};\n\n        /**\n         * An object containing the Chats this {@link User} is currently in. The key of each item in the object is the {@link Chat.channel} and the value is the {@link Chat} object. Note that for privacy, this map will only contain {@link Chat}s that the client ({@link Me}) is also connected to.\n         *\n         * @readonly\n         * @type Object\n         * @example\n         *{\n                *    \"globalChannel\": {\n                *        channel: \"globalChannel\",\n                *        users: {\n                *            //...\n                *        },\n                *    },\n                *    // ...\n                * }\n         */\n        this.chats = {};\n\n        /**\n         * Feed is a Chat that only streams things a User does, like\n         * 'startTyping' or 'idle' events for example. Anybody can subscribe\n         * to a User's feed, but only the User can publish to it. Users will\n         * not be able to converse in this channel.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.feed.emit('update', 'I may be away from my computer right now');\n         *\n         * // another instance\n         * them.feed.connect();\n         * them.feed.on('update', (payload) => {})\n         */\n\n        const Chat = require('../components/chat');\n\n        // grants for these chats are done on auth. Even though they're marked private, they are locked down via the server\n        this.feed = new Chat(chatEngine, [chatEngine.global.channel, 'user', uuid, 'read.', 'feed'].join('#'), false, this.constructor.name === 'Me', 'feed');\n\n        /**\n         * Direct is a private channel that anybody can publish to but only\n         * the user can subscribe to. Great for pushing notifications or\n         * inviting to other chats. Users will not be able to communicate\n         * with one another inside of this chat. Check out the\n         * {@link Chat#invite} method for private chats utilizing\n         * {@link User#direct}.\n         *\n         * @type Chat\n         * @example\n         * // me\n         * me.direct.on('private-message', (payload) -> {\n                *     console.log(payload.sender.uuid, 'sent your a direct message');\n                * });\n         *\n         * // another instance\n         * them.direct.connect();\n         * them.direct.emit('private-message', {secret: 42});\n         */\n        this.direct = new Chat(chatEngine, [chatEngine.global.channel, 'user', uuid, 'write.', 'direct'].join('#'), false, this.constructor.name === 'Me', 'direct');\n\n        // if the user does not exist at all and we get enough\n        // information to build the user\n        if (!chatEngine.users[uuid]) {\n            chatEngine.users[uuid] = this;\n        }\n\n        // update this user's state in it's created context\n        this.assign(state);\n\n    }\n\n    /**\n     * @private\n     * @param {Object} state The new state for the user\n     * @param {Chat} chat Chatroom to retrieve state from\n     */\n    update(state) {\n        let oldState = this.state || {};\n        this.state = Object.assign(oldState, state);\n    }\n\n    /**\n     this is only called from network updates\n\n     @private\n     */\n    assign(state) {\n        this.update(state);\n    }\n\n    /**\n     adds a chat to this user\n\n     @private\n     */\n    addChat(chat, state) {\n\n        // store the chat in this user object\n        this.chats[chat.channel] = chat;\n\n        // updates the user's state in that chatroom\n        this.assign(state, chat);\n    }\n\n    /**\n    Get stored user state from remote server.\n    @private\n    */\n    _getState(chat, callback) {\n        const url = 'https://pubsub.pubnub.com/v1/blocks/sub-key/' + this.chatEngine.pnConfig.subscribeKey + '/state?globalChannel=' + this.chatEngine.ceConfig.globalChannel + '&uuid=' + this.uuid;\n        axios.get(url)\n            .then((response) => {\n                this.assign(response.data);\n                callback();\n            })\n            .catch(() => {\n                this.chatEngine.throwError(chat, 'trigger', 'getState', new Error('There was a problem getting state from the PubNub network.'));\n            });\n\n    }\n\n}\n\nmodule.exports = User;\n"},{"id":10,"identifier":"/Users/ian/Development/chat-engine/src/modules/root_emitter.js","name":"./src/modules/root_emitter.js","index":30,"index2":29,"size":3516,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":5,"building":11},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":16,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"./root_emitter","loc":"1:20-45"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./modules/root_emitter","loc":"4:20-53"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\n// Allows us to create and bind to events. Everything in ChatEngine is an event\n// emitter\nconst EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n* The {@link ChatEngine} object is a RootEmitter. Configures an event emitter that other ChatEngine objects inherit. Adds shortcut methods for\n* ```this.on()```, ```this.emit()```, etc.\n*/\nclass RootEmitter {\n\n    constructor() {\n\n        /**\n        * @private\n        */\n        this.events = {};\n\n        /**\n        Create a new EventEmitter2 object for this class.\n\n        @private\n        */\n        this.emitter = new EventEmitter2({\n            wildcard: true,\n            newListener: true,\n            maxListeners: 50,\n            verboseMemoryLeak: true\n        });\n\n        // we bind to make sure wildcards work\n        // https://github.com/asyncly/EventEmitter2/issues/186\n\n        /**\n        Private emit method that broadcasts the event to listeners on this page.\n\n        @private\n        @param {String} event The event name\n        @param {Object} the event payload\n        */\n        this._emit = this.emitter.emit.bind(this.emitter);\n\n        /**\n        Listen for a specific event and fire a callback when it's emitted. This is reserved in case ```this.on``` is overwritten.\n\n        @private\n        @param {String} event The event name\n        @param {Function} callback The function to run when the event is emitted\n        */\n\n        this._on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n        * @method\n        * @param {String} event The event name\n        * @param {Function} cb The function to run when the event is emitted\n        * @example\n        *\n        * // Get notified whenever someone joins the room\n        * object.on('event', (payload) => {\n        *     console.log('event was fired').\n        * })\n        *\n        * // Get notified of event.a and event.b\n        * object.on('event.*', (payload) => {\n        *     console.log('event.a or event.b was fired').;\n        * })\n        */\n        this.on = this.emitter.on.bind(this.emitter);\n\n        /**\n        * Stop a callback from listening to an event.\n        * @method\n        * @param {String} event The event name\n        * @example\n        * let callback = function(payload;) {\n        *    console.log('something happend!');\n        * };\n        * object.on('event', callback);\n        * // ...\n        * object.off('event', callback);\n        */\n        this.off = this.emitter.off.bind(this.emitter);\n\n        /**\n        * Listen for any event on this object and fire a callback when it's emitted\n        * @method\n        * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.\n        * @example\n        * object.onAny((event, payload) => {\n        *     console.log('All events trigger this.');\n        * });\n        */\n        this.onAny = this.emitter.onAny.bind(this.emitter);\n\n        /**\n        * Listen for an event and only fire the callback a single time\n        * @method\n        * @param {String} event The event name\n        * @param {Function} callback The function to run once\n        * @example\n        * object.once('message', => (event, payload) {\n        *     console.log('This is only fired once!');\n        * });\n        */\n        this.once = this.emitter.once.bind(this.emitter);\n\n    }\n\n}\n\nmodule.exports = RootEmitter;\n"},{"id":11,"identifier":"/Users/ian/Development/chat-engine/src/components/chat.js","name":"./src/components/chat.js","index":32,"index2":62,"size":25897,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":6,"building":42,"dependencies":6},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../components/chat","loc":"75:21-50"},{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/chat","loc":"5:13-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"\nconst waterfall = require('async/waterfall');\nconst axios = require('axios');\n\nconst Emitter = require('../modules/emitter');\nconst Event = require('../components/event');\nconst User = require('../components/user');\n\n/**\n This is the root {@link Chat} class that represents a chat room\n\n @param {String} [channel=new Date().getTime()] A unique identifier for this chat {@link Chat}. The channel is the unique name of a {@link Chat}, and is usually something like \"The Watercooler\", \"Support\", or \"Off Topic\". See [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-).\n @param {Boolean} [needGrant=true] This Chat has restricted permissions and we need to authenticate ourselves in order to connect.\n @param {Boolean} [autoConnect=true] Connect to this chat as soon as its initiated. If set to ```false```, call the {@link Chat#connect} method to connect to this {@link Chat}.\n @param {String} [group='default'] Groups chat into a \"type\". This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n @extends Emitter\n @fires Chat#$\".\"ready\n @fires Chat#$\".\"state\n @fires Chat#$\".\"online\n @fires Chat#$\".\"offline\n */\nclass Chat extends Emitter {\n\n    constructor(chatEngine, channel = new Date().getTime(), needGrant = true, autoConnect = true, group = 'default') {\n\n        super(chatEngine);\n\n        this.chatEngine = chatEngine;\n\n        /**\n         * A string identifier for the Chat room.\n         * @type String\n         * @readonly\n         * @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = channel.toString();\n\n        // public.* has PubNub permissions for everyone to read and write\n        // private.* is totally locked down and users must be granted access one by one\n        let chanPrivString = 'public.';\n\n        if (needGrant) {\n            chanPrivString = 'private.';\n        }\n\n        if (this.channel.indexOf(chatEngine.ceConfig.globalChannel) === -1) {\n            this.channel = [chatEngine.ceConfig.globalChannel, 'chat', chanPrivString, channel].join('#');\n        }\n\n        /**\n        * Does this chat require new {@link User}s to be granted explicit access to this room?\n        * @type Boolean\n        * @readonly\n        */\n        this.isPrivate = needGrant;\n\n        /**\n        * This is the key which chats will be grouped into within {@link ChatEngine.session} object.\n        * @type String\n        * @readonly\n        */\n        this.group = group;\n\n        /**\n         A list of users in this {@link Chat}. Automatically kept in sync as users join and leave the chat.\n         Use [$.join](/Chat.html#event:$%2522.%2522join) and related events to get notified when this changes\n\n         @type Object\n         @readonly\n         */\n        this.users = {};\n\n        /**\n         A map of {@link Event} bound to this {@link Chat}\n\n         @private\n         @type Object\n         @readonly\n         */\n        this.events = {};\n\n        /**\n         Updates list of {@link User}s in this {@link Chat}\n         based on who is online now.\n\n         @private\n         @param {Object} status The response status\n         @param {Object} response The response payload object\n         */\n        this.onHereNow = (status, response) => {\n\n            if (status.error) {\n\n                /**\n                 * There was a problem fetching the presence of this chat\n                 * @event Chat#$\".\"error\".\"presence\n                 */\n                chatEngine.throwError(this, 'trigger', 'presence', new Error('Getting presence of this Chat. Make sure PubNub presence is enabled for this key'), {\n                    error: status.errorData,\n                    errorText: status.errorData.response.text\n                });\n\n            } else {\n\n                // get the list of occupants in this channel\n                let occupants = response.channels[this.channel].occupants;\n\n                // format the userList for rltm.js standard\n                occupants.forEach((occupant) => {\n                    this.userUpdate(occupant.uuid, occupant.state);\n                });\n\n            }\n\n        };\n\n        /**\n         * Get messages that have been published to the network before this client was connected.\n         * Events are published with the ```$history``` prefix. So for example, if you had the event ```message```,\n         * you would call ```Chat.history('message')``` and subscribe to history events via ```chat.on('$history.message', (data) => {})```.\n         *\n         * @param {String} event The name of the event we're getting history for\n         * @param {Object} [config] The PubNub history config for this call\n         * @tutorial history\n         */\n        this.history = (event, config = {}) => {\n\n            // create the event if it does not exist\n            this.events[event] = this.events[event] || new Event(chatEngine, this, event);\n\n            // set the PubNub configured channel to this channel\n            config.channel = this.events[event].channel;\n\n            // run the PubNub history method for this event\n            chatEngine.pubnub.history(config, (status, response) => {\n\n                if (status.error) {\n\n                    /**\n                     * There was a problem fetching the history of this chat\n                     * @event Chat#$\".\"error\".\"history\n                     */\n                    chatEngine.throwError(this, 'trigger', 'history', new Error('There was a problem fetching the history. Make sure history is enabled for this PubNub key.'), {\n                        errorText: status.errorData.response.text,\n                        error: status.error,\n                    });\n\n                } else {\n\n                    response.messages.forEach((message) => {\n\n                        if (message.entry.event === event) {\n\n                            /**\n                             * Fired by the {@link Chat#history} call. Emits old events again. Events are prepended with\n                             * ```$.history.``` to distinguish it from the original live events.\n                             * @event Chat#$\".\"history\".\"*\n                             * @tutorial history\n                             */\n                            this.trigger(['$', 'history', event].join('.'), message.entry);\n\n                        }\n\n                    });\n\n                }\n            });\n\n        };\n\n        /**\n        * Turns a {@link Chat} into a JSON representation.\n        * @return {Object}\n        */\n        this.objectify = () => {\n\n            return {\n                channel: this.channel,\n                group: this.group,\n                private: this.isPrivate\n            };\n\n        };\n\n        /**\n         * Invite a user to this Chat. Authorizes the invited user in the Chat and sends them an invite via {@link User#direct}.\n         * @param {User} user The {@link User} to invite to this chatroom.\n         * @fires Me#event:$\".\"invite\n         * @example\n         * // one user running ChatEngine\n         * let secretChat = new ChatEngine.Chat('secret-channel');\n         * secretChat.invite(someoneElse);\n         *\n         * // someoneElse in another instance of ChatEngine\n         * me.direct.on('$.invite', (payload) => {\n                *     let secretChat = new ChatEngine.Chat(payload.data.channel);\n                * });\n         */\n        this.invite = (user) => {\n\n            let complete = () => {\n\n                let send = () => {\n\n                    /**\n                     * Notifies {@link Me} that they've been invited to a new private {@link Chat}.\n                     * Fired by the {@link Chat#invite} method.\n                     * @event Me#$\".\"invite\n                     * @tutorial private\n                     * @example\n                     * me.direct.on('$.invite', (payload) => {\n                                  *    let privChat = new ChatEngine.Chat(payload.data.channel));\n                                  * });\n                     */\n                    user.direct.emit('$.invite', {\n                        channel: this.channel\n                    });\n\n                };\n\n                if (!user.direct.connected) {\n                    user.direct.connect();\n                    user.direct.on('$.connected', send);\n                } else {\n                    send();\n                }\n\n            };\n\n            axios.post(chatEngine.ceConfig.endpoint + '/chat/invite', {\n                authKey: chatEngine.pnConfig.authKey,\n                uuid: user.uuid,\n                myUUID: chatEngine.me.uuid,\n                authData: chatEngine.me.authData,\n                chat: this.objectify()\n            })\n                .then(() => {\n                    complete();\n                })\n                .catch((error) => {\n                    chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                });\n\n        };\n\n        /**\n         Keep track of {@link User}s in the room by subscribing to PubNub presence events.\n\n         @private\n         @param {Object} data The PubNub presence response for this event\n         */\n        this.onPresence = (presenceEvent) => {\n\n            // make sure channel matches this channel\n            if (this.channel === presenceEvent.channel) {\n\n                // someone joins channel\n                if (presenceEvent.action === 'join') {\n\n                    let user = this.createUser(presenceEvent.uuid, presenceEvent.state);\n\n                    /**\n                     * Fired when a {@link User} has joined the room.\n                     *\n                     * @event Chat#$\".\"online\".\"join\n                     * @param {Object} data The payload returned by the event\n                     * @param {User} data.user The {@link User} that came online\n                     * @example\n                     * chat.on('$.join', (data) => {\n                                  *     console.log('User has joined the room!', data.user);\n                                  * });\n                     */\n                    this.trigger('$.online.join', { user });\n\n                }\n\n                // someone leaves channel\n                if (presenceEvent.action === 'leave') {\n                    this.userLeave(presenceEvent.uuid);\n                }\n\n                // someone timesout\n                if (presenceEvent.action === 'timeout') {\n                    this.userDisconnect(presenceEvent.uuid);\n                }\n\n                // someone's state is updated\n                if (presenceEvent.action === 'state-change') {\n                    this.userUpdate(presenceEvent.uuid, presenceEvent.state);\n                }\n\n            }\n\n        };\n\n        /**\n         * Boolean value that indicates of the Chat is connected to the network\n         * @type {Boolean}\n         */\n        this.connected = false;\n\n        /**\n         * @private\n         */\n        this.onPrep = () => {\n\n            if (!this.connected) {\n\n                if (!chatEngine.pubnub) {\n                    chatEngine.throwError(this, 'trigger', 'setup', new Error('You must call ChatEngine.connect() and wait for the $.ready event before creating new Chats.'));\n                }\n\n                // listen to all PubNub events for this Chat\n                chatEngine.pubnub.addListener({\n                    message: this.onMessage,\n                    presence: this.onPresence\n                });\n\n                // subscribe to the PubNub channel for this Chat\n                chatEngine.pubnub.subscribe({\n                    channels: [this.channel],\n                    withPresence: true\n                });\n\n            }\n\n        };\n\n        /**\n         * @private\n         */\n        this.grant = () => {\n\n            let createChat = () => {\n\n                axios.post(chatEngine.ceConfig.endpoint + '/chats', {\n                    globalChannel: chatEngine.ceConfig.globalChannel,\n                    authKey: chatEngine.pnConfig.authKey,\n                    uuid: chatEngine.pnConfig.uuid,\n                    authData: chatEngine.me.authData,\n                    chat: this.objectify()\n                })\n                    .then(() => {\n                        this.onPrep();\n                    })\n                    .catch((error) => {\n                        chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                    });\n            };\n\n            axios.post(chatEngine.ceConfig.endpoint + '/chat/grant', {\n                globalChannel: chatEngine.ceConfig.globalChannel,\n                authKey: chatEngine.pnConfig.authKey,\n                uuid: chatEngine.pnConfig.uuid,\n                authData: chatEngine.me.authData,\n                chat: this.objectify()\n            })\n                .then(() => {\n                    createChat();\n                })\n                .catch((error) => {\n                    chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to authentication server.'), { error });\n                });\n\n        };\n\n        /**\n         * Connect to PubNub servers to initialize the chat.\n         * @example\n         * // create a new chatroom, but don't connect to it automatically\n         * let chat = new Chat('some-chat', false)\n         *\n         * // connect to the chat when we feel like it\n         * chat.connect();\n         */\n        this.connect = () => {\n            this.grant();\n        };\n\n        if (autoConnect) {\n            this.grant();\n        }\n\n        chatEngine.chats[this.channel] = this;\n\n    }\n\n    /**\n     * Send events to other clients in this {@link User}.\n     * Events are trigger over the network  and all events are made\n     * on behalf of {@link Me}\n     *\n     * @param {String} event The event name\n     * @param {Object} data The event payload object\n     * @example\n     * chat.emit('custom-event', {value: true});\n     * chat.on('custom-event', (payload) => {\n          *     console.log(payload.sender.uuid, 'emitted the value', payload.data.value);\n          * });\n     */\n    emit(event, data) {\n\n        // create a standardized payload object\n        let payload = {\n            data, // the data supplied from params\n            sender: this.chatEngine.me.uuid, // my own uuid\n            chat: this, // an instance of this chat\n        };\n\n        // run the plugin queue to modify the event\n        this.runPluginQueue('emit', event, (next) => {\n            next(null, payload);\n        }, (err, pluginResponse) => {\n\n            // remove chat otherwise it would be serialized\n            // instead, it's rebuilt on the other end.\n            // see this.trigger\n            delete pluginResponse.chat;\n\n            // publish the event and data over the configured channel\n\n            // ensure the event exists within the global space\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            this.events[event].publish(pluginResponse);\n\n        });\n\n    }\n\n    /**\n     Broadcasts an event locally to all listeners.\n\n     @private\n     @param {String} event The event name\n     @param {Object} payload The event payload object\n     */\n\n    trigger(event, payload) {\n\n        let complete = () => {\n\n            // let plugins modify the event\n            this.runPluginQueue('on', event, (next) => {\n                next(null, payload);\n            }, (err, pluginResponse) => {\n                // emit this event to any listener\n                this._emit(event, pluginResponse);\n            });\n\n        };\n\n        // this can be made into plugin\n        if (typeof payload === 'object') {\n\n            // restore chat in payload\n            if (!payload.chat) {\n                payload.chat = this;\n            }\n\n            // if we should try to restore the sender property\n            if (payload.sender) {\n\n                // this use already exists in memory\n                if (this.chatEngine.users[payload.sender]) {\n                    payload.sender = this.chatEngine.users[payload.sender];\n                    complete();\n                } else {\n\n                    // the user doesn't exist, create it\n                    payload.sender = new User(this.chatEngine, payload.sender);\n\n                    // try to get stored state from server\n                    payload.sender._getState(this, () => {\n                        console.log('state not set', payload.sender.state);\n                        complete();\n                    });\n\n                }\n\n            } else {\n                // there's no \"sender\" in this object, move on\n                complete();\n            }\n\n        } else {\n            // payload is not an object, we want nothing to do with it.\n            complete();\n        }\n\n    }\n\n    /**\n     Add a user to the {@link Chat}, creating it if it doesn't already exist.\n\n     @private\n     @param {String} uuid The user uuid\n     @param {Object} state The user initial state\n     @param {Boolean} trigger Force a trigger that this user is online\n     */\n    createUser(uuid, state) {\n\n        // Ensure that this user exists in the global list\n        // so we can reference it from here out\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new User(this.chatEngine, uuid);\n\n        this.chatEngine.users[uuid].addChat(this, state);\n\n        // trigger the join event over this chatroom\n        if (!this.users[uuid]) {\n\n            /**\n             * Broadcast that a {@link User} has come online. This is when\n             * the framework firsts learn of a user. This can be triggered\n             * by, ```$.join```, or other network events that\n             * notify the framework of a new user.\n             *\n             * @event Chat#$\".\"online\".\"here\n             * @param {Object} data The payload returned by the event\n             * @param {User} data.user The {@link User} that came online\n             * @example\n             * chat.on('$.online.here', (data) => {\n                      *     console.log('User has come online:', data.user);\n                      * });\n             */\n            this.trigger('$.online.here', {\n                user: this.chatEngine.users[uuid]\n            });\n\n        }\n\n        // store this user in the chatroom\n        this.users[uuid] = this.chatEngine.users[uuid];\n\n        // return the instance of this user\n        return this.chatEngine.users[uuid];\n\n    }\n\n    /**\n     * Update a user's state.\n     * @private\n     * @param {String} uuid The {@link User} uuid\n     * @param {Object} state State to update for the user\n     */\n    userUpdate(uuid, state) {\n\n        // ensure the user exists within the global space\n        this.chatEngine.users[uuid] = this.chatEngine.users[uuid] || new User(this.chatEngine, uuid);\n\n        // if we don't know about this user\n        if (!this.users[uuid]) {\n            // do the whole join thing\n            this.createUser(uuid, state);\n        }\n\n        // update this user's state in this chatroom\n        this.users[uuid].assign(state);\n\n        /**\n         * Broadcast that a {@link User} has changed state.\n         * @event ChatEngine#$\".\"state\n         * @param {Object} data The payload returned by the event\n         * @param {User} data.user The {@link User} that changed state\n         * @param {Object} data.state The new user state\n         * @example\n         * ChatEngine.on('$.state', (data) => {\n         *     console.log('User has changed state:', data.user, 'new state:', data.state);\n         * });\n         */\n        this.chatEngine._emit('$.state', {\n            user: this.users[uuid],\n            state: this.users[uuid].state\n        });\n\n    }\n\n    /**\n     * Leave from the {@link Chat} on behalf of {@link Me}.\n     * @fires Chat#event:$\".\"offline\".\"leave\n     * @example\n     * chat.leave();\n     */\n    leave() {\n\n        // unsubscribe from the channel locally\n        this.chatEngine.pubnub.unsubscribe({\n            channels: [this.channel]\n        });\n\n        // delete the chat in the remote list\n        axios.delete(this.chatEngine.ceConfig.endpoint + '/chats', {\n            data: {\n                globalChannel: this.chatEngine.ceConfig.globalChannel,\n                authKey: this.chatEngine.pnConfig.authKey,\n                uuid: this.chatEngine.pnConfig.uuid,\n                authData: this.chatEngine.me.authData,\n                chat: this.objectify()\n            } })\n            .then(() => {})\n            .catch((error) => {\n                this.chatEngine.throwError(this, 'trigger', 'auth', new Error('Something went wrong while making a request to chat server.'), { error });\n            });\n\n    }\n\n    /**\n     Perform updates when a user has left the {@link Chat}.\n\n     @private\n     */\n    userLeave(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            // if a user leaves, trigger the event\n\n            /**\n             * Fired when a {@link User} intentionally leaves a {@link Chat}.\n             *\n             * @event Chat#$\".\"offline\".\"leave\n             * @param {Object} data The data payload from the event\n             * @param {User} user The {@link User} that has left the room\n             * @example\n             * chat.on('$.offline.leave', (data) => {\n                      *     console.log('User left the room manually:', data.user);\n                      * });\n             */\n            this.trigger('$.offline.leave', {\n                user: this.users[uuid]\n            });\n\n            // remove the user from the local list of users\n            delete this.users[uuid];\n\n            // we don't remove the user from the global list,\n            // because they may be online in other channels\n\n        } else {\n\n            // that user isn't in the user list\n            // we never knew about this user or they already left\n\n            // console.log('user already left');\n        }\n    }\n\n    /**\n     Fired when a user disconnects from the {@link Chat}\n\n     @private\n     @param {String} uuid The uuid of the {@link Chat} that left\n     */\n    userDisconnect(uuid) {\n\n        // make sure this event is real, user may have already left\n        if (this.users[uuid]) {\n\n            /**\n             * Fired specifically when a {@link User} looses network connection\n             * to the {@link Chat} involuntarily.\n             *\n             * @event Chat#$\".\"offline\".\"disconnect\n             * @param {Object} data The {@link User} that disconnected\n             * @param {Object} data.user The {@link User} that disconnected\n             * @example\n             * chat.on('$.offline.disconnect', (data) => {\n                      *     console.log('User disconnected from the network:', data.user);\n                      * });\n             */\n\n            this.trigger('$.offline.disconnect', { user: this.users[uuid] });\n        }\n\n    }\n\n    /**\n     Load plugins and attach a queue of functions to execute before and\n     after events are trigger or received.\n\n     @private\n     @param {String} location Where in the middleeware the event should run (emit, trigger)\n     @param {String} event The event name\n     @param {String} first The first function to run before the plugins have run\n     @param {String} last The last function to run after the plugins have run\n     */\n    runPluginQueue(location, event, first, last) {\n\n        // this assembles a queue of functions to run as middleware\n        // event is a triggered event key\n        let pluginQueue = [];\n\n        // the first function is always required\n        pluginQueue.push(first);\n\n        // look through the configured plugins\n        this.plugins.forEach((pluginItem) => {\n            // if they have defined a function to run specifically\n            // for this event\n            if (pluginItem.middleware && pluginItem.middleware[location] && pluginItem.middleware[location][event]) {\n                // add the function to the queue\n                pluginQueue.push(pluginItem.middleware[location][event]);\n            }\n        });\n\n        // waterfall runs the functions in assigned order\n        // waiting for one to complete before moving to the next\n        // when it's done, the ```last``` parameter is called\n        waterfall(pluginQueue, last);\n\n    }\n\n    /**\n     Set the state for {@link Me} within this {@link User}.\n     Broadcasts the ```$.state``` event on other clients\n\n     @private\n     @param {Object} state The new state {@link Me} will have within this {@link User}\n     */\n    setState(state) {\n        this.chatEngine.pubnub.setState({ state, channels: [this.chatEngine.global.channel] }, () => {\n            // handle status, response\n        });\n    }\n\n    onConnectionReady() {\n\n        /**\n         * Broadcast that the {@link Chat} is connected to the network.\n         * @event Chat#$\".\"connected\n         * @example\n         * chat.on('$.connected', () => {\n                *     console.log('chat is ready to go!');\n                * });\n         */\n        this.connected = true;\n\n        // get a list of users online now\n        // ask PubNub for information about connected users in this channel\n        this.chatEngine.pubnub.hereNow({\n            channels: [this.channel],\n            includeUUIDs: true,\n            includeState: true\n        }, (status, response) => {\n            // trigger that SDK is ready before emitting online events\n            this.trigger('$.connected');\n            this.onHereNow(status, response);\n        });\n\n    }\n\n}\n\nmodule.exports = Chat;\n"},{"id":16,"identifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","name":"./src/modules/emitter.js","index":62,"index2":60,"size":2932,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/user.js","issuerId":3,"issuerName":"./src/components/user.js","profile":{"factory":30,"building":6,"dependencies":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/user.js","module":"./src/components/user.js","moduleName":"./src/components/user.js","type":"cjs require","userRequest":"../modules/emitter","loc":"3:16-45"},{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../modules/emitter","loc":"5:16-45"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"const RootEmitter = require('./root_emitter');\nconst Event = require('../components/event');\n\n/**\n An ChatEngine generic emitter that supports plugins and forwards\n events to the root emitter.\n @extends RootEmitter\n */\nclass Emitter extends RootEmitter {\n\n    constructor(chatEngine) {\n\n        super();\n\n        this.chatEngine = chatEngine;\n\n        /**\n         Emit events locally.\n\n         @private\n         @param {String} event The event payload object\n         */\n        this._emit = (event, data) => {\n\n            // all events are forwarded to ChatEngine object\n            // so you can globally bind to events with ChatEngine.on()\n            this.chatEngine._emit(event, data);\n\n            // emit the event from the object that created it\n            this.emitter.emit(event, data);\n\n        };\n\n        /**\n         * Listen for a specific event and fire a callback when it's emitted. Supports wildcard matching.\n         * @method\n         * @param {String} event The event name\n         * @param {Function} cb The function to run when the event is emitted\n         * @example\n         *\n         * // Get notified whenever someone joins the room\n         * object.on('event', (payload) => {\n                *     console.log('event was fired').\n                * })\n         *\n         * // Get notified of event.a and event.b\n         * object.on('event.*', (payload) => {\n                *     console.log('event.a or event.b was fired').;\n                * })\n         */\n        this.on = (event, cb) => {\n\n            // keep track of all events on this emitter\n            this.events[event] = this.events[event] || new Event(this.chatEngine, this, event);\n\n            // call the private _on property\n            this._on(event, cb);\n\n        };\n\n        /**\n         Stores a list of plugins bound to this object\n         @private\n         */\n        this.plugins = [];\n\n        /**\n         Binds a plugin to this object\n         @param {Object} module The plugin module\n         */\n        this.plugin = (module) => {\n\n            // add this plugin to a list of plugins for this object\n            this.plugins.push(module);\n\n            // returns the name of this class\n            let className = this.constructor.name;\n\n            // see if there are plugins to attach to this class\n            if (module.extends && module.extends[className]) {\n\n                // attach the plugins to this class\n                // under their namespace\n                this.chatEngine.addChild(this, module.namespace, new module.extends[className]());\n\n                this[module.namespace].ChatEngine = this.chatEngine;\n\n                // if the plugin has a special construct function\n                // run it\n                if (this[module.namespace].construct) {\n                    this[module.namespace].construct();\n                }\n\n            }\n        };\n    }\n\n}\n\nmodule.exports = Emitter;\n"},{"id":17,"identifier":"/Users/ian/Development/chat-engine/src/components/event.js","name":"./src/components/event.js","index":63,"index2":59,"size":2061,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/components/chat.js","issuerId":11,"issuerName":"./src/components/chat.js","profile":{"factory":7,"building":3},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":11,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/components/chat.js","module":"./src/components/chat.js","moduleName":"./src/components/chat.js","type":"cjs require","userRequest":"../components/event","loc":"6:14-44"},{"moduleId":16,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/modules/emitter.js","module":"./src/modules/emitter.js","moduleName":"./src/modules/emitter.js","type":"cjs require","userRequest":"../components/event","loc":"2:14-44"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":3,"source":"/**\n Represents an event that may be emitted or subscribed to.\n */\nclass Event {\n\n    constructor(chatEngine, chat, event) {\n\n        /**\n         Events are always a property of a {@link Chat}. Responsible for\n         listening to specific events and firing events when they occur.\n         @readonly\n         @type String\n         @see [PubNub Channels](https://support.pubnub.com/support/solutions/articles/14000045182-what-is-a-channel-)\n         */\n        this.channel = chat.channel;\n\n        /**\n         Publishes the event over the PubNub network to the {@link Event} channel\n\n         @private\n         @param {Object} data The event payload object\n         */\n        this.publish = (m) => {\n\n            m.event = event;\n\n            chatEngine.pubnub.publish({\n                message: m,\n                channel: this.channel\n            }, (status) => {\n\n                if (status.statusCode === 200) {\n                    chat.trigger('$.publish.success');\n                } else {\n                    /**\n                     * There was a problem publishing over the PubNub network.\n                     * @event Chat#$\".\"error\".\"publish\n                     */\n                    chatEngine.throwError(chat, 'trigger', 'publish', new Error('There was a problem publishing over the PubNub network.'), {\n                        errorText: status.errorData.response.text,\n                        error: status.errorData,\n                    });\n                }\n\n            });\n\n        };\n\n        /**\n         Forwards events to the Chat that registered the event {@link Chat}\n\n         @private\n         @param {Object} data The event payload object\n         */\n        this.onMessage = (m) => {\n\n            if (this.channel === m.channel && m.message.event === event) {\n                chat.trigger(m.message.event, m.message);\n            }\n\n        };\n\n        // call onMessage when PubNub receives an event\n        chatEngine.pubnub.addListener({\n            message: this.onMessage\n        });\n\n    }\n\n}\n\nmodule.exports = Event;\n"},{"id":18,"identifier":"/Users/ian/Development/chat-engine/src/index.js","name":"./src/index.js","index":0,"index2":65,"size":1516,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"issuerId":null,"issuerName":null,"profile":{"factory":18,"building":17},"failed":false,"errors":0,"warnings":0,"reasons":[],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":0,"source":"// allows asynchronous execution flow.\nconst init = require('./bootstrap');\n\n/**\nGlobal object used to create an instance of {@link ChatEngine}.\n\n@alias ChatEngineCore\n@param pnConfig {Object} ChatEngine is based off PubNub. Supply your PubNub configuration parameters here. See the getting started tutorial and [the PubNub docs](https://www.pubnub.com/docs/java-se-java/api-reference-configuration).\n@param ceConfig {Object} A list of chat engine specific config options.\n@param [ceConfig.globalChannel=chat-engine] {String} The root channel. See {@link ChatEngine.global}\n@param [ceConfig.throwErrors=true] {Boolean} Throws errors in JS console.\n@param [ceConfig.endpoint] {String} The root URL used to manage permissions for private channels.\n@return {ChatEngine} Returns an instance of {@link ChatEngine}\n@example\nChatEngine = ChatEngineCore.create({\n    publishKey: 'demo',\n    subscribeKey: 'demo'\n}, {\n    endpoint: 'http://localhost/auth',\n    globalChannel: 'chat-engine-global-channel'\n});\n*/\nconst create = (pnConfig, ceConfig = {}) => {\n\n    if (ceConfig.globalChannel) {\n        ceConfig.globalChannel = ceConfig.globalChannel.toString();\n    } else {\n        ceConfig.globalChannel = 'chat-engine';\n    }\n\n    if (typeof ceConfig.throwErrors === 'undefined') {\n        ceConfig.throwErrors = true;\n    }\n\n    // return an instance of ChatEngine\n    return init(ceConfig, pnConfig);\n\n};\n\n// export the ChatEngine api\nmodule.exports = {\n    plugin: {}, // leave a spot for plugins to exist\n    create\n};\n"},{"id":19,"identifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","name":"./src/bootstrap.js","index":1,"index2":64,"size":12800,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/index.js","issuerId":18,"issuerName":"./src/index.js","profile":{"factory":3,"building":27},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":18,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./bootstrap","loc":"2:13-35"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":1,"source":"const axios = require('axios');\nconst PubNub = require('pubnub');\n\nconst RootEmitter = require('./modules/root_emitter');\nconst Chat = require('./components/chat');\nconst Me = require('./components/me');\nconst User = require('./components/user');\n\n/**\n Provides the base Widget class...\n\n @class ChatEngine\n @extends RootEmitter\n @return {ChatEngine} Returns an instance of {@link ChatEngine}\n */\nmodule.exports = (ceConfig, pnConfig) => {\n\n    // Create the root ChatEngine object\n    let ChatEngine = new RootEmitter();\n\n    ChatEngine.ceConfig = ceConfig;\n    ChatEngine.pnConfig = pnConfig;\n\n    /**\n     * A map of all known {@link User}s in this instance of ChatEngine\n     * @memberof ChatEngine\n     */\n    ChatEngine.users = {};\n\n    /**\n     * A map of all known {@link Chat}s in this instance of ChatEngine\n     * @memberof ChatEngine\n     */\n    ChatEngine.chats = {};\n\n    /**\n     * A global {@link Chat} that all {@link User}s join when they connect to ChatEngine. Useful for announcements, alerts, and global events.\n     * @member {Chat} global\n     * @memberof ChatEngine\n     */\n    ChatEngine.global = false;\n\n    /**\n     * This instance of ChatEngine represented as a special {@link User} know as {@link Me}\n     * @member {Me} me\n     * @memberof ChatEngine\n     */\n    ChatEngine.me = false;\n\n    /**\n     * An instance of PubNub, the networking infrastructure that powers the realtime communication between {@link User}s in {@link Chats}.\n     * @member {Object} pubnub\n     * @memberof ChatEngine\n     */\n    ChatEngine.pubnub = false;\n\n    /**\n     * Indicates if ChatEngine has fired the {@link ChatEngine#$\".\"ready} event\n     * @member {Object} ready\n     * @memberof ChatEngine\n     */\n    ChatEngine.ready = false;\n\n    /**\n    * A map of {@link Chat}s that this instance of ChatEngine is representing.\n    * @type {Object}\n    */\n    ChatEngine.session = {};\n\n    ChatEngine.throwError = (self, cb, key, ceError, payload = {}) => {\n\n        if (ceConfig.throwErrors) {\n            // throw ceError;\n            throw ceError;\n        }\n\n        payload.ceError = ceError.toString();\n\n        self[cb](['$', 'error', key].join('.'), payload);\n\n    };\n\n    /**\n    Stores {@link Chat} within ```ChatEngine.session``` keyed based on the ```chat.group``` property.\n    @param {Object} chat JSON object representing {@link Chat}. Originally supplied via {@link Chat#objectify}.\n    @private\n    */\n    ChatEngine.addChatToSession = (chat) => {\n\n        // create the chat if it doesn't exist\n        ChatEngine.session[chat.group] = ChatEngine.session[chat.group] || {};\n\n        // check the chat exists within the global list but is not grouped\n        let existingChat = ChatEngine.chats[chat.channel];\n\n        // if it exists\n        if (existingChat) {\n            // assign it to the group\n            ChatEngine.session[chat.group][chat.channel] = existingChat;\n        } else {\n            // otherwise, try to recreate it with the server information\n            ChatEngine.session[chat.group][chat.channel] = new Chat(ChatEngine, chat.channel, chat.private, false, chat.group);\n\n            /**\n            * Fired when another identical instance of {@link ChatEngine} and {@link Me} joins a {@link Chat} that this instance of {@link ChatEngine} is unaware of.\n            * Used to synchronize ChatEngine sessions between desktop and mobile, duplicate windows, etc.\n            * @event ChatEngine#$\".\"session\".\"chat\".\"join\n            */\n            ChatEngine._emit('$.session.chat.join', {\n                chat: ChatEngine.session[chat.group][chat.channel]\n            });\n        }\n\n    };\n\n\n    /**\n    Removes {@link Chat} within ChatEngine.session\n    @private\n    */\n    ChatEngine.removeChatFromSession = (chat) => {\n\n        let targetChat = ChatEngine.session[chat.group][chat.channel] || chat;\n\n        /**\n        * Fired when another identical instance of {@link ChatEngine} and {@link Me} leaves a {@link Chat}.\n        * @event ChatEngine#$\".\"session\".\"chat\".\"leave\n        */\n        ChatEngine._emit('$.session.chat.leave', {\n            chat: targetChat\n        });\n\n        // don't delete from chatengine.chats, because we can still get events from this chat\n        delete ChatEngine.chats[chat.channel];\n        delete ChatEngine.session[chat.group][chat.channel];\n\n    };\n\n    /**\n     * Connect to realtime service and create instance of {@link Me}\n     * @method ChatEngine#connect\n     * @param {String} uuid A unique string for {@link Me}. It can be a device id, username, user id, email, etc.\n     * @param {Object} state An object containing information about this client ({@link Me}). This JSON object is sent to all other clients on the network, so no passwords!\n     * * @param {Strung} authKey A authentication secret. Will be sent to authentication backend for validation. This is usually an access token or password. This is different from UUID as a user can have a single UUID but multiple auth keys.\n     * @param {Object} [authData] Additional data to send to the authentication endpoint. Not used by ChatEngine SDK.\n     * @fires $\".\"connected\n     */\n    ChatEngine.connect = (uuid, state = {}, authKey = false, authData) => {\n\n        // this creates a user known as Me and\n        // connects to the global chatroom\n\n        pnConfig.uuid = uuid;\n\n        let complete = (chatData) => {\n\n            ChatEngine.pubnub = new PubNub(pnConfig);\n\n            // create a new chat to use as global chat\n            // we don't do auth on this one because it's assumed to be done with the /auth request below\n            ChatEngine.global = new Chat(ChatEngine, ceConfig.globalChannel, false, true, 'global');\n\n            // create a new user that represents this client\n            ChatEngine.me = new Me(ChatEngine, pnConfig.uuid, authData);\n\n            // create a new instance of Me using input parameters\n            ChatEngine.global.createUser(pnConfig.uuid, state);\n\n            ChatEngine.me.update(state);\n\n\n            /**\n             *  Fired when ChatEngine is connected to the internet and ready to go!\n             * @event ChatEngine#$\".\"ready\n             */\n            ChatEngine.global.on('$.connected', () => {\n\n                ChatEngine._emit('$.ready', {\n                    me: ChatEngine.me\n                });\n\n                ChatEngine.ready = true;\n\n                chatData.forEach((chatItem) => {\n                    ChatEngine.addChatToSession(chatItem);\n                });\n            });\n\n            // chats.session =\n\n            /**\n             Fires when PubNub network connection changes\n\n             @private\n             @param {Object} statusEvent The response status\n             */\n            ChatEngine.pubnub.addListener({\n                status: (statusEvent) => {\n\n                    /**\n                     * SDK detected that network is online.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"online\n                     */\n\n                    /**\n                     * SDK detected that network is down.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"offline\n                     */\n\n                    /**\n                     * A subscribe event experienced an exception when running.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"issue\n                     */\n\n                    /**\n                     * SDK was able to reconnect to pubnub.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"reconnected\n                     */\n\n                    /**\n                     * SDK subscribed with a new mix of channels.\n                     * @event ChatEngine#$\".\"network\".\"up\".\"connected\n                     */\n\n                    /**\n                     * JSON parsing crashed.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"malformed\n                     */\n\n                    /**\n                     * Server rejected the request.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"badrequest\n                     */\n\n                    /**\n                     * If using decryption strategies and the decryption fails.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"decryption\n                     */\n\n                    /**\n                     * Request timed out.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"timeout\n                     */\n\n                    /**\n                     * PAM permission failure.\n                     * @event ChatEngine#$\".\"network\".\"down\".\"denied\n                     */\n\n                    // map the pubnub events into chat engine events\n                    let categories = {\n                        PNNetworkUpCategory: 'up.online',\n                        PNNetworkDownCategory: 'down.offline',\n                        PNNetworkIssuesCategory: 'down.issue',\n                        PNReconnectedCategory: 'up.reconnected',\n                        PNConnectedCategory: 'up.connected',\n                        PNAccessDeniedCategory: 'down.denied',\n                        PNMalformedResponseCategory: 'down.malformed',\n                        PNBadRequestCategory: 'down.badrequest',\n                        PNDecryptionErrorCategory: 'down.decryption',\n                        PNTimeoutCategory: 'down.timeout'\n                    };\n\n                    let eventName = ['$', 'network', categories[statusEvent.category] || 'other'].join('.');\n\n                    if (statusEvent.affectedChannels) {\n                        statusEvent.affectedChannels.forEach((channel) => {\n                            let chat = ChatEngine.chats[channel];\n\n                            if (chat) {\n                                // connected category tells us the chat is ready\n                                if (statusEvent.category === 'PNConnectedCategory') {\n                                    chat.onConnectionReady();\n                                }\n\n                                // trigger the network events\n                                chat.trigger(eventName, statusEvent);\n                            } else {\n                                ChatEngine._emit(eventName, statusEvent);\n                            }\n                        });\n                    } else {\n                        ChatEngine._emit(eventName, statusEvent);\n                    }\n                }\n            });\n        };\n\n        let getChats = () => {\n\n            axios.get(ceConfig.endpoint + '/chats?uuid=' + pnConfig.uuid)\n                .then((response) => { complete(response.data); })\n                .catch((error) => {\n\n                    /**\n                     * There was a problem logging in\n                     * @event ChatEngine#$\".\"error\".\"session\n                     */\n                    ChatEngine.throwError(ChatEngine, '_emit', 'session', new Error('There was a problem getting session from the server (' + ceConfig.endpoint + ').'), {\n                        error\n                    });\n\n                });\n        };\n\n        pnConfig.authKey = authKey;\n\n        axios.post(ceConfig.endpoint + '/grant', {\n            uuid: pnConfig.uuid,\n            channel: ceConfig.globalChannel,\n            authData: ChatEngine.me.authData,\n            authKey: pnConfig.authKey\n        })\n            .then((response) => { getChats(response.data); })\n            .catch((error) => {\n\n                /**\n                 * There was a problem logging in\n                 * @event ChatEngine#$\".\"error\".\"auth\n                 */\n                ChatEngine.throwError(ChatEngine, '_emit', 'auth', new Error('There was a problem logging into the auth server (' + ceConfig.endpoint + ').'), { error });\n            });\n\n    };\n\n    /**\n     * The {@link Chat} class.\n     * @member {Chat} Chat\n     * @memberof ChatEngine\n     * @see {@link Chat}\n     */\n    ChatEngine.Chat = class extends Chat {\n        constructor(...args) {\n            super(ChatEngine, ...args);\n        }\n    };\n\n    /**\n     * The {@link User} class.\n     * @member {User} User\n     * @memberof ChatEngine\n     * @see {@link User}\n     */\n    ChatEngine.User = class extends User {\n        constructor(...args) {\n\n            if (ChatEngine.me.uuid === args[0]) {\n                return ChatEngine.me;\n            } else {\n                super(ChatEngine, ...args);\n            }\n\n        }\n    };\n\n    // add an object as a subobject under a namespoace\n    ChatEngine.addChild = (ob, childName, childOb) => {\n\n        // assign the new child object as a property of parent under the\n        // given namespace\n        ob[childName] = childOb;\n\n        // the new object can use ```this.parent``` to access\n        // the root class\n        childOb.parent = ob;\n\n    };\n\n    return ChatEngine;\n\n};\n"},{"id":56,"identifier":"/Users/ian/Development/chat-engine/node_modules/webpack/buildin/global.js","name":"(webpack)/buildin/global.js","index":52,"index2":37,"size":509,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","issuerId":55,"issuerName":"./node_modules/lodash/_freeGlobal.js","profile":{"factory":7,"building":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":55,"moduleIdentifier":"/Users/ian/Development/chat-engine/node_modules/lodash/_freeGlobal.js","module":"./node_modules/lodash/_freeGlobal.js","moduleName":"./node_modules/lodash/_freeGlobal.js","type":"cjs require","userRequest":"global","loc":"1:0-41"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":14,"source":"var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n"},{"id":65,"identifier":"/Users/ian/Development/chat-engine/src/components/me.js","name":"./src/components/me.js","index":65,"index2":63,"size":1836,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/ian/Development/chat-engine/src/bootstrap.js","issuerId":19,"issuerName":"./src/bootstrap.js","profile":{"factory":7,"building":12,"dependencies":1},"failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":19,"moduleIdentifier":"/Users/ian/Development/chat-engine/src/bootstrap.js","module":"./src/bootstrap.js","moduleName":"./src/bootstrap.js","type":"cjs require","userRequest":"./components/me","loc":"6:11-37"}],"usedExports":true,"providedExports":null,"optimizationBailout":[],"depth":2,"source":"const User = require('./user');\n\n/**\n Represents the client connection as a special {@link User} with write permissions.\n Has the ability to update it's state on the network. An instance of\n {@link Me} is returned by the ```ChatEngine.connect()```\n method.\n\n @class Me\n @param {String} uuid The uuid of this user\n @extends User\n */\nclass Me extends User {\n\n    constructor(chatEngine, uuid, authData) {\n\n        // call the User constructor\n        super(chatEngine, uuid);\n\n        this.authData = authData;\n        this.chatEngine = chatEngine;\n\n        this.direct.on('$.server.chat.created', (payload) => {\n            chatEngine.addChatToSession(payload.chat);\n        });\n\n\n        this.direct.on('$.server.chat.deleted', (payload) => {\n            chatEngine.removeChatFromSession(payload.chat);\n        });\n\n    }\n\n    // assign updates from network\n    assign(state) {\n        // we call \"update\" because calling \"super.assign\"\n        // will direct back to \"this.update\" which creates\n        // a loop of network updates\n        super.update(state);\n    }\n\n    /**\n     * Update {@link Me}'s state in a {@link Chat}. All other {@link User}s\n     * will be notified of this change via ```$.state```.\n     * Retrieve state at any time with {@link User#state}.\n     * @param {Object} state The new state for {@link Me}\n     * @param {Chat} chat An instance of the {@link Chat} where state will be updated.\n     * Defaults to ```ChatEngine.global```.\n     * @fires Chat#event:$\".\"state\n     * @example\n     * // update state\n     * me.update({value: true});\n     */\n    update(state, chat = this.chatEngine.global) {\n\n        // run the root update function\n        super.update(state, chat);\n\n        // publish the update over the global channel\n        this.chatEngine.global.setState(state);\n\n    }\n\n}\n\nmodule.exports = Me;\n"}],"filteredModules":57,"children":[]}